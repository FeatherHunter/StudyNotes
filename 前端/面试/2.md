[TOC]


# CSS

## 常见问题

1、行内块元素与块元素的水平居中
> 1.行内块元素，本质为行内元素，要设置居中，可以通过`text-align: center;`设置父元素来实现自己的居中。
```html
<div class="div">
    <a class="a" href="#">我要居中</a>
</div>
```
```
.div{
    width:300px;
    height:200px;
    text-align:center;        //实现子行内块元素居中
}
.a{
    display:inline-block;     //行内块元素
    width:120px;
    height:100px;
}
```
> 2.块元素，与行内元素不同，可以通过`margin:0 auto;`直接设置居中
```
<div class="div">
    <a class="a" href="#">我要居中</a>
</div>
```
```
.div{
    width:300px;
    height:200px;
}
.a{
    display:block;            //块元素
    width:120px;
    height:100px;
    margin:0 auto;           //直接设置margin值，实现居中
}
```

1、关于`margin`和`padding`的百分数形式的参照对象
> 1.margin的4个值得参考对象都是父元素的`width`;
> 2.padding的4个值得参考对象都是父元素的`width`;
```html
<div class="g-container">
    <div class="margin"></div>
</div>
```
```css
.g-container {
    height: 100px;
    width: 100px;
    background: #6f42c1;
    overflow: hidden;         //必须加上，否则子元素外边距与父元素外边距重合，会导致子元素的margin-top应用到父元素身上
}

.margin {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    margin-left: 50%;       //相对于父元素的宽，实际为50px
    margin-top: 20%;        //相对于父元素的宽，实际为20px
}
```
```css
.g-container {
    height: 100px;
    width: 100px;
    background: #6f42c1;
}

.padding {
    width: 40px;
    height: 50px;
    border: 1px solid red;
    padding-left: 50%;      //相对于父元素的宽，实际为50px
    padding-top: 20%;       //相对于父元素的宽，实际为20px
}
```

**注意点**
**1、父子元素必须都是块元素，才会发生这些现象；**
**2、如果父子元素中只有一个是块元素，不会发生这些现象，会正常显示；**


1、第一个子元素（块元素）margin-top值应用到父元素（块元素）中
> 1.原因：**外边距合并**；
> 1. 外边距合并，指的是，当两个垂直的外边距相遇时，会合并成一个外边距；
> 2. 合并后的外边距的高度等于两个发生合并的外边距中较高的；
> 3. 当一个元素出现在另一个元素上面时，第一个元素的下边距会和第二个元素的上边距合并；
> 4. 当一个元素包含另一个元素时(假如没有内边距或边框把外边距分隔开)，他们的上和/或下外边距也会发生合并。
```html
<div class="g-container">
    <div class="margin">11</div>
</div>
```
```css
.g-container {
    height: 100px;
    width: 100px;
    background: #6f42c1;
}

.margin {
    width: 40px;
    height: 50px;
    border: 1px solid red;
    margin-top: 10px;           //这个值会用到父元素中，所以父元素也会有10px的上外边距
}
```

2、解决方法
> 1.给父元素设置`border`属性；
> 2.给父元素设置`overflow: hidden;`，推荐使用；
> 3.给父元素设置内边距`padding`；
> 4.给父元素或子元素设置`float`；
> 5.给父元素或子元素设置`position:absolute;`；
```css
.g-container {
    height: 100px;
    width: 100px;
    background: #6f42c1;
    /*position: absolute;*/
    /*padding-top: 1px;*/
    /*float:left;*/
    /*border: 1px solid red;*/
    /*overflow: hidden;         //必须加上，否则子元素外边距与父元素外边距重合，会导致子元素的margin-top应用到父元素身上*/
}

.margin {
    width: 40px;
    height: 50px;
    border: 1px solid red;
    /*float:left;*/
    /*position: absolute;*/
    margin-top: 10px;
}
```

**为什么要清除浮动？**
**因为子元素浮动之后，会导致父元素的高度塌陷。**


1、父级div定义伪类：after和zoom
> 1.原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题;
> 2.优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）;
> 3.缺点：代码多，不少初学者不理解原理，要两句代码结合使用，才能让主流浏览器都支持;
> 4.建议：推荐使用，建议定义公共类，以减少CSS代码;
```html
<div class="float clear">
    <div class="fl"></div>
    <div class="fr"></div>
</div>
```
```css
.float {
    width: 500px;
    border: 1px solid red;
}

//主要代码，如果不清除浮动，父元素的高度为0
.clear {
    zoom: 1;
}

.clear:after {
    display: block;
    content: '';
    clear: both;
    visibility: hidden;
    height: 0;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

2、在结尾处添加空div标签clear:both
> 1.原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度;
> 2.优点：简单，代码少，浏览器支持好，不容易出现怪问题;
> 3.缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不爽;
> 4.建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法;
```html
<div class="float">
    <div class="fl"></div>
    <div class="fr"></div>
    <div class="clear"></div>
</div>
```
```css
.float {
    width: 500px;
    border: 1px solid red;
}

.clear {
    clear: both;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

3、父级div定义height
> 1.原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题;
> 2.优点：简单，代码少，容易掌握;
> 3.缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题;
> 4.建议：不推荐使用，只建议高度固定的布局时使用;
```html
<div class="float">
    <div class="fl"></div>
    <div class="fr"></div>
</div>
```
```css
.float {
    height:80px;            //关键代码
    width: 500px;
    border: 1px solid red;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

4、父级div定义overflow:hidden
> 1.原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度;
> 2.优点：简单，代码少，浏览器支持好;
> 3.缺点：不能和position配合使用，因为超出的尺寸的会被隐藏;
> 4.建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用;
```html
<div class="float">
    <div class="fl"></div>
    <div class="fr"></div>
</div>
```
```css
.float {
    width: 500px;
    border: 1px solid red;
    overflow: hidden;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

5、父级div定义overflow:auto
> 1.原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度;
> 2.优点：简单，代码少，浏览器支持好;
> 3.缺点：内部宽高超过父级div时，会出现滚动条。
> 4.建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。
```html
<div class="float">
    <div class="fl"></div>
    <div class="fr"></div>
</div>
```
```css
.float {
    width: 500px;
    border: 1px solid red;
    overflow: auto;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

6、父级div也一起浮动
> 1.原理：所有代码一起浮动，就变成了一个整体;
> 2.优点：没有优点;
> 3.缺点：会产生新的浮动问题。
> 4.建议：不推荐使用，只作了解。

7、父级div定义display:table
> 1.原理：将div属性变成表格;
> 2.优点：没有优点
> 3.缺点：会产生新的未知问题;
> 4.建议：不推荐使用，只作了解;

8、结尾处加br标签clear:both
> 1.原理：父级div定义zoom:1来解决IE浮动问题，结尾处加br标签clear:both;
> 2.建议：不推荐使用，只作了解

参考链接：https://www.cnblogs.com/nxl0908/p/7245460.html

## CSS3

1、border制作倒三角
> 1.将宽和高都设置为0，四个边框都变成了三角形；
> 2.将左右和下边框颜色设置为透明或与背景颜色相同的颜色，推荐透明；
> **注：两种写法：**
```
border-width:3px;
border-style:solid dashed dashed;
border-color:#333 transparent transparent;
```
```
border: 3px dashed transparent;
border-top: solid #333;
```
```html
<div class="test">
    <ul>
        <li><a href="#">建材网首页</a></li>
        <li><a href="#">我的商务室<i></i></a></li>
        <li><a href="#">我的收藏<i></i></a></li>
        <li><a href="#">建材服务<i></i></a></li>
        <li><a href="#">客服中心</a></li>
        <li><a href="#">网站导航<i></i></a></li>
    </ul>
</div>
```
```css
.test {
    height: 20px;
    border: 1px solid red;
}

.test ul li {
    float: left;
    padding-right: 10px;
    line-height: 20px;
}

.test ul li a i {
    height: 0;
    width: 0;
    /*制作倒三角*/
    border: 3px solid transparent;
    border-top: 3px solid #333;
    /*border-top-color: #333;*/
    /* 行内块元素*/
    display: inline-block;
}
```

制作倒三角详解：https://blog.csdn.net/hl_java/article/details/70148328

2、伪元素制作倒三角（before和after用法相同）
```css
span:before {
    content: "";
    border: 5px solid transparent;
    border-top-color: red;
    display: inline-block;               //一定要设置，才能调整位置
    margin-bottom:-2px;
    margin-left: 10px;
}
```
```html
<span>00</span>
```


1、div中的img标签水平数值居中的方法：
```html
<div class="div">
    <img src="img/test.jpg"/>
</div>
```
> 1.方法一:将display设置成table-cell，然后水平居中设置text-align为center，垂直居中设置vertical-align为middle
```css
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    display: table-cell;
    vertical-align: middle;
    text-align: center;
}

.div img {
    max-width: 80px;
    max-height: 80px;
}
```
> 2.方法二：弹性布局flex
```css
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    display: flex;
    justify-content: center;
    align-items: center;
}

.div img {
    max-width: 80px;
    max-height: 80px;
}
```
> 3.方法三：通过position定位实现(图片的宽和高的固定)
> **注意：有一个缺点，只有图片的尺寸固定的，才可以实现居中，因为需要设置margin值**
```CSS
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    position: relative;
}

.div img {
    /*图片的宽和高的固定*/
    width: 80px;
    height: 80px;
    position: absolute;
    top: 50%;
    left: 50%;
    /*宽和高的一般*/
    margin-top: -40px;
    margin-left: -40px;
}
```
> 3.方法四：通过position定位实现，解决了方法三中的缺陷(图片的宽和高不固定)
```css
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    position: relative;
}

.div img {
    max-width: 80px;
    max-height: 80px;
    position: absolute;
    top: 50%;
    left: 50%;
    /*宽和高的一般*/
    transform: translate(-50%,-50%);
}
```
> 5.方法五：通过position定位实现，利用margin:auto;
```css
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    position: relative;
}

.div img {
    max-width: 80px;
    max-height: 80px;
    /*关键代码*/
    position: absolute;
    top: 0;
    bottom: 0;
    right: 0;
    left: 0;
    margin: auto;
}
```

1、给div添加滚动条
> 1.方法一：
> 1. 宽和高一定要设置。
```
<div style=" overflow:scroll; width:400px; height:400px;”></div>
```
> 2.方法二：
> 1. 宽和高一定要设置。
> 2. 垂直滚动条为： overflow-y:auto；
> 3. 水平滚动条为： overflow-x:auto
```
<div style=" overflow-y:auto; overflow-x:auto; width:400px; height:400px;”></div>
```
```
<div style="height:400px; overflow:auto"></div>
```

2、修改默认的滚动条样式
> 1.如果是指定的某个class的样式，在前面天上class名即可。
> 2.下面的方法默认修改所有的滚动条；
```
/*滚动条样式*/
::-webkit-scrollbar { /*滚动条整体样式*/
    width: 4px; /*高宽分别对应横竖滚动条的尺寸*/
    height: 4px;
    scrollbar-track-color: #FFFFFF; /*滚动条底色*/
    /*滚动条隐藏*/
    display: none;
}

::-webkit-scrollbar-thumb { /*滚动条里面小方块*/
    border-radius: 5px;
    -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
    background: rgba(0, 0, 0, 0.2);
}

::-webkit-scrollbar-track { /*滚动条里面轨道*/
    -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
    border-radius: 0;
}
```

> 3.滚动条隐藏
> 1.利用 css3的新特性  -webkit-scrollbar, 但是这种方式不兼容火狐和IE
```
::-webkit-scrollbar {
    /*滚动条隐藏*/
    display: none;
}
```

1、CSS3模块有哪些？
> 1.选择器；
> 2.盒模型；
> 3.背景和边框；
> 4.文字特效；
> 5.2D/3D转换；
> 6.动画；
> 7.多列布局；
> 8.用户界面；

2、CSS3的边框有哪些属性
> 1.`border-radius`：创建圆角；
> 2.`border-shadow`：添加阴影；
> 3.`border-image`：用图片来创建边框；

3、圆角属性
> 1.基本语法：`border-radius: 1-4 length|% / 1-4 length|%;`
> 2.参数意义：
> 1. 1-4指的是radius的四个值，length和%指的是值的单位;
> 2. 第一个参数表示圆角的水平半径，第二个参数表示圆角的垂直半径；
```
//左右不对称的圆角（4个角的水平半径是2em，垂直半径是1em）
.div{border-radius: 2em/1em}
```
> 3.参数顺序：左上，右上，右下，左下；
> 4.完整的参数有8个：
```
//
div{border-radius: 100px 60px 40px 10px /20px 40px 60px 80px;}
```
```
div{
    border:2px solid;
    border-radius:25px;
    width:250px;
}

<div>border-radius 属性允许您为元素添加圆角边框！</div>
```

4、盒阴影
> 1.语法：`box-shadow: inset x-offset y-offset blur-radius spread-radius color`
> 2.参数含义：
> 1. inset：可选。阴影类型，默认为外阴影；取值为"inset"，变成内阴影；
> 2. x-offset：可正可负。阴影水平偏移量，正值：阴影在对象的右边；负值：阴影在对象的左边；
> 3. y-offset：可正可负。阴影垂直偏移量，正值：阴影在对象的底部；负值：阴影在对象的顶部；
> 4. blur-radius：可选。阴影模糊半径，只能为正。为0：阴影不具有模糊效果；
> 5. spread-radius：可选。阴影扩展半径，可正可负，正值：整个阴影都延展扩大；反之缩小；
> 6. color：可选。不设颜色，会根据浏览器取默认色。
```
.shadows{
    box-shadow: 10px 10px 5px #888888;
    height:30px;
    width:250px;
    margin:20px 0;
}

<div class="shadows"></div>
```

5、边界图片
> 1.语法：
`border-image: url top right bottom left x-repeat y-repeat：`
> 2.参数含义：
> 1. url：图片的路径；
> 2. top right bottom left：定义border-image的显示区域的，不用单位；
> 3. x-repeat y-repeat：表示图片的变换样式，包括三个值 stretch拉伸 repeat重复  round平铺；
```
.images1{
    border-image:url(border.png) 10 10 round;
    -webkit-border-image:url(border.png) 10 10 round; /* Safari 5 and older */
    -o-border-image:url(border.png) 10 10 round; /* Opera */
}

<div class="images1">这里，图像平铺（重复）来填充该区域。</div>
```

6、CSS3背景的新属性
> 1.background-image：添加背景图片；
> 2.background-size：指定背景图像的大小；
> 3.background-origin：指定背景图像的位置区域；
> 4.background-clip：背景裁剪属性，从指定位置开始绘制；

7、background-image添加背景图片
> 1.语法：
```
.back{
    width:300px;
    height: 300px;
    //下面两种写法可达到同样的效果
    background:url(border.png) left 100px top 100px no-repeat;
    /*background-image:url(border.png);*/
    /*background-position: left 100px top 100px;*/
    /*background-repeat: repeat;*/
}
<div class="back">背景图片</div>
```
> 2.添加多个背景图片时，用逗号隔开；
```
background: url(img_flwr.png) right bottom no-repeat, url(paper.png) left top repeat;
```

8、background-size指定背景图像的大小
```
//指定固定的像素或者百分比大小（相对父元素而言）
background-size: 100% 100%;
```

9、background-Origin指定背景图像的位置区域
> 1.padding-box(padding):此值为background-origin的默认值，决定background-position起始位置从padding的外边缘（border的内边缘）开始显示背景图片；
> 2.border-box(border):此值决定background-position起始位置从border的外边缘开始显示背景图片；
> 3.content-box(content):此值决定background-position起始位置从content的外边缘（padding的内边缘）开始显示背景图片；

10、background-clip从指定位置开始绘制
> 1.将背景图片以border的尺寸、以padding的尺寸，以content的尺寸进行切割，其得到的结果是不完整的背景;
```
background-clip:content-box;
```

11、CSS3渐变（gradients）是什么
> 1.定义：让你在两个或多个指定的颜色之间显示平稳的过渡；
> 2.种类：线性渐变(Linear Gradients)和径向渐变(Radial Gradients)；

12、线性渐变(Linear Gradients)
> 1.基本语法：
```
background: linear-gradient(direction, color-stop1, color-stop2, ...);
```
> 2.参数direction(预定义方向)：向下(默认)/向上(to top)/向左(to left)/向右(to right)/对角方向(to bottom right等)；
> 3.使用自定义方向(使用角度)
> 1. 语法：
```
background: linear-gradient(angle, color-stop1, color-stop2,...);
```
> 2. 角度：指水平线和渐近线之间的角度，逆时针方向计算；一般以12点钟为0deg。
> **注意：在旧的标准中，要进行换算90-x=y，其中x为标准角度，y为非标准角度(在旧标准中，把3点钟方向作为0deg)**
> 4.使用透明度(transparent)
> 1. 作用：创建减弱变淡效果；
> 2. 使用rgba()函数定义颜色结点：rgba最后一个参数定义了透明度(0表示完全透明，1表示完全不透明)；
```
background: linear-gradient(to bottom,rgba(255,0,0,0),rgba(255,0,0,1));
```
> 5.重复的线性渐变
> 1. 使用repeating-linear-gradient()函数
```
background: repeating-linear-gradient(red,yellow 10%,blue 20%);
```

13、径向渐变(Radial Gradients)
> 1.基本语法：定义渐变的中心，形状(圆形或椭圆形)，大小。
```
background: radial-gradient([ [ <shape> || <size> ] [ at <position> ]? , | at <position>, ]?<color-stop>[ , <color-stop> ]+);
```
> 2.颜色结点均匀分布(默认情况)
```
background:radial-gradient(red,blue);
```
> 3.颜色结点不均匀分布
```
background:radial-gradient(red 10%,blue 20%);
```
> 4.设置参数渐变中心点[position]
> 1. 语法：at x轴 y轴（数值或百分比）
```
background:radial-gradient(circle at 10% 20%, red, blue, yellow);
background:radial-gradient(circle at 100px 20px, red, blue, yellow);
```
> 2. 单个值，默认为center(left,right,top,center,bottom)
```
background:radial-gradient(circle at right, red, blue, yellow);
```
> 5.设置参数渐变形状[shape]，默认为ellipse(椭圆形)，circle(圆形)；
> 6.设置参数渐变的大小[size]，默认为farthest-corner
> 1. closest-side：半径为从圆心到最近边；
> 2. closest-corner：半径为从圆心到最近角；
> 3. farthest-side：半径为从圆心到最远边；
> 4. farthest-corner：半径为从圆心到最远角；
> 5. 自定义固定的长度(px)；
```
background:radial-gradient(closest-corner at center, red, blue, yellow);
background:radial-gradient(circle 60px at center, red, blue, yellow);
```
> 7.重复的径向渐变
> 1. 使用函数repeating-radial-gradient();
```
background:repeating-radial-gradient(circle 20px at center, red, blue, yellow)
```

14、CSS3文本效果有哪些
> 1.text-shadow：文本阴影；
> 2.box-shadow：盒子阴影；
> 3.text-overflow：显示溢出内容的方式
> 4.word-wrap：换行；
> 5.word-break：单词拆分换行；

15、text-shadow文本阴影
> 1.语法： text-shadow: X轴  Y轴  Rpx  color;
> 2.参数说明：阴影的x轴，阴影的y轴，阴影模糊值(大小)，阴影的颜色；
```
text-shadow:5px 5px 5px #f00;
```

16、box-shadow盒子阴影
> 1.语法： box-shadow: X轴  Y轴  Rpx  color inset(内阴影);
```
.box-img{
    font-size:12px;
    text-align:center;
    margin: 30px;
    width:100px;
    box-shadow:0 4px 8px rgba(0,0,0,0.2),0 6px 20px rgba(0,0,0,0.19);
}
//卡片效果
<div class="box-img">
    <img src="box-img.jpg" height="100" width="100"/>
    <p>Hello World!</p>
</div>
```

17、text-overflow显示溢出内容
> 1.有两个值：clip(默认值，不显示省略标记...，而是简单裁剪)和ellipsis(当文本溢出时显示省略标记...)；
> 2.注意点：
> 1. 少了`overflow:hidden`，文字会横向撑到容器外面；
> 2. 少了`white-space:nowrap`，文字会纵向撑高；
```
.overflow{
    font-size: 12px;
    width:150px;
    border:1px solid #f00;
    overflow: hidden;
    white-space: nowrap;
    text-overflow:ellipsis;
}

//三个属性必须一起使用
<div class="overflow">容器内的文本无法完全显示，可以看到它被裁剪了</div>
```

18、word-wrap换行
> 1.长文本换行；
```
word-wrap: normal;  //默认值
```

19、word-break单词拆分换行
> 1.两个值：keep-all和break-all;

20、CSS3字体@font-face
> 1.只需要将字体文件包含在网站中，会自动的下载给用户使用；
```
@font-face {
    font-family: myfont;
    src:url('Sansation_Light.ttf');
}
//使用
div{
  font-family: myfont;
}
```

21、CSS3 2D转换方法
> 1.translate()：平移；
> 2.rotate()：旋转；
> 3.scale()：缩放；
> 4.skew()：

22、translate()方法
> 1.语法:transform:translate(x,y);
> 2.根据给定的x轴和y轴参数，平移到指定的位置（原位置的空间会一直占据）；
```
.two{
    height:100px;
    width:100px;
    background-color:#f00;
    -webkit-transform: translate(100px,100px); //适用于chorme
}

<div class="two"></div>
```
> 3.translateX(n):沿着x轴移动元素；
> 4.translateY(n):沿着y轴移动元素；

23、rotate()方法
> 1.语法：transform:rotate(deg);
> 2.根据给定的度数顺时针旋转的元素。负值表示逆时针旋转；
```
<div class="two2"></div>
.two2{
    height:100px;
    width:100px;
    background-color:#f00;
    -webkit-transform:rotate(30deg); //适用于chorme
}
```

24、scale()方法
> 1.语法：transform:scale(x,y);
> 2.横坐标的宽度放大x倍，纵坐标的高度放大y倍；
```
.two3{
    height:100px;
    width:100px;
    background-color:#f00;
    transform:scale(0.2,0.3);
}
<div class="two3"></div>
```

25、skew()方法
> 1.语法：transform:skew(<angle> [,<angle>]);
> 2.分别表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0；
> 3.参数为负，表示想相反的方向倾斜；
> 4.skewX(<angle>):表示只在x轴（水平方向）倾斜；
> 5.skewY(<angle>):表示只在y轴（垂直方向）倾斜；
```
.two4{
    height:100px;
    width:100px;
    background-color:#f00;
    transform:skew(20deg,30deg);
}
<div class="two4"></div>
```

26、matrix()方法
> 1.由六个参数，包含旋转，缩放，移动和倾斜功能；
> 2.这六个参数对应矩阵：matrix(a,b,c,d,e,f);
```
a c e
b d f
0 0 1
```
> 3.平移
```
translate(x,y);
matrix(1,0,0,1,x,y);
```
> 4.缩放
```
scale(x,y);
matrix(x,0,0,y,0,0);
```
> 5.旋转
```
rotate(x);
matrix(cosx,-sinx,sinx,cosx,0,0);
```
> 6.变形
```
skew(x,y);
matrix(1,tany,tanx,1,0,0);
```

27、CSS3过渡
> 1.添加某种效果可以从一种样式转变到另一个样式（无需使用flash和javascript）；
> 2.实现方法：
> 1. 指定要添加效果的CSS属性；
> 2. 指定效果的持续时间；
```
.transition1{
    width: 100px;
    height: 100px;;
    background-color: #12aa33;
    transition:width 2s,height 2s,transform 2s,font-size 2s;
}
.transition1:hover{         //鼠标移上去的效果
    font-size:30px;
    width:130px;
    height:130px;
    transform:rotate(360deg);
}
<div class="transition1">CSS3过渡</div>
```
```
div{
   transition: width 2s;
   -moz-transition: width 2s;	    /* Firefox 4 */
   -webkit-transition: width 2s;	/* Safari 和 Chrome */
   -o-transition: width 2s;     	/* Opera */
}
```

28、CSS3动画
> 1.动画使元素从一种样式逐渐变化为另一种样式的效果；
> 2.使用百分比来规定变化发生的时间，或用关键词"from"和"to"，等同于0%和100%；
> 3.0%是动画的开始，100%是动画的完成；
> 4.使用方法：
> 1. 规定动画的名称；
> 2. 规定动画的时长；
```
//动画改变颜色
.animation{
    width: 100px;
    height: 100px;
    background-color:#f00;
    animation:myFirst 5s;
}
@keyframes myFirst{
    from {background-color:#0ff;}
    to {background-color:#0f0;}
}
<div class="animation"></div>

//动画无限循环
.animation1{
    height:100px;
    width: 100px;
    background-color:#f0f;
    position:relative;
    animation:mySecond 5s infinite;
}
@keyframes mySecond{
    0%{left:0;top:0;}
    25%{transform:rotate(20deg);left:0;}
    50%{transform:rotate(0deg);left:500px;}
    75%{transform:rotate(0deg);left:500px; background-color:#0f0;}
    100%{transform:rotate(-360deg);left:0;}
}
<div class="animation1"></div>
```

29、CSS3动画属性animation
> 1.语法：animation:[<animation-name> || <animation-duration> || <animation-timing-function> || <animation-delay> || <animation-iteration-count> || <animation-direction> || <animation-fill-mode>]
> 2.animation-name：要绑定到选择器的关键帧的名称(动画的名称)；
> 3.animation-duration：指一个动画周期持续的时间，单位秒s或毫秒ms；
> 4.animation-timing-function：定义动画的速度曲线；
> 1. ease:动画以低速开始，然后加快，在结束前变慢；
> 2. linear:匀速；
> 3. ease-in:动画以低速开始；
> 4. ease-out:动画以低速结束；
> 5. ease-in-out:动画以低速开始和结束，相对ease缓慢，速度更均匀；
> 6. step-start:按keyframes设置逐帧显示，第一帧为keyframes设置的第一帧；
> 7. step-end:按keyframes设置逐帧显示，第一帧为样式的初始值；
> 8. steps(<number>,[start|end]):把keyframes里设置的一帧等分为几帧，start表示第一次显示第一帧，end表示第一次显示样式的初始值；例如：steps(4,start);
> 9. cubic-bezier(<number>,<number>,<number>,<number>):在cubic-bezier函数中自己的值。可能的值是从0到1。贝兹曲线限制了首尾两控制点的位置，通过调整中间两控制点的位置可以灵活得到常用的动画效果。
```
贝塞尔曲线：http://cubic-bezier.com/#.17,.67,.83,.67
```
> 5.animation-delay：指动画延时执行时间，单位秒s或毫秒ms；
> 6.animation-iteration-count：动画迭代次数，默认1次，可以设置10次，。。。infinite表示无限；
> 7.animation-direction：指动画时间轴上帧前进的方向；
> 1. normal:默认值，表示一直向前，最后一帧结束后回到第一帧；
> 2. reverse:与normal的运行方向相反；
> 3. alternate:往前播放完了之后，然后在倒带，倒带到头了再往后播放；
> 4. alternate-reverse:与alternate的运行方向相反；
```
.animation1{
    height:100px;
    width: 100px;
    background-color:#f0f;
    position:relative;
    animation:mySecond 5s cubic-bezier(0,.69,1,.17) alternate infinite;
}
@keyframes mySecond{
    0%{left:0;}
    100%{left:500px;}
  }
<div class="animation1"></div>
```
> 8.animation-fill-mode>：设置动画结束后的状态；
> 1. none:默认值。不设置对象动画之外的状态，DOM未进行动画前状态；
> 2. forwards:设置对象状态为动画结束时的状态，100%或to时，当设置animation-direction为reverse时，动画结束后显示keyframes第一帧；
> 3. backwards:设置对象状态为动画开始时的状态，（测试显示DOM未进行动画前状态）；
> 4. both:设置对象状态为动画结束或开始的状态，结束时状态优先；

30、CSS3多列属性
> 1.column-count:指定了需要分割的列数；
> 2.column-gap:指定了列与列间的间隙；
> 3.column-rule:指定了列与列间的边框；
> 1. column-rule-style:指定了列与列间的边框样式；
> 2. column-rule-width:指定了列的边框厚度；
> 3. column-rule-color:指定了列的边框颜色；
```
column-rule:1px solid #f00;
//两种写法效果相同
column-rule-style:solid;
column-rule-width:1px;
column-rule-color:#f00;
```
> 4.column-span:指定元素跨多少列；
```
div{
    border:1px solid #00f;
    width:500px;
    column-gap:40px;
    column-rule:1px solid #f00;
    column-width:50px;
}
h2{
    column-span:all;
    text-align:center;
}
<div>
    <h2>多列</h2>
    “当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。”
</div>
```
> 5.column-width:指定列的宽度；
> 6.columns:设置column-width和column-count的简写（用来设置列数）；
> 1. 语法：columns: column-width column-count;
```
columns:50px;
column-width:50px;   //作用等价
```

31、CSS3弹性盒模型
> 1.组成：弹性容器和弹性子元素组成；
> 2.设置方法：将容器的display属性设置为flex或inline-flex；
```
.flex-container{
    display:flex;
    width:300px;
    height:200px;
    background-color:#0ff;
}
.flex{
    width:100px;
    height:100px;
    background-color:#ff0;
    margin:10px;
}
<div class="flex-container">     //弹性盒模型
    <div class="flex flex-first">flex-first</div>
    <div class="flex flex-second">flex-second</div>
    <div class="flex flex-third">flex-third</div>
</div>
```

32、弹性盒模型的属性
> 1.flex-direction:指定了弹性子元素在父容器中的位置；
> 1. row:横向从左到右排列(左对齐)，默认的排列方式；
> 2. row-reverse:反向横向排列(右对齐，从后往前排，最后一项排在最前面)；
> 3. column:纵向排列；
> 4. column-reverse:反向纵向排列，从后往前排，最后一项排在最上面；
> 5. 语法：flex-direction:row|row-reverse|column|column-reverse;
```
.flex-container{
    display:flex;
    width:400px;
    height:300px;
    background-color:#0ff;
    flex-direction:row;
}
```
> 2.justify-content:横向内容对齐；
> 1. flex-start:弹性项目向行头紧挨着填充；
> 2. flex-end:弹性项目向行尾紧挨着填充；
> 3. center:弹性项目居中紧挨着填充；
> 4. space-betwwen:弹性项目平均分布在该行上，两端开始填充；
> 5. space-around:弹性项目平均分布在该行上，两端留有一半的间隔空间；
```
.flex-container{
    display:flex;
    width:400px;
    height:300px;
    background-color:#0ff;
    justify-content:flex-end;
}
```
> 3.align-items:设置或检索弹性盒子元素在侧轴(纵轴)上的对齐方式；
> 1. flex-start:侧轴起始位置的边界紧靠住该行的侧轴起始边界；
> 2. flex-end:侧轴起始位置紧靠住该行的侧轴结束边界；
> 3. center:在纵轴上居中放置；
> 4. baseline:如弹性盒子元素的行内周与侧轴为同一条，则该值与"flex-start"等效。否则，该值将于基线对齐；
> 5. stretch:如果指定侧轴大小的属性值为"auto"，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸；
```
.flex-container{
    display:flex;
    width:400px;
    height:400px;
    background-color:#0ff;
    flex-direction:column;
    align-items: stretch;
}
.flex{
    width:auto;
    height:100px;
    background-color:#ff0;
    margin:10px;
}
```
> 4.flex-wrap:指定了弹性盒子的子元素换行方式；
> 1. nowrap:默认。弹性容器为单行；这种情况下，弹性盒子想可能会移除容器；
> 2. wrap:弹性容器为多行，溢出的部分会被放置到新行，子项内部会发生断行；
> 3. wrap-reverse:反转wrap排列；
> 5.align-content:用于修改flex-wrap属性的行为，设置各行的对齐；
> 1. stretch:默认。各行会伸展以占用剩余的空间；
> 2. flex-start:各行向弹性盒容器的起始位置堆叠；
> 3. flex-end:各行向弹性盒容器的结束位置堆叠；
> 4. center:各行向弹性盒容器的中间位置堆叠；
> 5. space-between:各行在弹性盒容器中平均分布；
> 6. space-around:各行在弹性容器中平均分布，两端保留子元素之间间距大小的一半；

33、弹性子元素属性
> 1.order:<integer>:用整数来定义排序顺序，数值小的排在前面(可以为负值)；
> 2.align-self:设置弹性元素自身在侧轴(纵轴)方向上的对齐方式；
```
auto/flex-start/flex-end/center/baseline/stretch
```
> 3.flex:指定弹性子元素如何分配空间；
> 1. auto: 计算值为 1 1 auto
> 2. initial: 计算值为 0 1 auto
> 3. none：计算值为 0 0 auto
> 4. inherit：从父元素继承
> 5. [ flex-grow ]：定义弹性盒子元素的扩展比率。
> 6. [ flex-shrink ]：定义弹性盒子元素的收缩比率。
> 7. [ flex-basis ]：定义弹性盒子元素的默认基准值。

34、多媒体查询
> 1.语法：
```
@media not|only mediatype and (expressions){
          //css代码
}
```
> 2.not: not是用来排除掉某些特定的设备的，比如 `@media not print`（非打印设备）；
> 3.only: 用来定某种特别的媒体类型。对于支持Media Queries的移动设备来说，如果存在only关键字，移动设备的Web浏览器会忽略only关键字并直接根据后面的表达式应用样式文件。对于不支持Media Queries的设备但能够读取Media Type类型的Web浏览器，遇到only关键字时会忽略这个样式文件；
> 4.all: 所有设备，这个应该经常看到。
> 5.css3多媒体类型：

|值|描述|
|---|---|
|all|所有多媒体类型设备|
|print|打印机|
|screen|电脑屏幕，平板，智能手机等|
|speech|屏幕阅读器|

```
@media screen and (min-width:480px) and (max-width:700px){
  body{font-size:14px;}
}
```

35、box-sizing属性
> 1.作用：允许以特定的方式定义匹配某个区域的特定元素；
> 2.语法：`box-sizing:content-box|border-box|inherit`
> 3.默认值为：content-box，宽高分别应用到元素的内容框，在宽高之外绘制元素的边框和内边距；
> 4.border-box：为元素设定的宽高决定了元素的边框盒。就是为元素指定的任何内边距和边框都在已设定的宽高之内绘制，通过已设定的宽高分别减去边框和内边距得到内容的宽高。
> 5.inherit：继承父元素的box-sizing值。
```
box-sizing: border-box;
-o-box-sizing: border-box;        //opera
-moz-box-sizing: border-box;      //firefox
-webkit-box-sizing: border-box;   //chrome和safari
```


1、CSS与HTML的作用
> 1.HTML是做数据的显示；
> 2.CSS是对页面进行修饰；

2、CSS引用的方法
> 1.内嵌在html标签中，通过`style`属性来设置
```
  <h2 style="color:blue;text-decoration:underline;font-size:14px">我的第一个CSS</h2>
```
> 2.在head标签中，通过<style>标签来定义
```
<head>
  <style type="text/css">
  h2{
    background: green;
  }
  </style>
</head>
```
> 3.引用外部css文件
```
<head>
  <link rel="stylesheet" type="text/css" href="01.css"/>
</head>
```

3、css样式的作用范围
> 1.CSS样式是按顺序，从上到下进行加载的；
> 2.不同的引入方法，都遵循这个规则。

4、css选择器
> 1.标签选择器（元素选择器）：对页面中的所有标签都有用；
```css
h2{
  background: green;     //页面中的所有的<h2>标签都会有效
}
```
> 2.id选择器，用"#"标记：对指定的标签进行修饰；
```css
p#p1{               //表示<p>标签的id="p1"
  color: yellow;
}
```
> 3.类选择器，用"."标记：对一组标签进行修饰；
```css
p.p2{               //表示<p>标签的class="p2"
  color: yellow;
}
```
> 4.属性选择器，根据元素的属性及属性值来选择元素。
> 1. 简单属性选择：选择某个属性的元素，不管属性值为什么；
```css
*[title] {                //包含title属性的所有元素，字体颜色变红
    color: red;
}

a[href] {                 //针对href属性的a元素，字体变蓝
    color: blue;
}
a[href][title] {          //同时有href和title属性的a元素，字体变黄
    color: yellow;
}
```
> 2. 特定属性值选择：只选择有特定属性值的元素（属性与属性值必须完全匹配，特别是空格分隔符）；
```css
a[href="#"][title="test"] {  //同时有href="#"和title="test"的a元素，字体变黄
    color: yellow;
}
li[class="test"] {          //这个与html中的不匹配，无效
     color: gray;
 }
li[class="test test1"] {    //这个与html中的完全匹配，有效
    color: gray;
}
```
```html
<li class="test test1">工艺美术</li>
```
> 3. 部分属性值选择：针对属性值中的某个词进行选择，使用`~`符号；
```html
<li class="test test1">工艺美术</li>
```
```css
li[class~="test"] {          //匹配属性值中的部分词
     color: orange;
 }
```
> 4. 子串匹配属性选择器

|选择器|描述|
|---|---|
|[abc^="def"]|选择abc属性，属性值以"def"开头的所有元素|
|[abc$="def"]|选择abc属性，属性值以"def"结尾的所有元素|
|[abc*="def"]|选择abc属性，属性值包含"def"子串的所有元素|
```html
<li class="test test1">工艺美术</li>
```
```css
li[class^="t"] {        //class属性值以"t"开头的所有li元素，字体变红
    color: red;
}
li[class$="1"] {        //class属性值以"1"结尾的所有li元素，字体变黄
    color: yellow;
}
li[class*="es"] {       //class属性值包含"es"子串的所有li元素，字体变蓝
    color: blue;
}
```
> 5. 特定属性选择器：选择属性值等于或以这个开头的所有元素，一般用于匹配语言值；
```html
<p lang="en">Hello!</p>            <!--英国-->
<p lang="en-us">Greetings!</p>     <!--英国-美国-->
<p lang="en-au">G'day!</p>         <!--英国-澳洲-->
```
```css
*[lang|=zh] {              //lang属性值为"en"或者以"en-"开头的所有元素，字体变红
    color: red;
}
```
> 5.包含选择器（后代选择器）：用" "标记：对一个大标签中的 **所有** 指定的标签(包括子标签中的)进行修饰；
> 1. 这里定义的样式，会在最后加载(优先级最低)；
```
div span{
  color: red;
}
//在<h3>标签中的<span>标签，也会被修饰
<div>
    我的第一个CSS我的第一<span>个CSS我的第一</span>个CSS我的第一<h3>个CS<span>S我的</span>第</h3>一个CSS我的第一个CSS我的第一<span>个CSS我的第一个CSS我的第</span>一个CSS，我的第一个CSS我的第一个CSS我的第一个CSS我的第一个CSS我的第一个CSS.
</div>
```
> 6.子对象选择器：用">"标记：只针对第一级标签进行修饰；
```
div>span{
  color: purple;
}
//只针对"个CSS我的第一"应用样式，在<h3>标签中的<span>标签不会应用
<div>
    <h3>我的<span>第一<span>个CS<h3>S我的第一<span>个CSS我的第一</span>个CSS
</div>
```
> 7.相邻兄弟选择器：选择紧接在一个元素后的元素，且二者有相同的父元素，用`+`符号；
```html
<h1>This is a heading.</h1>
<p>This is paragraph.</p>
<p>This is paragraph.</p>
```
```
h1 + p {              //表示h1元素后的第一个p元素，字体变红
    color: red;
}
```
> 8.伪类选择器：向某些元素添加特殊的效果；

|属性|描述|
|---|---|
|:active|向被激活的元素添加样式|
|:focus|向拥有键盘输入焦点的元素添加样式|
|:hover|当鼠标悬浮在元素上方时，向元素添加样式|
|:link|向未被访问的链接添加样式|
|:visited|向已被访问的链接添加样式|
|:first-child|向元素的第一个子元素添加样式，该元素的位置必须是第一个|
|:lang|向带有指定lang属性的元素添加样式|
```html
<body>
<p><i>test0</i>,00,<i>test00</i></p>    
<p><i>test1</i>,11,<i>test11</i></p>
</body>
```
```css
p:first-child{         //第一个p元素变红，是body的第一个子元素
    color: red;
}
```
> 1. first-child：表示是父元素的所有子元素中的第一个位置上的元素添加样式；
```html
<body>
<i>iiii00</i>                           <!--iiii00变红，i是body的第一个子元素-->
<p><i>test0</i>,00,<i>test00</i></p>    <!--test0变红，i是p的第一个子元素-->
<p><i>test1</i>,11,<i>test11</i></p>    <!--test1变红，i是p的第一个子元素-->
<i>iiii11</i>                           <!--iiii11无变化，不是body的第一个子元素，是第四个子元素-->
</body>
```
```html
<body>
<p><i>test0</i>,00,<i>test00</i></p>    <!--test0变红，i是p的第一个子元素-->
<p><i>test1</i>,11,<i>test11</i></p>    <!--test1变红，i是p的第一个子元素-->
<i>iiii11</i>                           <!--iiii11无变化，不是body的第一个子元素，是第三个子元素-->
</body>
```
```css
i:first-child{        
    color: red;
}
```
> 9.伪元素选择器：向某些选择器添加特殊效果；

|属性|描述|
|---|---|
|:first-letter|向文本的第一个字母添加特殊样式|
|:first-line|向文本的首行添加特殊样式|
|:before|在元素之前添加样式|
|:after|在元素之后添加样式|
```html
<span>00</span>
```
```css
span:before {               //倒三角
    content: "";
    border: 5px solid transparent;
    border-top-color: red;
    display: inline-block;
    margin-bottom:-2px;
    margin-left: 10px;
}
```
```css
span:before {              //插入一张图片
  content: url("../img/test.jpg");
}
```
> 10.分组选择符：用","隔开：同时设置对个标签的样式
```
#p1,#p2{
  font-size:20px;
}
```

5、盒子模型(box model)
> 1.padding属性：子标签距离自己的距离；
> 2.margin属性：自己距离父标签的距离；
```
//这两种样式写法的作用相同
#parent{
  border:1px solid red;
  height: 500px;
  width: 500px;
  padding:30px;
}
#child{
  border:1px solid blue;
  height: 150px;
  width: 150px;
  margin: 30px;
}
<div id="parent">
  <div id="child">
    hello
  </div>
</div>
```

6、清除标签的原来样式
> 1.一些标签有自己原来的margin和padding样式，例如`<h2>`标签；
> 2.<body>中也存在默认的margin；
> 3.清除所有的样式：
> 1. 用`*`表示所有的标签；
```
*{
  margin:0px;
  padding:0px;
}
```

7、特殊的文本标签兼容性(例如<span>和<a>)
> 1.只能设置文本的标签，在W3C标准中默认是不能用width等样式修饰的(直接对其赋值是无用的)；
> 2.要通过`display:block`之后才会有作用；
> 3.在IE中是直接使用width是有用的。

8、padding的兼容性
> 1.对于padding而言，如果一个标签设置了height或width，此时，再进行padding设置；
> 2.对于IE而言，padding值不会加到height和width中；
> 3.除了IE以外的浏览器，padding值会加到height和width中；例如，一个div高度是40，padding-top为20，此时，div的高度变成了60。
> 4.不要使用padding进行对齐操作。
```
#star span{
  border:1px solid purple;
  width:50px;
  height:30px;
  display: block;
  text-align: center;
  padding-top: 20px；
}
<div id="star">
  <span>111</span>
  <span>222</span>
  <span>333</span>
  <span>444</span>
</div>
```

9、定位：相对定位和绝对定位
> 1.absolute：绝对定位，不占据空间，会被其他元素占用；
> 1. 针对上一级的父元素中的position为absolute来进行定位；
> **2019/2/21：注：经代码检查，只要上级元素中有`position:relative;`，或者`position：absolute；`就会针对这一层的样式来进行定位。`position：relative;`有一个优点，会占据空间，不至于下面的元素顶上来，建议使用。（作用：针对某个指定的区域使用绝对定位）**
```html
<div class="container">
    <div class="list">        //绝对定位相对于container的位置开始定位

    </div>
</div>
```
```css
.container {
    position: relative;
    height: 100px;
    width: 100px;
    border: 1px solid red;
}
.list{
    position:absolute;
    left:20px;
    top:20px;
    height: 30px;
    width: 30px;
    background-color: #e227b1;
}
```
> 2. 如果父级中，没有这样的定位方式，会针对body来进行定位；
> 3. 使用方法：
```
position: absolute;
bottom: 0px;
left: 10px;
```
> 2.relative：相对定位，占据空间（哪怕这个元素已经移动到其他地方）
> 1. 针对父元素；
> 2. 使用方法：
```
position: relative;
bottom: 0px;
left: 10px;
```
> **使用：用来设置文本对齐方式**

10、给ul中的li标签添加一个自定义的小圆点
> 1.通过background属性来加载一张图片；
```
background: url("2.png") no-repeat;     //不重复填充该图片
background-position: 2px 4px;           //设置图片的位置
```

20、加载一张图片的方法
> 1.使用<img>标签：适用加载会变化的图片；
> 2.使用background属性；适用加载固定不变的图片；
> 3.区别：
> 1. 使用<img>加载图片，再次请求加载图片时，需要时间；
> 2. 使用background属性，再次请求图片，会在缓存器中读取，节约了时间；

30、float的使用
> 1.float:left
> 1. 元素会自动向左排齐；
> 2. 如果外层标签宽度不能满足float标签的宽度，会自动换行；
> 3. 对于IE而言，该标签会占据空间，其他浏览器不会占用空间；
> 4. 在使用了这个对齐方法以后，在下一个元素中药使用clear:both;来清除左右漂移；（解决浏览器兼容问题）
```
#nav ul li{
  float: left;
}
#content{
  clear:both;
}

<div id="nav">
  <ul>
    <li><span>返回首页</span></li>
    <li><span>联系我们</span></li>
  </ul>
</div>
<div id="content">内容管理</div>
```
> 2.float:right
> 1. 元素会自动向右排齐；

31、浏览器兼容的居中方法
```
position: absolute;
left:50%;
margin-left: -550px;
```

32、超链接的样式
> 1.a:link表示默认的样式；
> 2.a:visited表示访问之后的样式；
> 3.a:hover表示鼠标移到超链接上的样式
> 4.同一类的超链接可以用class来区分
> **注意：在IE中link不能自动继承visited，我们要手动配置才能够达到效果**
```
a.nav_href:link,a.nav_href:visited{
  text-decoration: none;
  font-size: 14px;
  color: blue;
}
a.nav_href:visited{
  color: red;
}
a.nav_href:hover{
  color: green;
  text-decoration: underline;
}
<a href="#" class="nav_href">超链接1</a>
<a href="#" class="nav_href">超链接2</a>
```

33、设置多个样式
> 1.添加多个类名，类名的顺序与加载样式的顺序无关，取决于样式表中的顺序；

```
li.nav_li{                            //取决于这里定义的顺序
  width:160px;
  height: 40px;
  float: left;
  text-align: center;
  border-right: 1px solid #339;
  border-bottom: 0px;
}
li.nav_last{                         //取决于这里定义的顺序
  border: none;
}

<li class="nav_li"><a href="#">工作动态</a></li>
<li class="nav_li"><a href="#">联系我们</a></li>
<li class="nav_li nav_last"><a href="#">网站帮助</a></li>     //两个效果相同
<li class="nav_last nav_li"><a href="#">网站帮助</a></li>     //两个效果相同
```

34、浏览器兼容性（CSS Hack）
> 1.Hack：不同的浏览器识别不同的css语言；
> 2.具体语法：百度css hack；

35、css选择器优先级
> 1.在不同的级别下：
```
!important > 行内样式 > ID选择器 >  类选择器|属性选择器|伪类选择器 > 标签|伪元素选择器 > 通配符 > 继承 > 浏览器默认属性
```
> 1. 子元素选择器|包含选择器，优先级相同；
> 2. 但，如果基于id或类名来写，则会比单纯的id或类选择器的优先级要高；
```html
<div class="class">
    <span class="span">你好</span>
</div>
```
```css
//这两个优先级相同，后写的有效
.class span:hover {
    color: black;
}

.class span[name="test"] {
    color: yellow;
}

//优先级较低，无效
.class span {               
    color: red;
    font-size: 16px;
}
```
> 2.在同一级别中：按书写的顺序执行；
```html
<div class="class">
    <span class="span">你好</span>
</div>
```
```css
//这两个优先级相同，则后写的有效，但，这个优先级比类选择器的优先级高
.class > span {
    color: blue;
    font-size: 10px;
}

.class span {
    color: red;
    font-size: 16px;
}

 //这个无效，优先级比较低
.span {                  
    color:yellow;
}
```
**总结：实际书写顺序**
> **1、`.class`**
> **2、`.class li`和`.class>li`和`.class+li`**
> **3、`.class li:hover`和`.class li[name="test"]`**


# ES6

1、let命令
> 1.声明变量，用法类似于var；
> 2.作用域：声明的变量仅在let命令所在的代码块有效；
```
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    }
}
a[6]();                //6
```
>**注意：可以解决js中的循环存在的问题——闭包**

2、不存在变量提升
> 1.var会出现变量提升，即变量可以在声明之前使用，值为undefined
```
// var 的情况
console.log(foo);        // 输出undefined
var foo = 2;
```
> 2.let命令，一定要声明后使用，否则报错。
```
// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```

3、暂时性死区(TDZ)
> 1.在代码块内，存在let命令和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前使用这些变量，就会报错。
> 2.在声明这些变量之前的区域称为死区。
```
var tmp = 123;    //全局变量

if (true) {
  tmp = 'abc';    // ReferenceError，报错（死区）
  let tmp;        //存在let命令
}
```
```
function bar(x = y, y = 2) {     //y还未声明
  return [x, y];
}

bar();                           // 报错   
```
```
function bar(x = 2, y = x) {     //x声明了
  return [x, y];
}
bar();                           // [2, 2]
```

4、不允许重复声明
> 1.let不允许在相同的作用域内，重复声明同一个变量；
```
// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
```

5、ES6块级作用域
> 1.外层作用域无法获取内层作用于的变量
> 2.块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了
```
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```

6、const命令
> 1.声明一个只读的常量。一旦声明，该值就不可以改变。
> 2.声明常量必须立即初始化，不能留到以后赋值；
```
const PI = 3.1415;
```

1、解构赋值
> 1.是对赋值运算符的扩展；
> 2.一种针对数组或对象进行模式匹配，然后对其中的变量进行赋值；
> 3.书写简洁易懂，语义更加清晰明了。

2、结构模型
> 1.解构的源：解构赋值表达式的右边部分；
> 2.解构的目标：解构赋值表达式的左边部分。

3、数组模型的解构（Array）
> 1.只要等号两边的模式相同，左边的变量就会被赋予对应的值
> 1. 可嵌套的
```
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3
```
> 2. 可忽略的
```
let [ , , third] = ["foo", "bar", "baz"];
third // "baz"
```
> 3. 剩余运算符
```
let [a, ...b] = [1, 2, 3];
//a = 1
//b = [2, 3]
```
> 2.解构不成功：左边的变量值为undefined；
```
let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```
> 3.不完全解构：左边的变量只匹配右边数组的一部分；
```
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```

4、解构默认值
> 1.解构赋值允许执行默认值。
```
let [foo = true] = [];    //foo=true
let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```
> 2.这里的`=`号，使用严格相等运算符`===`，判断一个位置是否有效。只有严格等于undefined时，默认值才会有效。
```
let [x = 1] = [undefined];    // x=1

let [x = 1] = [null];         // x=null
```

5、对象的解构赋值
> 1.数组的元素是按顺序排列的，变量的取值由位置来决定。
> 2.但是，对象的属性没有顺序，变量名必须与属性同名，才能取到对应的值。
> 3.基本
```
let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
// foo = 'aaa'
// bar = 'bbb'

let { baz : foo } = { baz : 'ddd' };
// foo = 'ddd'
```
> 4.可嵌套的
```
let obj = {p: ['hello', {y: 'world'}] };
let {p: [x, { y }] } = obj;
// x = 'hello'
// y = 'world'
```
> 5.可忽略的
```
let obj = {p: ['hello', {y: 'world'}] };
let {p: [x, {  }] } = obj;
// x = 'hello'
```
> 6.剩余运算符
```
let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40};
// a = 10
// b = 20
// rest = {c: 30, d: 40}
```

6、已声明的变量用于解构赋值
> 1.因为`{x}`会理解为一个代码块，从而发生语法错误。
```
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
```
> 2.解决方法：放在圆括号里面
```
// 正确的写法
let x;
({x} = {x: 1});
```
> 3.解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式
```
({} = [true, false]);
({} = 'abc');
({} = []);
```
> 4.由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构
```
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```

7、字符串的解构赋值
> 1.字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象
```
let [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

8、数值和布尔值的解构赋值
> 1.构赋值时，如果等号右边是数值和布尔值，则会先转为对象
```
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```

1、字符的 Unicode 表示法
> 1.允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点;
```
\u0061                  // "a"
```
> 2.但是，这种表示法只限于码点在`\u0000~\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示;
```
\uD842\uDFB7            // "𠮷"
```
```
\u20BB7                 // " 7"
```
> **注意：如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7**

> 3.ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。
> 4.大括号表示法与四字节的 UTF-16 编码是等价的
```
"\u{20BB7}"
// "𠮷"

"\u{41}\u{42}\u{43}"
// "ABC"

let hello = 123;
hell\u{6F} // 123

'\u{1F680}' === '\uD83D\uDE80'
// true
```

1、Symbol的作用
> 1.确保每个属性名都是独一无二的；

2、Symbol类型
> 1.本质：数据类型，表示独一无二的值；
> 2.其余数据类型：undefined，null，Boolean，String，Number，Object
> 3.Symbol值是通过`Symbol`函数生成的；
> 1. 意味着，对象的属性名现在有两种类型，一种是原来的字符串，另一种是新增的Symbol类型。
> 2. 凡是属性名属于Symbol类型，都是独一无二的值，可以保证与其他属性名不会冲突；
```
let s = Symbol();
console.log(typeof s);          //symbol
```

3、Symbol()函数
> 1.不能使用`new`命令，否则会报错；
> 2.因为函数生成的是一个数值，不是对象。
> 3.可以接受一个**字符串**作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转化为字符串时区分；
```
//如果不加参数，在控制台输出的都是Symbol()，不利于区分
let s1 = Symbol('s1');
let s2 = Symbol('s2');
console.log(s1);              //Symbol(s1)
console.log(s2);              //Symbol(s2)
```
> 4.如果Symbol的参数是一个对象，会先调用该对象的toString()方法，转化为字符串，然后生成一个Symbol值；
```
const obj={
    toString(){
        return 'abc';
    }
};
const sym = Symbol(obj);
console.log(sym);             //Symbol(abc)
```
5、Symbol函数生成的值都是独一无二的，因此相同参数的Symbol函数的返回值是不相等的；
```
let s3 = Symbol();
let s4 = Symbol();
console.log(s3===s4);             //false
```
> 6.Symbol值不能与其他类型的值进行计算，会报错；
```
let sym1 = Symbol('Niko');
console.log('my name is ' + sym1);
//Uncaught TypeError: Cannot convert a Symbol value to a string
```
> 7.symbol值可以显式转化为字符串，调用String()方法或者调用toString()方法；
```
let sym2 = Symbol('my symbol');
console.log(String(sym2));                  //'Symbol(my symbol)'
console.log(sym2.toString());               //'Symbol(my symbol)'
```
> 8.symbol值可以转化为布尔值；
```
let sym3 = Symbol('my boolean');
console.log(Boolean(sym3));                 //true
console.log(!sym2);                         //false
```

4、实例属性description：Symbol.prototype.description
> 1.作用：获取一个描述；
```
let sym3 = Symbol('my boolean');
console.log(sym3.description);            //'my boolean'
```

5、作为属性名的Symbol

# Html

1、HTML的全称是什么？作用?
>1. HyperText Markup Language(超文本标记语言)
>2. `HTML`的作用是告诉浏览器如何去显示页面。

2、超文本标记语言的标记什么意思？
>1. HTML提供一种方法使用`标签`去`标记`你的文本，来告诉浏览器你的文本的结构是什么。


1、html文件的创建
> 1.创建一个文本文件，后缀名修改为xxx.html或xxx.htm;

2、html标签
> 1.作用：指定相应显示的内容；
> 2.网页内容必须在<html>中；
> 3.每一个标签都有相应的开始和结束；
> 4.网页中的标签用小写（也可以用大写，但基于xhtml标准全是小写）；

3、html属性lang——规定网页或部分网页的语言
```
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">             //在xhtml中
...
</html>
```
> 1.html5官方文档：说明lang属性遵循BCP 47
The lang attribute (in no namespace) specifies the primary language for the element’s contents and for any of the element’s attributes that contain text. Its value must be a valid BCP 47 language tag, or the empty string. Setting the attribute to the empty string indicates that the primary language is unknown.  [BCP47]
> 2.现在只需要查看IANA就可以了。

IANA语言子标记注册表：https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry

BCP 47：https://tools.ietf.org/html/bcp47


知乎：https://www.zhihu.com/question/20797118

> 2.语言文字标签书写顺序
> 1. 常见的一般有 language、language-script 和 language-region 三种。
```
language-extlang-script-region-variant-extension-privateuse
语言文字种类-扩展语言文字种类-书写格式-国家和地区-变体-扩展-私有
```
```
language:
fr 法语
es 西班牙语

language-extlang:
zh-lzh 中文 (文言文)
sgn-csl 手语 (中国大陆)

language-script:
cmn-Hans 普通话 (简体)
yue-Hant 粤语 (繁体)

language-region:
zh-CN 中文 (简体, 中国大陆)
en-US 英语 (美国)

language-script-region：
cmn-Hans-CN 普通话 (简体, 中国大陆)
cmn-Hant-TW 普通话 (繁体, 台湾)
```
> 2.`Type: redundant`和`Deprecated`
> 1. “zh-Hant”、“zh-yue”和“zh-cmn-Hans”都是“Deprecated”
> 2. 而且，Type: redundant
> 3. 原因：“zh”和“Hant”已经被收录了，拼起来就是“zh-Hant”，再把这个当做单独条目收录，会重复，所以废弃了。而拼起来的“zh-Hant”正常使用。

3、两种写法不允许
> 1.标签不能只有开始，没有结束；
> 2.标签不能嵌套；
>```
><aaa>ggg<bbb>bbb</aaa></bbb>
>```

iso lang
www.iana.org

1、<head>标签：给搜索引擎和浏览器看的
> 1.<head>标签的内容不会在网页主体中显示，
> 2.一般用来设置标题（<title>）;
> 3.外部文件的引入；
> 4.设置<meta>中的信息；

2、<meta>标签：定义网页使用的语言
> 1.搜索引擎用关键字进行检索；
>```
><meta name="keywords" content=""/>
><meta name="description" content=""/>
>```
> 2.告诉浏览器和搜索引擎网页的信息；
> 3.`<meta charset="utf-8" />`：定义了字符编码；
> 1. 第一代语言90年：GB2313(包含6763个汉字)；
> 2. 第二代语言：GBK(包含21886个汉字，后发展到70244汉字)；
> 3. 第三代语言：UTF-8(包含200多个国家和地区的文字)

3、搜索引擎中的关键字搜索功能-爬虫
> 1.告诉搜索引擎和浏览器：网页的招牌
`<meta name="keywords" content="碰撞球，css3">`
> 2.网站的简介
`<meta name="description" content="这是最厉害的css3碰撞球特效">`

4、换行标签
> 1.<br>：标签里面没有内容，要使用自结束标签`<br/>`
> 2.<p>：前面和后面会有空行

5、body中的标题标签
> 1.`<h1>`
> 2.`<h2>`
> 3.`<h3>`
> 4.`<h4>`
> 5.`<h5>`
> 6.`<h6>`
> 7.应用：网页的某个标题部分

6、无序列表标签
> 1.`<ul>`
>```
><ul>
>    <li>唐曾</li>
>    <li>八戒</li>
></ul>
>```

7、有序列表标签
> 1.`<ol>`
>```
><ol>
>    <li>唐曾</li>
>    <li>八戒</li>
></ol>
>```

1、列表显示的方法
> 1.<ul>
>```
><ul>
>    <li>
>        <h2>网站首页</h2>
>        <ul>
>            <li>机构设置</li>
>        </ul>
>    </li>
></ul>
>```
> 2.<dl>
>```
><dl>
>    <dt>网站首页</dt>
>    <dd>机构设置</dd>
></dl>
>```

2、html中的注释标签
> 1.`<!--内容-->`

3、显示代码标签
> 1.<pre>
>```
><pre>
>for(int i = 0, i < 10; i++)
>{
>    printf(%d,i);
>}
></pre>
>```

4、转义字符，在末尾要加上分号
> 1.`&lt;`：表示小于号；
> 2.`&gt;`：表示大于号；

5、空格符
> 1.`&nbsp;`在页面中显示空格；

6、常用符号
> 1.`&copy;`：copy符号
> 2.`&amp;`：表示"&"符号

7、超链接标签<a>
> 1.<a>标签常用属性
> 1. href：链接地址
> 2. target：打开方式，默认是`_self`
>- 1.`_blank`：在一个新打开、未命名的窗口中载入目标文档。
>- 1.`_parent`：文档载入父窗口或者包含来超链接引用的框架的框架集
>- 1.`_self`：在同一个的框架或者窗口中打开
>- 1.`_top`：清除所有被包含的框架并将文档载入整个浏览器窗口。
>```
><a href="HTMLPage1.html" target="_blank" title="超链接标签">这是一个超链接</a>
>```
> 3.title：显示内容

8、插入滚动内容，已废弃
> 1.<marquee>
> 1. direction属性：设置滚动方向；
> 2. scrollamount属性：设置滚动的速度；
> 3. onmousemove属性：鼠标放在内容上，会停止；
> 4. onmouseout属性：鼠标移走，内容会继续滚动；
>```
><marquee direction="up" scrollamount="2" onmousemove="this.stop()" onmouseout="this.start()">
>    我会动
></marquee>
>```

9、图片标签<img>
> 1.alt属性：设置图片的名称，加载失败时会显示；
>```
>    <img src="1.jpg" width="300" height="300" alt="你好" title="搞笑图片"/>
>```

1、块级标签<div>
> 1.作用：设置一个容器，可以在容器中放置大量数据；

2、行内标签<span>
> 1.作用：放置文本数据，进行简单的控制；

3、表格布局：维护困难
> 1.组成部分：table，tr，td
> 2.控制样式：thead，tbody
> 1. border属性：表格有无边框
> 2. align属性：设置位置
> 3. colspan属性：合并单元格；参数即为合并的个数；
> 4. valign属性：上下的对齐
>```
><table width="900" align="left" border="1">
>    <tr>
>        <td>1.1</td>
>        <td>1.2</td>
>    </tr>
>    <tr>
>        <td>2.1</td>
>        <td>2.2</td>
>    </tr>
>    <tr>
>        <td colspan="2">3.1</td>
>    </tr>
></table>
>```

4、表格的嵌套
>```
><table width="900" align="left" border="1">      //3列的表格
>    <tr>
>        <td>1.1</td>   
>        <td>1.2</td>
>        <td>1.3</td>
>    </tr>
>    <tr>
>        <td>2.1</td>
>        <td>2.2</td>
>        <td>2.3</td>
>    </tr>
>    <tr>
>        <td colspan="3">      //先合并为一个单元格
>            <table width="900" align="left" border="1">   //    嵌套一个2列的表格
>                <tr>
>                    <td>3.1</td>
>                    <td>3.2</td>
>                </tr>
>            </table>
>        </td>
>    </tr>
></table>
>```

常用的表单

1、form表单
> 1.默认是get提交方式，提交给本页；

2、input标签
> 1.type属性：
> 1. text：文本框；
> 2. password：密码；
> 3. submit：提交按钮，会链接到form表单的action操作；
> 4. button：普通按钮；
> 5. radio：单选框（通过name属性来判断是否为同一组）；
> 6. checkbox：多选框；

3、select下拉框
> 1.通过<option>来设置下拉框中的item；

4、textarea多行文本框
> 1.cols属性：设置文本框的宽；
> 2.rows属性：设置文本框的长；

5、例子
>```
><form action="HTMLPage1.html">
>    用户名：<input type="text"/><br/>
>    密码：<input type="password"/><br/>
>    性别：<input type="radio" value="男" name="sex"/>男<input type="radio" value="女" name="sex"/>女<br/>
>    兴趣：<input type="checkbox"/>羽毛球<input type="checkbox" />蓝球<input type="checkbox" />足球<br/>
>    籍贯：<select>
>            <option>北京</option>
>            <option>上海</option>
>            <option>南京</option>
>          </select><br/>
>    个人简介：<textarea rows="10" cols="50"></textarea><br/>
>    <input type="submit" value="注册"/>
>    <input type="button" value="登陆"/><br/>
></form>
>```

框架页面

1、frameset框架页
> 1.cols属性：横向分成若干个块；
> 1. 130：表示第一部分的大小；
> 2. `*`：表示第二个部分是剩余的所有的大小；
> 3. 150：表示第三部分的大小；
>```
>cols="130,*,150"      //分成3列
>```
> 2.rows属性：纵向分成若干个块，（同上）
> 3.frameborder属性：设置有无边框；
> 4.border属性：设置边框的大小；
> 5.noresize：设置块不能拖动；
> 5.<frmae>标签：设置每一块的内容

2、<frame>标签
> 1.src属性：链接的URL；
> 2.name属性：设置标题
> 1. 可以与<a>标签中的target属性一起使用；
>```
><a href = "1.html" target = "content">超链接</a>
>//点击a标签，则会在<frame>中打开1.html
><frame src = "2.html" name = "content"></frame>
>```

3、<frameset>的嵌套
> 1.规定：cols和rows设置了几个块，就必须写几个<frame>;
> 2.注意点：frameset不能和<body>一起使用；
> 3.嵌套时不能够在<frame>中写<frameset>;
>```
><frameset rows="100,*,100" frameborder="0">
>    <frame src="HTMLPage1.html" noresize></frame>
>    <frameset cols="130,*">
>        <frame src="HTMLPage2.html"></frame>
>        <frame src="HTMLPage3.html"></frame>
>    </frameset>
>    <frame src="HTMLPage4.html" noresize></frame>
></frameset>
>```
> **注：不能够写成如下，无法正确显示**
>```
><frameset rows="100,*,100" frameborder="0">
>    <frame src="HTMLPage1.html" noresize></frame>
>    <frame>
>      <frameset cols="130,*">
>        <frame src="HTMLPage2.html"></frame>
>        <frame src="HTMLPage3.html"></frame>
>        </frameset>
>    </frame>
>    <frame src="HTMLPage4.html" noresize></frame>
></frameset>
>```

4、完整例子
>```
><!DOCTYPE html>
><html lang="en" xmlns="http://www.w3.org/1999/xhtml">
><head>
>    <meta charset="utf-8" />
>    <title>框架</title>
></head>
>
><frameset rows="100,*,100" frameborder="0">
>    <frame src="HTMLPage1.html" noresize></frame>
>    <frameset cols="130,*">
>        <frame src="HTMLPage2.html"></frame>
>        <frame src="HTMLPage3.html" name="content"></frame>
>    </frameset>
>    <frame src="HTMLPage4.html" noresize></frame>
></frameset>
></html>
>```

转载请注明链接：https://blog.csdn.net/feather_wch/article/details/79793596

1、html分为head和body标签

2、head标签存放标题以及meta数据,meta可以存放关键字、作者等数据

3、body存放网页主体内容

4、换行的几种方法？
>1. `<br/>`标签
>2. `<p>hello world<p/>`,`段落标签`-上下都会空一行。
>3. `<h1>hello<h1/>`等`标题标签`也会`换行`

5、标题标签(6级)
```html
<h1>hello<h1/>
  <h2>hello<h2/>
    <h3>hello<h3/>
      <h4>hello<h4/>
        <h5>hello<h5/>
          <h6>hello<h6/>
```

6、有序列表
```html
<ul>
    <li>剧集</li>
    <li>电影</li>
    <li>综艺</li>
    <li>动漫</li>
    <li>娱乐</li>
</ul>
```

7、无序列表
```html
<ol>
    <li>剧集</li>
    <li>电影</li>
    <li>综艺</li>
    <li>动漫</li>
    <li>娱乐</li>
</ol>
```

8、列表的子标签li可以作为布局(内部嵌套标题、列表等等)
```html
<ul>
    <li>
        <h1>剧集</h1>
        <ul>
            <li>动作片</li>
            <li>剧情片</li>
            <li>动画片</li>
        </ul>
    </li>
    <li>
        <h1>电影</h1>
        <ul>
            <li>战狼</li>
            <li>头号玩家</li>
        </ul>
    </li>
</ul>
```

9、xhtml中的列表
```xhtml
<dl>
    <dt>我是XHTML中dt的title</dt>
    <dd>纪实</dd>
    <dd>公益</dd>
    <dd>体育</dd>
</dl>
```
>html中用下列代码可以实现相同效果：
```html
<h1>
    我是HTML中的title
</h1>
<ul>
    <li>纪实</li>
    <li>公益</li>
    <li>体育</li>
</ul>
```

10、html中的注释
```html
<!-- 我是注释 -->
```

11、html中`<pre></pre>`标签显示代码段
```html
<pre>
    public class Person{
        String name;
        int age;
        boolean sex;
    }
</pre>
```

12、html中特殊的符号需要转义字符
|字符|转义字符|
|---|---|
|<   |`&lt; `  |
|>   |`&gt; `  |
|空格   | `&nbsp;`   |
|拷贝权限符号： © | `&copy`  |
| &   |`&amp;`   |

13、超链接`<a></a>`标签
```html
<a href="https://www.baidu.com/"
   target="_blank"
   title="鼠标悬浮在文字上时的提示语">这是“百度一下”的超链接</a>
```
>超链接标签也可以作为`父布局`去放置`img`等标签

14、跑马灯标签: `<marquee></marquee>`
```html
<marquee
        direction="right"
        scrollamount="5"
        onmouseover="this.stop()"
        onmouseout="this.start()">
    这是一个弹弹弹的垃圾控件
</marquee>
```
>`marquee`标签也可以作为`父布局`去放置`img`等标签

15、图片标签
```html
<img src="https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2510956726.webp"
     width="300"
     height="400"
     alt="图片没有加载时显示的内容"
     title="鼠标悬浮在图片上时显示的标题">
```

16、表格`table、tr、td标签`
```html
<table>
    <tr>
        <td>A</td>
        <td>B</td>
        <td>C</td>
    </tr>
    <tr>
        <td>D</td>
        <td>E</td>
        <td>F</td>
    </tr>
    <tr>
        <td>G</td>
        <td colspan="2">H</td>
    </tr>
</table>
```
>复杂页面用table扩展性太差，最好的办法是使用`div标签+css`

17、布局标签`div`的作用
>1. 容器, 类似于`Android中的父布局`
>2. `span标签`是作为文本的容器，可以对文本进行定位。
```html
<div>
    <ul>
        <li>
            <h1>剧集</h1>
            <ul>
                <li>动作片</li>
                <li>剧情片</li>
                <li>动画片</li>
            </ul>
        </li>
        <li>
            <h1>电影</h1>
            <ul>
                <li>战狼</li>
                <li>头号玩家</li>
            </ul>
        </li>
    </ul>
    <span>
          span标签
    </span>
</div>
```

18、html中表单是什么意思？
>1. `表单`的英文为`form`
>2. `html表单`是用于`收集`不同类型的用户输入。
```html
<form action="https://blog.csdn.net/feather_wch">
    用户名: <input type="text"><br/>
    <input type="submit"><br/>
    注册：<input type="button" value="Button">
</form>
```
>`提交`或者`回车`后会进入`action`指明的页面中。

19、表单中的单选框
>1. `name`属性进行分组。
```html
<form>
    性别:<input type="radio" value="男" name="sex">男
    <input type="radio" value="女" name="sex">女
</form>
```
20、表单的多选框
```html
<form>
    城市:<input type="checkbox" value="sh" name="city">上海
    <input type="checkbox" value="bj" name="city">北京
    <input type="checkbox" value="nj" name="city">南京
    <input type="checkbox" value="sz" name="city">深圳
</form>
```

21、下拉框
```html
<form>
    月份:<select>
      <option value="1">Ja</option>
      <option value="2">Fe</option>
      <option value="3">Ma</option>
      <option value="4">Ap</option>
    </select>
</form>
```

22、多文本输入
```html
<textarea cols="50" rows="10"></textarea>
```

# JavaScript

## 博客前端项目

1、连缀是什么
> 1.一句话同时设置一个或多个节点，两个或两个以上的操作。
> 2.例如：同时设置CSS，设置click事件等等；
```
Base.getId('box').css('color','red').html('标题').click(function(){alert('aaa')});
```
> 3.但是，Base.getId('box')返回的是一个元素节点，这个对象没有css方法
> 4.解决方法：将Base.getId('box')返回值改为Base，在Base对象中添加css方法，html方法，click事件；
> **注意：1、Base.getId('box')返回Base对象，2、Base.getId('box').css('color','red')返回Base对象，3、Base.getId('box').css('color','red').html('标题')返回Base对象，4、Base.getId('box').css('color','red').html('标题').click(function(){alert('aaa')})返回Base对象**
```js
$().getId('box').css('color', 'red').css('background', 'green').html('box').click(function () {
    alert('a')
});
$().getTagName('p').css('color', 'red').css('background', 'pink');


var $ = function () {      //创建不同的对象
    return new Base();
};

function Base() {
    //创建一个数组，来保存获取的节点和节点数组
    this.elements = [];
    //获取ID节点
    this.getId = function (id) {
        this.elements.push(document.getElementById(id));
        return this;             //返回Base对象
    };
    //获取元素节点
    this.getTagName = function (tagName) {
        var tags = document.getElementsByTagName(tagName);
        console.log(tags.length);
        for (var i = 0; i < tags.length; i++) {
            this.elements.push(tags[i]);
        }
        return this;           //返回Base对象
    };
}

Base.prototype.css = function (attr, value) {
    for (var i = 0; i < this.elements.length; i++) {
        this.elements[i].style[attr] = value;
    }
    return this;                 //返回Base对象
};
Base.prototype.html = function (str) {
    for (var i = 0; i < this.elements.length; i++) {
        this.elements[i].innerHTML = str;
    }
    return this;                //返回Base对象
};
Base.prototype.click = function (fn) {
    for (var i = 0; i < this.elements.length; i++) {
        this.elements[i].onclick = fn;
    }
    return this;               //返回Base对象
};
```
```html
<div id="box">box111</div>
<p>你好</p>
<p>你好</p>
```

1、获取内容
> 1.之前的连缀，写的方法，可以设置标题内容和CSS样式，
> 2.获取的方法：
> 1. 获取css，传一个属性值；
> 2. 获取标题，不传值；
```
console.log($().getId('box').html());
console.log($().getTagName('p').css('background'));
```

```js
//连缀
var $ = function () {      //创建不同的对象
    return new Base();
};

function Base() {
//创建一个数组，来保存获取的节点和节点数组
    this.elements = [];
}


//获取ID节点
Base.prototype.getId = function (id) {
    this.elements.push(document.getElementById(id));
    return this;             //返回Base对象
};
//获取元素节点
Base.prototype.getTagName = function (tagName) {
    let tags = document.getElementsByTagName(tagName);
    for (let i = 0; i < tags.length; i++) {
        this.elements.push(tags[i]);
    }
    return this;
};
//获取相同的节点(区域化)
Base.prototype.getClass = function (className, idName) {
    let node = null;
    if (arguments.length === 2) {
        node = document.getElementById(idName);
    } else {
        node = document;
    }
    let all = node.getElementsByTagName('*');        //获取所有的节点
    for (let i = 0; i < all.length; i++) {
        if (all[i].className === className) {        //判断是否为需要的节点
            this.elements.push(all[i]);
        }
    }
    return this;
};
//获取节点数组的某一个
Base.prototype.getElement = function (num) {
    let element = this.elements[num];
    this.elements = [];
    this.elements[0] = element;
    return this;
};
//设置css样式
Base.prototype.css = function (attr, value) {
    for (let i = 0; i < this.elements.length; i++) {
        if (arguments.length === 1) {         //获取内容，只传入一个参数为属性名
            if (typeof window.getComputedStyle !== 'undefined') {     //w3c标准，获取计算后的样式(包括外联样式表中的样式)
                return window.getComputedStyle(this.elements[i], null)[attr];
            }
            return this.elements[i].style[attr];   //直接返回这个属性值
        }
        this.elements[i].style[attr] = value;
    }
    return this;                 //返回Base对象
};
//设置link或style中的CSS规则
Base.prototype.addRule = function (num, selector, cssText, position) {
    let sheet = document.styleSheets[num];        //获取第num个样式
    if (typeof sheet.insertRule !== 'undefined') {
        sheet.insertRule(selector + "{" + cssText + "}", position);
    } else if (typeof sheet.addRule !== 'undefined') {     //低版本IE兼容
        sheet.addRule(selector, cssText, position);
    }
    return this;
};
//移除link或style中的CSS规则
Base.prototype.removeRule = function (num, index) {
    let sheet = document.styleSheets[num];
    if (typeof sheet.deleteRule !== 'undefined') {
        sheet.deleteRule(index);
    } else if (typeof sheet.removeRule !== 'undefined') {    //低版本IE兼容
        sheet.removeRule(index);
    }
    return this;
};
//添加class
Base.prototype.addClass = function (className) {
    for (let i = 0; i < this.elements.length; i++) {
        if (!this.elements[i].className.match(new RegExp('(^|\\s)' + className + '(\\s|$)'))) {    //判断className是否存在
            this.elements[i].className += ' ' + className;   //连续添加多个className，并且在两个之间留一个空格
        }
    }
    return this;
};
//移除class
Base.prototype.removeClass = function (className) {
    for (let i = 0; i < this.elements.length; i++) {
        if (this.elements[i].className.match(new RegExp('(^|\\s)' + className + '(\\s|$)'))) {    //判断className是否存在
            this.elements[i].className = this.elements[i].className.replace(new RegExp('(^|\\s)' + className + '(\\s|$)'), ' ');
        }
    }
    return this;
};
//设置内容
Base.prototype.html = function (str) {
    for (let i = 0; i < this.elements.length; i++) {
        if (arguments.length === 0) {     //获取内容，不传入参数
            return this.elements[i].innerHTML;
        }
        this.elements[i].innerHTML = str;
    }
    return this;
};
//触发点击事件
Base.prototype.click = function (fn) {
    for (let i = 0; i < this.elements.length; i++) {
        this.elements[i].onclick = fn;
    }
    return this;
};
```


1、鼠标的几个方法
> 1.hover()方法：鼠标移入移出的方法；
> 2.hide()方法：隐藏方法；
> 3.show()方法：显示方法；

2、设置下拉框的步骤
> 1.搭建页面及样式；
> 2.考虑隐藏的部分；
> 3.通过鼠标移入隐藏部分，然后移出继续隐藏；

## jQuery

1、jquery对象与DOM对象
> 1.通过jquery包装后的对象，是一个类数组对象
> 2.这个对象包含了DOM对象的信息，也封装了很多操作方法；
```
<div class="text" id="div"></div>

$(function(){
    var $div = $('#div');            //封装成类数组对象
    $div.html('jquery');             //调用其中的方法
});
```

2、DOM对象转化为jquery对象
> 1.通过`$(dom)`方法——将普通dom对象转化为jquery对象；
> 2.通过ID获得jquery对象——两种方法
> 1. 直接获取对象
>```
><div class="text" id="div"></div>
>
>$(function(){
>    var $div = $('#div');            //封装成类数组对象，直接获取ID
>    $div.html('jquery');             //调用其中的方法
>});
>```
> 2. 通过`$(dom)`方法获取js对象
>```
>$(function(){
>    var div = document.getElementById('div');     //原生js获取dom对象
>    var $div = $(div);                            //dom对象转化为jquery对象
>    $div.html('普通dom转jquery对象');
>});
>```
> 3.通过标签名获取jquery对象——`$(dom)`方法
> 1. 在原生js对象中配置是第几个标签；
>```
><div class="text" id="div"></div><br/>
><div class="text"></div><br/>
>
>var div = document.getElementsByTagName('div')[1];    //设置为第二个div
>var $div = $(div);
>$div.html('在原生js中设置第二个div中的内容');
>```
> 2. 在jquery对象中配置是第几个标签；
>```
>var div = document.getElementsByTagName('div');
>var $first = $(div).first();                          //获取第一个div
>$first.html('在jquery中设置第一个div中的内容');
>```

3、jquery对象转化为DOM对象
> 1.jquery对象本身类似于数组对象，通过`[index]`方式来获取对应的DOM对象；
```
<div class="text" id="div"></div>

var $div = $('#div');      //获取id为div的对象
var div = $div[0];
div.style.width = '50px';
```
> 2.通过`get(index)`方法来得到相应的DOM对象；
```
<div class="text" id="div"></div>
<br/>
<div class="text"></div>
<br/>

var $div = $('div');         //获取元素名为div的所有对象
var div = $div.get(1);       //得到第二个元素名为div的DOM对象
div.style.height = '50px';
```

1、简单选择器
|选择器|css模式|jquery模式|描述|
|---|---|---|---|
|元素名|div{}|$('div')|获取所有div元素的DOM对象|
|ID|#box{}|$('#box')|获取一个ID为box的DOM对象|
|类(class)|.box{}|$('.box')|获取所有class为box的DOM对象|

2、基本选择器
|选择器|css模式|jquery模式|描述|
|---|---|---|---|
|群组选择器|span,em,box{}|$('span,em,box')|获取多个选择器的DOM对象|
|后代选择器|ul li a{}|$('ul li a')|获取追溯到多个DOM对象，包括a标签之内的标签|
|通配选择器|*{}|$('*')|获取所元素标签的DOM对象|
```
<ul>
    <li><a href="#"><span>链接1</span></a></li>
    <li><a href="#"></a></li>
    <li><a href="#"><p>这是一个段落</p></a></li>
</ul>

$('ul li a').css('color','green');            //包括span标签和p标签，全部被设置为绿色
```

3、层次选择器
|选择器|描述|
|---|---|
|$('parent > child')|子选择器：选定所有指定‘parent’元素中指定的‘child’的直接子元素以及子元素中的内容（下一层及）|
|$('ancestor descendant')|后代选择器：选择给定的祖先元素的所有后代元素，一个元素的后代可能是该元素的一个孩子，孙子，曾孙等（所有层级的）|
|$('prev + next')|相邻兄弟选择器：选择所有紧接在‘prev’元素后的‘next’元素|
|$('prev ~ siblings')|一般兄弟选择器：匹配‘prev’元素之后的所有兄弟元素。具有相同的父元素，并且过滤‘siblings’选择器|
```子选择器
<div>
    <a href="#">选择器<span>测试1</span></a>
</div>

$('div>a').css('color','blue');      //“选择器”和“测试1”全部变蓝
```
```子选择器与后代选择器的区别
$('div span');           //div标签下的所有的span标签，不管什么层级的（后代选择器）
$('div>span');           //div标签的下一层级的span标签，不是所有的（子选择器）
```
```相邻兄弟选择器
<p>jquery</p>
<p id="p">jquery</p>
<p>jquery</p>

$('#p + p').css('color', 'yellow');      //只有第三个变黄
```
```一般兄弟选择器
<p>jquery</p>
<p>jquery</p>
<p id="p">jquery</p>
<p>jquery</p>
<p>jquery</p>

$('#p ~ p').css('color', 'orange');     //第四个和第五个变橙（过滤到第三个p）
```

4、层次选择器的相同点与不同点
> 1.相同点：都有一个参考节点；
> 2.不同点：
> 1. 后代选择器包含子选择器的内容；
> 2. 一般兄弟选择器包含相邻兄弟选择的内容（一般兄弟选择器和相邻兄弟选择器所选择的的元素，必须在同一个父元素下）；

5、过滤选择器
|选择器|返回|实例|
|---|---|---|
|:first|单个元素|$('div:first')：选取所有div元素中的第一个div元素|
|:last|单个元素|$('div:last')：选取所有div元素中的最后一个div元素|
|:not(selector)|集合元素|$('input:not(.myClass)')：选取类名不是myClass的input元素|
|:even|集合元素|$('input:even')：选取索引是偶数的input元素（从0开始计数）|
|:odd|集合元素|$('input:odd')：选取索引是基数的input元素|
|:eq(index)|单个元素|$('input:eq(1)')：选取索引为1的input元素|
|:gt(index)|集合元素|$('input:gt(1)')：选取索引大于1的input元素|
|:lt(index)|集合元素|$('input:lt(1)')：选取索引小于1的input元素，不包括1|
|:header|集合元素|$(':header')：选取网页中所有别的h1,h2,h3...|
|:animated|集合元素|$('div:animated')：选取正在执行动画的div元素|
```
<p>jquery</p>
<h1>你好1</h1>
<p>jquery</p>
<p id="p">jquery</p>
<p class="pp">jquery</p>
<p>jquery</p>
<h1>你好1</h1>
<h6>你好1</h6>

$('p:first').css('background','red');
$('p:last').css('background','blue');
$('p:not(.pp)').css('background','orange');
$('p:even').css('background','green');
$(':header').css('background','yellow');
```

6、属性选择器
> 1.使用XPath表达式来选择带有给定属性的元素；

|选择器|jquery模式|描述|
|---|---|---|
|[attribute]|`$('[href]')`|获取带有herf属性的元素|
|[attribute=value]|`$('[href='#']')`|获取href值为'#'的元素|
|[attribute!=value]|`$('[href!='#']')`|获取href值不为'#'的元素|
|[attribute$=value]|`$('[href$='.jpg']')`|获取herf属性值包含以'.jpg'结尾的元素|


1、jquery元素的属性
> 1.每个元素都有一个或多个特性，用来展示元素的附加信息。
> 2.attr()和removeAttr()方法

2、attr()方法
> 1.作用：获取和设置元素属性；
> 2.attr(传入属性名)：获取属性的值；
> 3.attr(属性名，属性值)：设置属性值；
> 4.attr(属性名.函数值)：设置属性的函数值；
> 5.attr(attributes)：给定元素设置多个属性值（例如：{属性名一:"属性值",属性名二:"属性值",...}）
```
<input type="text" value="php 中文网" id="ipt">

alert($("#ipt").attr('value'));
$("#ipt").attr('value','你好')
```

3、removeAttr()方法
> 1.作用：删除
> 2.removeAttr(attributeName)：为匹配的元素集合中的每个元素移除一项属性；

4、这两个方法的优点
> 1.都是封装的方法;；
> 2.直接调用方法即可；

5、html()方法
> 1.html()方法：获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容；
> 1. html()：不传入值，就是获取集合中第一个匹配元素的HTML内容；
> 2. html(htmlString)：设置每一个匹配元素的HTML内容；
> 3. html(function(index,oldhtml))：用来返回设置HTML内容的一个函数；
```
<div id="dv">php 中文网</div>

$('#dv').html();
$('#dv').html("www.php.cn");
```

6、追加内容——append(htmlString)
> 1.作用：在指定的位置加入内容(可以加入新的元素节点)
> 2.注意：与指定的元素是父子关系；
```
<div id="append">追加内容</div>

$('#append').append('<em>新内容</em>')                  //追加内容新内容(斜体)
```

7、after和before方法
> 1.after：在所有匹配的元素之后加入新的HTML内容；
> 2.before：在所有匹配元素之前加入新的HTML内容；
> 3.共同点：与指定的元素是兄弟关系
```
<div id="append">追加内容</div>

$('#append').before('<em>之前插入</em>');
$('#append').after('<em>之后插入</em>');
//之前插入(斜体)
//追加内容
//之后插入(斜体)
```

8、text()方法
> 1.作用：
> 1. 得到匹配元素集合中每个元素的文本内容结合，包括他们的后代；
> 2. 设置匹配元素集合中每个元素的文本内容为指定的文本内容；
```
```
> 2.用法
> 1. text()：得到匹配元素集合中每个元素的合并文本，包括他们的后代；
> 2. text(textString)：设置匹配元素内容的文本；
> 3. text(function(index,text))：返回设置文本内容的一个函数；
```
<div id="text">匹配集合</div>

console.log($('#text').text());               //匹配集合

$('#text').text('匹配集合22');
console.log($('#text').text());               //匹配集合22
```

9、val()方法
> 1.作用：用于处理表单元素的值，比如input，select和textarea。
> 2.val()：无参数，获取匹配的元素集合中第一个元素的值（多用来设置表单的字段的值）；
> 3.val(value)：设置匹配集合中每个元素的值；
> 4.val(function)：用来返回设置值得函数；
> **注意：val()在处理select元素时，当没有选项被选中时，它返回null**
```
<select id="see">
    <option>php 中文网</option>
    <option>php.cn</option>
    <option>小猪 CMS</option>
</select>
<p></p>

$("p").text($('#see').val());            //将p标签内的文本内容设置为‘php 中文网’
```

10、html(),text()和val()的差异
>1..html(),.text(),.val()三种方法都是用来读取选定元素的内容；
>2.只不过.html()是用来读取元素的html内容（包括html标签），
>3.text()用来读取元素的纯文本内容，包括其后代元素，
>4.val()是用来读取表单元素的"value"值。
>5.其中html()和text()方法不能使用在表单元素上,
>6.而val()只能使用在表单元素上；
>7.另外html()方法使用在多个元素上时，只读取第一个元素；
>8.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的"value"值，
>9.但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。
>10.html(htmlString),text(textString)和val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。
>11.html(),text(),val()都可以使用回调函数的返回值来动态的改变多个元素的内容。

11、addClass(className)方法
> 1.作用：动态增加类名，来增加样式；
```
<style type="text/css">
    div{
        width:200px;
        height:200px;
    }
    .bg{
        background:red;
    }
</style>

<div id="div">php 中文网</div>

$("#div").addClass('bg');       //增加"class='bg'"
```

12、removeClass(className)方法
> 1.作用：动态去除类名，来去除样式；
```
<style type="text/css">
    div{
        width:200px;
        height:200px;
    }
    .bg{
        background:red;
    }
</style>

<div id="div" class="bg">php 中文网</div>

$("#div").removeClass('bg');       //去除类名为bg的样式
```

13、toggleClass()方法
> 1.作用：addClass()与removeClass()方法的切换，动态增加和删除样式；
> 2.在匹配的元素集合中的每个元素上添加或删除一个或多个样式，取决于这个样式是否存在或值切换属性；
> 3.如果不存在，就添加类名，如果存在，就删除类名。
> 4.toggleClass(className)：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名；
> 5.toggleClass([switch])：一个用来判断样式类添加还是移除的布尔值；
> 6.toggleClass(className,switch)：一个布尔值，用于判断样式是否应该被添加或移除；
> 7.toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数
```
<style type="text/css">
body,table,td,{
    font-family: Arial, Helvetica, sans-serif;
    font-size: 12px;
}

.h {
    background: #f3f3f3;
    color: #000;
}

.c {
    background: #ebebeb;
    color: #000;
}
</style>

<table id="table" width="50%" border="0" cellpadding="3" cellspacing="1">
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
</table>

<script type="text/javascript">
//给所有的tr元素加一个class="c"的样式
$("#table tr").toggleClass("c");
</script>
<script type="text/javascript">
//给所有的偶数tr元素切换class="c"的样式
//所有基数的样式保留，偶数的被删除
$("#table tr:odd").toggleClass("c");
</script>
<script type="text/javascript">
//第二个参数判断样式类是否应该被添加或删除
//true，那么这个样式类将被添加;
//false，那么这个样式类将被移除
//所有的奇数tr元素，应该都保留class="c"样式
$("#table tr:even").toggleClass("c", true); //这个操作没有变化，因为样式已经是存在的
</script>
```

14、css()方法
> 1.作用：获取元素样式属性的计算值或者设置元素的CSS属性；
> 2.css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值;
> 3.css( propertyNames )：传递一组数组，返回一个对象结果;
> 4.css(propertyName, value )：设置CSS;
> 5.css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理;
> 6.css( properties )：可以传一个对象，同时设置多个样式;
> **注意：浏览器属性获取方式不同，在获取某些值的时候都jQuery采用统一的处理，比如颜色采用RBG，尺寸采用px**
```
<div>php 中文网</div>

$('div').css('color','red');

$("div").css({
    width:'200px',
    height:'200px',
    background:'#ccc'
});
```

1、节点的创建
> 1.创建节点(常见的：元素、属性和文本);
> 2.添加节点的一些属性;
> 3.加入到文档中
```
<ul></ul>

$(function(){
    var $li1 = $("<li>php中文网</li>");  //创建第一个li 标签
    var $li2 = $("<li>php.cn</li>");    //创建第二个li 标签

    $("ul").append($li1);              //添加到<ul>节点中，<ul>节点是<li>的父节点
    $($li1).before($li2);
})
```

2、文本节点
> 1.定义：标签中的文字内容;
```
<li>php中文网</li>                  //这里，‘php 中文网’就是文本节点
```

3、属性节点
> 1.定义：整个标签；
```
var $div = $('<div class="shuxing"></div>');     //这是一个属性节点
$('body').append($div);                          //添加到body中
```

4、节点的插入——父子关系的插入（在父元素的后面插入）
|选择器|描述|
|---|---|
|append(content)|向每个匹配的元素内部追加内容|
|appendTo(节点)|把所有匹配的元素追加到另一个、指定的元素集合中|
> **注意：与原生js方法的比较**
>**1、append操作，对应appendChild方法；**
>**2、appendTo操作，对应$(A).append(B)的操作，把A追加到B中；**
```
<div id="append">追加内容</div>

$('#append').append('<em>新内容</em>');         //添加到“追加内容”的后面
$('<em>新内容</em>').appendTo($('#append'));    
```
> 1、append()方法：前面是被插入的对象，后面是要插入的内容；
> 2.appendTo()方法：前面是要插入的内容，后面是被插入的对象；

5、节点的插入——兄弟关系的插入（after()和before()）
|选择器|描述|
|---|---|
|after(content)|在匹配元素集合中的每个元素**后面**插入参数所指定的内容，作为兄弟节点|
|before(content)|据参数设定，在匹配元素的**前面**插入内容|
> 1.两个方法都可以接收HTML字符串，DOM元素，元素数组或jQuery对象，用来插入到集合中每个匹配元素的前面或后面；
> 2.两个方法都支持多个参数传递（after(div1,div2...)）;
>**注意：**
>**1、after向元素的后面添加html代码，如果元素后面有元素了，将后面的元素后移，然后将html代码插入；**
>**2、before向元素的前面添加html代码，如果元素前面有元素了，将前面的元素前移，然后将html代码插入；**
```
<div id="append">追加内容</div>

$('#append').before('之前插入<br>','111');
$('#append').before('<em>之前插入</em>','<span>111</span>');    //顺序插入
$('#append').after('<em>之后插入</em>','<span>222</span>');
```

6、节点的插入——父子关系的插入（在父元素的前面插入）
|选择器|描述|
|---|---|
|prepend(content)|向每个匹配的元素内部前置内容|
|prependTo(节点)|把所有匹配的元素前置到另一个指定的元素集合中|
```
<div id="append">追加内容</div>
<div id="prepend">前置内容</div>

$('#prepend').prepend('<em>prepend内容</em>');    //在“前置内容”的前面插入
$('<em>prependTo内容</em>').prependTo($('#prepend'));   

$('#prepend').prependTo($('#append'));           //将整个'prepend'节点插入到'append'节点的最前面
```

7、append、appendTo、prepend、prependTo四个方法的区别
> 1.append()：向每个匹配的元素内部追加内容；
> 2.prepend()：向每个匹配的元素内部前置内容；
> 3.appendTo()：把所有匹配的元素追加到另一个指定元素的集合中；
> 4.prependTo()：把所有匹配的元素前置到另一个指定的元素集合中；

8、节点的插入——兄弟关系的插入（insertAfter()与insertBefore()）
|选择器|描述|
|---|---|
|insertAfter(节点)|内容在前，指定的元素放在后面，在匹配的元素**后面**插入内容|
|insertBefore(节点)|据参数设定，在匹配元素的**前面**插入内容|
>**注意：这两个方法不支持传递多参数；**
```
<div id="append">追加内容</div>

$('<em>insert之前插入</em>','<span>insert111</span>').insertBefore($('#append'));     //第二个参数无用，无法插入进去（不支持）
$('<em>insert之后插入</em>','<span>insert222</span>').insertAfter($('#append'));      //不支持第二个参数
```

1、empty()方法
> 1.作用：移除了指定元素中的所有子节点；
> 2.不仅移除子元素（包括其他后代元素），而且移除元素里的文本；
> **注意：指定的元素节点依然会保存，只会清空所有的子元素**
```
<div id="empty">
    <p>元素1<span>2级子元素</span></p>
    <p>元素2</p>
</div>

$('#empty').empty();                  //移除所有的子元素，但是父元素保存下来了
```

2、remove()方法
> 1.作用：移除自身及元素内的一切，包括绑定的事件及与该元素相关的jquery数据；
> 2.本质：因为删除了自身这个节点，所以该节点上的事件绑定都无效了；
```
<div id="remove">
    <p>remove方法</p>
</div>

$('#remove').on('click',function(){
    console.log('click事件');
});
$('#remove').remove();                   //整个节点全部都被删除掉了
```
> 3.**表达式参数：通过传递一个选择器表达式来过滤将被移除的匹配元素集合，可以删除指定的节点；**
```
<p>remove方法1</p>
<p>remove方法2</p>
<p>remove方法3</p>

$('p').remove(":contains('2')");     //只留下第一和第三个（移除所有p元素中包含2的元素）
```

3、empty()与remove()的区别
> 1.empty方法，是清空节点，清空元素中的所有后代节点；
> 2.empty方法，不能删除自己本身这个节点；
> 3.remove方法，删除自身及所有的后代节点；
> 4.remove方法，提供一个筛选表达式，删除指定集合中的元素；

4、detach()方法
> 1.作用：临时删除页面上的节点，但是节点上的数据和事件不会丢失，能够在下一个时间段让这个删除的节点显示出来；
> 2.detach()方法会移除对象，但在内存中还是存在的，通过append等方法，就会重新回到文档流中。
```
<p>detach方法</p>
<input type="button" value="删除p元素"/>
<input type="button" value="移动p元素"/>

var p;                    //定义一个全局变量，临时保存删除的节点
$('input:first').click(function(){
    if(!$('p').length) return;     //确保存在p节点，不存在，直接返回
    p = $('p').detach();           //存在节点，则删除，包含自身
});
$('input:last').click(function(){
    $('body').append(p);
});
```

5、detach()与remove()区别
|方法名|参数|事件及数据是否也被移除|元素自身是否被移除|
|---|---|---|---|
|remove|支持选择器表达|是|是|
|detach|支持选择器表达|否|是|

1、clone()方法——拷贝
> 1.浅拷贝：只克隆了节点结构；`.clone()`
> 2.深拷贝：不仅克隆了节点结构，而且克隆了事件和数据；`.clone(true)`
> 3.clone方法，在插入到文档前，可以修改克隆后的元素或元素内容；
```
<style>
    .clone {
        width: 300px;
        height: 200px;
    }

    .clone div {
        width: 100px;
        height: 70px;
        float: left;
        border: 1px solid #ccc;
    }
</style>

<div class="clone" id="left">
    <div id="aaron1">浅拷贝</div>
    <div id="aaron2">深拷贝</div>
</div>

$('#aaron1').on('click', function () {
    var $div1 = $('#aaron1').clone().css('color', 'red');
    $('#left').append($div);               //浅拷贝
});

$('#aaron2').on('click', function () {
    $('#left').append($(this).clone(true).css('color', 'blue'));     //深拷贝
});
```

2、replaceWith()和replaceAll()——替换
> 1.replaceWith(newContent)：
> 2.作用：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合；
```
<div id="replace">
    <p>第一段</p>
    <p>第二段</p>
    <p>第三段</p>
</div>

$('#replace>p:eq(1)').replaceWith('<span>替换新内容</span>')   //将“第二段”p节点替换为span节点
```
> 3.replaceAll(target):
> 4.作用：用集合的匹配元素替换每个目标元素；
```
<div id="replace">
    <p>第一段</p>
    <p>第二段</p>
    <p>第三段</p>
</div>

$('<a>replaceAll</a>').replaceAll('#replace>p:eq(0)')   //将“第一段”p节点替换为a节点
```
> 5.不同点：目标和源相反；
> 6.相同点：功能类似，会删除与节点相关的所有数据和事件处理程序；


3、wrap()方法——包裹单个元素
> 1.作用：给集合中匹配的每个元素周围包裹一个HTML结构(给它增加一个父元素)；
```
<p id="wrap">包裹父元素</p>

$('#wrap').wrap('<div></div>');     //给p节点外面添加一个div节点
```
> 2.wrap(function)：一个回调函数，返回用于包裹匹配元素的HTML内容或JQuery对象；
```
$('#wrap').wrap(function(){         //与上述方法效果相同
    return '<div>';
});
```
> 3.**注意：wrap()函数，可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套好几层，但只有一个核心元素**

4、unwrap()方法
> 1.作用：将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置上；
```
<div>
    <p id="unwrap">unwrap方法</p>
    <p>unwrap</p>
</div>

$('#unwrap').unwrap();     //删除父元素div节点，其余的保留
```

5、wrapAll()方法——包裹集合中的元素
> 1.wrapAll(wrappingElement):
> 2.作用：给集合中匹配的元素增加一个外面包裹HTML结构；
> 3.**注意：如果匹配的多个元素不在一个地方，则会将所有匹配的元素移动至第一个匹配元素的位置，再包裹一个父元素**
```
<a>wrapAll方法</a>
<a>wrapAll方法11</a>

$('a').wrapAll('<div></div>');
```

6、wrapInner()方法
> 1.作用：将集合中的元素内部所有子元素用其他元素包裹起来，并当做指定元素的子元素；
> 2.wrapInner(wrappingElement)：给集合中匹配的元素的内部，增加包裹的HTML结构；
```
<div id="wrapInner">
    <p>wrapInner方法11</p>
    <p>wrapInner方法00</p>
    <p>wrapInner方法33</p>
</div>

$('#wrapInner>p').wrapInner('<div class="111"></div>')    //在每个p元素的内部包裹div元素"例如：<p><div class="111">wrapInner方法33</div></p>"
```

1、children()方法——父子关系
> 1.作用：查找集合里的第一级子元素；
> 2.children()：返回匹配元素集合中每个元素的所有子元素(仅儿子辈)；
```
<div>
    <ul>
        <li>children方法11</li>
        <li>children方法22</li>
    </ul>
    <p>children段落</p>
</div>

$('div').children().css('color','red');    //所有的都变红（第一级子元素有效）
```
> 3.children(selector)：选择性的接受同一类型选择器表达式；
```
$('div').children(':first').css('color','blue');    //只有ul标签内的元素变蓝
```

2、find()方法——后代关系
> 1.作用：查找DOM树中的元素的所有后代元素；
> 2.find遍历当前元素集合中每个元素的后代，只要符合，不管是儿子，还是孙子等，都可以。
```
<div>
    <ul>
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
    </ul>
</div>

$('div').find('span').css('color','orange');
```

3、parent()方法——父子关系
> 1.作用：查找集合里面的每一个元素的父元素，有序的向上匹配元素，并根据匹配的元素创建一个新的jQuery对象；
> 2.选择性的接受同一类型选择器表达式;
```
<div><p>Hello</p></div>
<div class="selected"><p>Hello Again</p></div>

$('p').parent('.selected').css('color','gray');     //只有第二个变灰，选择类名符合的父元素，设置样式
```

4、parents()方法——祖先关系
> 1.作用：查找合集里面每个元素的所有祖先元素，有序的向上匹配，返回的元素顺序是从离他们最近的父级元素开始的；
>**注意：**
>**1.jQuery是一个合集对象，通过parents匹配的是合集中所有元素的祖先元素；**
>**2.parents()方法，选择性的接受同一类型选择器表达式，进行筛选。**
```
<body>
<div>div
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
    </ul>
    <p>children段落</p>
</div>
</body>

$('li').parents().css('color','pink');      //html中的所有字体颜色，均被设置；
```

5、parent()和parents()比较
> 1.前者只是进行了单级的DOM树查找；
> 2.`$('html').parent();`返回一个包含document的集合；
> 3.`$('html').parents();`返回空集合；


6、closest()方法
> 1.作用：从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素；
> 2.接受一个匹配元素的选择器字符串；


7、parents()和closest()比较
> 1.起始位置不同：parents开始于父元素，closest开始于当前元素；
> 2.遍历目标不同：closest要找到指定的目标，找到一个匹配的目标就停止查找；parents遍历到文档根元素，将匹配的元素加入集合中；
> 3.结果不同：closest返回包含零个或一个元素的jquery对象；parents返回包含零个或一个或多个的jquery对象；

8、next()方法——兄弟关系
> 1.作用：查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合；
> 2.选择性的接受同一类型选择器表达式；
```
<ul>ul
    <li>children<span>方法11</span></li>
    <li>children方法22</li>
    <li>children方法33</li>
</ul>

$('li').next().css('background','red');             //第二个变红
$('li').next(':last').css('background','green');    //第三个变绿
```

9、prev()方法——兄弟关系
> 1.作用：查找指定集合中每一个元素紧邻的前面同辈元素的元素集合；
> 2.选择性的接受同一类型选择器表达式；
```
<div>div
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li class="item">children方法33</li>
    </ul>
    <p>children段落</p>
</div>
<div>div2
    <ul>ul2
        <li>children<span>方法1111</span></li>
        <li>children方法2222</li>
        <li class="item">children方法3333</li>
    </ul>
    <p>children段落11</p>
</div>

$('.item').prev().css('color','red');              //两个全部变红
$('.item').prev(':first').css('color','blue');     //只有第一个变蓝
```

10、siblings()方法——兄弟关系
> 1.作用：查找指定元素集合中每一个元素的所有同辈元素
> 2.选择性的接受同一类型选择器表达式；
```
<div>div
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li class="item">children方法33</li>
        <li>children方法44</li>
    </ul>
</div>
<div>div2
    <ul>ul2
        <li>children<span>方法1111</span></li>
        <li>children方法2222</li>
        <li class="item">children方法3333</li>
        <li>children方法4444</li>
    </ul>
</div>

$('.item').siblings().css('color','red');             //所有的变红
$('.item').siblings(':first').css('color','blue');    //只有第一个变蓝
```

11、add()方法
> 1.作用：向合集中添加新的元素；
> 2.接受参数：jquery选择器表达式，DOM元素，或HTML片段；
```
<div>传递元素标签
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li class="item">children方法33</li>
        <li>children方法44</li>
    </ul>
    <p>children段落</p>
</div>

$('li').add('p').css('color','red');   //将p元素加入到li元素合集中，全部设置css样式（li元素和p元素的字体颜色都变红）
```
```
<div>传递html结构
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li class="item">children方法33</li>
        <li>children方法44</li>
    </ul>
    <p>children段落</p>
</div>
<div id="li2"></div>

$('li').add('<p>新元素</p>').appendTo($('#li2'));     //在id为li2中插入一个HTML结构（在li合集中插入了p元素，原来位置的会消失）
```

12、each()方法
> 1.作用：类似for循环迭代器，迭代jquery对象合集中的每一个DOM元素；
> 2.通过回调的方式处理，有两个固定的实参，索引与元素；
> 3.回调方法中的this指向当前迭代的dom元素。
> 4.如果提前退出，返回false在回调函数内终止循环；
```
$("li").each(function(index, element) {
    index 索引 0,1
    element是对应的li节点 li,li
    this 指向的是li
})
```
```
<div>
    <ul>
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li>children方法33</li>
        <li>children方法44</li>
    </ul>
</div>
<div>
    <ul>
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li>children方法33</li>
        <li>children方法44</li>
    </ul>
</div>

$('li').each(function(index,element){
   $(this).css('color','green');         //给所有的li元素设置样式
});

$('li').each(function (index, element) {
    if (index % 2) {
        $(this).css('color', 'blue');    //只有下标为基数的li元素设置样式
    }
});
```

1、鼠标事件——单双击事件
> 1.click方法：用于监听用户单击操作；
> 2.dbclick方法：用于监听用户双击操作；
```
<input type="button" value="单击事件"/>

$('input').click(function(){
    console.log('单击事件');
});
```

2、鼠标事件——鼠标按下和弹起事件
> 1.mousedown方法：用于监听用户鼠标按下时的操作；
> 2.mouseup方法：用于监听用户鼠标弹起的操作；
```
<input type="button" value="鼠标弹起按下事件"/>
<p>鼠标事件</p>

$('input:eq(1)').mousedown(function(){
    $('p').css('color','red');          //鼠标按下为红色
});
$('input:eq(1)').mouseup(function(){
    $('p').css('color','orange');       //鼠标弹起为橙色
});
```

3、鼠标事件——鼠标移入移出事件
> 1.mouseover方法：用于监听用户鼠标移入时的操作；
> 2.mouseout方法：用于监听用户鼠标移出时的操作；
```
<input type="button" value="鼠标移入移出事件"/>
<p>鼠标事件</p>

$('input:eq(2)').mouseover(function(){
    $('p').css('background','red');
});
$('input:eq(2)').mouseout(function(){
    $('p').css('background','pink');
});
```

4、鼠标事件——mousemove事件
> 1.定义：当鼠标指针在指定的元素中移动时，会触发该事件；
> 2.用户吧鼠标移动一个像素，就会触发该事件，会非常耗费系统资源，慎用；
```
<style>
    div{
        border:1px solid red;
        height:50px;
        width:50px;
    }
</style>

<p>鼠标事件</p>
<div></div>

$('div').mousemove(function(){
   $('p').css('color','green');          //鼠标移入这个div时，p元素变成绿色；
});
```

5、鼠标事件——mouseenter事件
> 1.定义：当元素指针穿过元素时，触发该事件；（一般与mouseleave事件一起使用）

6、mouseover和mouseenter的区别
> 1.mouseenter事件：只有鼠标穿过被选元素时才会触发；
> 2.mouseover事件：鼠标穿过任何子元素都会触发该方法；
```
div {
    height: 100px;
    width:300px;
}

<div id="over" style="background: gray;padding: 5px;"><h2 style="background:pink;">mouseover事件:<span></span></h2></div>
<br/>
<div id="enter" style="background: gray;padding: 5px;"><h2 style="background:pink;">mouseenter事件:<span></span></h2></div>

$(document).ready(function () {
    x = 0;
    y = 0;
    $('#over').mouseover(function () {
        $('#over span').text(x += 1);       //从上往下划过一次，值为3
    });
    $('#enter').mouseenter(function () {
        $('#enter span').text(y += 1);      //从上往下划过一次，值为1
    });
});
```

7、鼠标事件——mouseleave事件
> 1.定义：当元素指针离开元素时，触发该事件；

8、mouseout和mouseleave的区别
> 1.mouseleave事件：只有鼠标离开被选元素才会触发；
> 2.mouseout事件：鼠标离开任何子元素都会触发该方法，同理第六点；

9、表单事件——focus()和blur()事件
> 1.focus()事件：
> 1. 定义：当元素获得焦点时，触发该事件；
> 2. 当通过鼠标点击选中元素或通过tab键定位带元素时，该元素会获得焦点；
> 3. focus()方法会触发focus事件，或规定当发生focus事件时运行的函数；
```
<p>鼠标事件</p>
请输入：<input id="focus" type="text"/>

$('#focus').focus(function(){
    $('p').css('color','blue');       //获得焦点，p元素变蓝
});
```
> 2.blur()事件：
> 1. 定义：当元素失去焦点时，触发该事件；
> 2. blur()方法触发blur事件，或者设置了function参数，该函数也可规定当发生blur事件时执行的代码；
> 3. **早前，blur事件仅发生于表单元素，现在，可用于任何元素。**
```
<p>鼠标事件</p>
请输入：<input id="focus" type="text"/>

$('#focus').blur(function(){
    $('p').css('color','yellow');       //失去焦点，p元素变黄
});
```

10、表单事件——change()事件
> 1.定义：当元素的值发生改变时，会触发该事件；
> 2.该事件仅用于文本域(text field)，以及textarea和select元素。
> 3.**注意：当用于select元素时，change事件会在选择某个选项时发生；用于text field和textarea时，该事件会在元素失去焦点前发生；**
```
<p>鼠标事件</p>
<select>
    <option>选项1</option>
    <option>选项2</option>
    <option>选项3</option>
</select>

$('select').change(function(){
    $('p').css('color','pink');     //更换选项时，p元素会变粉
});
```

11、表单事件——select()事件
> 1.定义：当textarea或文本类型的input元素中文本被选中时，触发该事件；
> 2.select()方法触发select事件，或规定当发生select事件时运行的函数；
```
<p>鼠标事件</p>
<input id="select" type="text" value="select事件"/>

$('#select').select(function(){
    $('p').css('color','red');           //选中input里的value值时，p元素会变红
});
```

12、表单事件——submit()事件
> 1.当提交表单时，会触发该事件；
> 2.该事件只适用于表单元素；
```
<form action="#" method="post" name="form">
    用户名：<input type="text"/><br/>
    密码：<input type="text"/>
    <input type="submit" value="提交"/>
</form>

$('form').submit(function(){
   alert('error');              //点击提交按钮时，会弹出error
});
```

13、键盘事件——keydown()和keyup()事件
> 1.keydown事件：按钮被按下时触发该事件；
> **注意：如果在文档元素上进行设置，无论元素是否获取焦点，都会触发该事件。**
> 2.keyup事件：按钮被松开时触发该事件，发生在当前获得焦点的元素上。
```
$('body').keydown(function(){
    $('p').html('keydown事件');      //按下按键时触发
});

$('body').keyup(function(){
    $('p').html('keyup事件');       //松开按键时触发
});
```

14、键盘事件——keypress()事件
> 1.定义：当按钮被按下时触发，发生在当前获得焦点的元素上；
> 2.与keydown不同：每插入一个字符，就会发生keypress事件；
```
输入字符验证keypress：<input type="text"/>
<p>keypress：<span>0</span></p>

i = 0;
$('input').keypress(function () {
    $('p span').text(i += 1);            //每插入一个字符，i会加1
});
```

1、什么是AJAX
> 1.全名： Asynchronous JavaScript And XML，异步JavaScript和XML；
> 2.是一种创建交互式网页应用的网页开发技术。
> 3.是一种用于创建快速动态网页的技术；
> 4.是一种在无需加载整个页面的情况下，能够更新部分网页的技术；
> 5.实现了异步更新，即按需更新；

2、AJAX对象
> 1.基于XMLHTTPRequest对象，简称XHR对象；

3、ajax()函数实现AJAX操作
> 1.常用参数：
```
<input type="button" value="个人信息"/>
<div>
    <h3>姓名：<span id="name"></span></h3>
    <h3>工资：<span id="salary"></span></h3>
    <h3>课程：<span id="lesson"></span></h3>
    <h3>域名：<span id="siteName"></span></h3>
</div>

$('input').click(function () {
    $.ajax({                        //jquery函数
        type:"GET",                 //http请求方法
        url:"demo.json",            //要获取数据的url
        data:null,                  //不给url添加任何数据
        dataType:"json",            //获取到的数据当做json类型处理
        success:function(data){     //完成时调用这个回调函数
            $("#name").text(data.name);
            $("#salary").text(data.salary);
            $("#lesson").text(data.lesson[1]);
            $("#siteName").text(data.website.siteName);
        }
    });
});
```
```json
{
  "name": "顾文慧",
  "salary": "2222",
  "lesson": ["JQuery","javaScript"],
  "website":{
    "siteName":"百度一下",
    "domain":"www.baidu.com"
  },
  "version": "1.0.0",
  "dependencies": {

  }
}
```

4、load()方法
> 1.语法：`$(选择器).load(url,args.function(data){回调函数})`；
> 2.访问纯文本文件：
```txt文件
纯文本文件1111
```
```
<input id="txt" type="button" value="纯文本文件"/>
<div id="text"></div>

$('#txt').click(function(){
    $('#text').load("demo.txt");                  //纯文本文件
});
```
> 3.访问html文件（XML文件类似）：
```
$('#txt').click(function(){
    $('#text').load("demo.html");                    //html文件全部内容
    $('#text').load('demo.html li:first', '?' + (new Date()));          //获取html文件的第一个li标签
});
```
```html
<ul>
    <li>课程列表1</li>
    <li>课程列表1</li>
    <li>课程列表1</li>
    <li>课程列表1</li>
    <li>课程列表1</li>
</ul>
```
 > 4.访问json数据
 ```json
 {
  "name": "顾文慧",
  "salary": "2222",
  "lesson": ["JQuery","javaScript"],
  "website":{
    "siteName":"百度一下",
    "domain":"www.baidu.com"
  },
  "version": "1.0.0",
  "dependencies": {

  }
}
 ```
 ```
 $('#txt').click(function () {
     $('#text').load('demo.json',function(data){
         var jsonObj = JSON.parse(data);                             //将获取的json字符串解析为js对象
         $(this).empty()                                             //清空当前显示的json字符串内容
             .append('<p>姓名：<span>'+jsonObj.name+'</span>')
             .append('<p>工资：<span>'+jsonObj.salary+'</span>')
             .append('<p>课程：<span>'+jsonObj.lesson[0]+'</span>')
             .append('<p>域名：<span>'+jsonObj.website.siteName+'</span>')
     })
 });
 ```


 5、Ajax的核心技术——XMLHttpRequest对象
 > 1.简称为XHR对象。
 > 2.创建XHR对象，使用new方法；
 > 3.调用open()方法，启动一个请求以备发送。接受三个参数：请求类型(get,post)、请求的URL、是否异步（false同步);
 > 4.调用send()方法，发送请求。接受一个参数：作为请求主体发送的数据，如果不需要，必须填null。
 ```
 var xhr = new XMLHttpRequest();              //创建XHR对象
 xhr.open('get','demo.php',false);
 xhr.send(null);
 ```

 6、XHR对象的属性
 > 1.IE低版本浏览器，第一次向服务器端请求时，获取最新数据，而第二次就会获取缓存数据，不会获取最新的数据，解决方法，使用JS随机字符串。
 ```
 xhr.open('get', 'demo.php?rand=' + Math.random(), false);
 xhr.send(null);
 alert(xhr.responseText);
 ```

 |属性名|说明|
 |---|---|
 |responseText|作为响应主体被返回的文本|
 |responseXML|如果响应主体中的内容是'text/xml'或'application/xml'，则返回包含响应数据的XML DOM文档|
 |status|响应的HTTP状态|
 |statusText|HTTP状态的说明|

 7、HTTP状态码
 > 1.接受响应后，第一步检查status属性，以确定响应已经成功返回。
 > 2.HTTP状态码为200，表示成功。
 ```
 var xhr = new XMLHttpRequest();
 xhr.open('get', 'demo.php', false);
 xhr.send(null);
 if (xhr.status === 200) {
     console.log(xhr.responseText);
 } else {
     throw new Error('出错：状态码：' + xhr.status);
 }
 ```

 |HTTP码|状态字符串|说明|
 |---|---|---|
 |200|OK|服务器成功返回了页面|
 |400|Bad Request|语法错误导致服务器不识别|
 |401|Unauthorized|请求需要用户认证|
 |404|Not found|指定的URL在服务器上找不到|
 |500|Internal Server Error|服务器遇到意外错误，无法完成请求|
 |503|ServiceUnavailable|由于服务器过载或维护导致无法完成请求|

8、get()函数
> 1.作用：从服务器上获取数据；
> 2.用法与ajax()函数类似；

9、getJSON()函数
> 1.作用：专门处理json数据；
> 2.与get()函数的区别：不需要再解析json字符串；
```
var jsonObj = JSON.parse(data);            //不需要这个解析过程
```

10、post()函数
> 1.作用：向服务器发送数据；

1、淡入淡出方法：Fading方法——不断改变透明度(opacity)来实现
> 1.fadeIn():淡入已隐藏的元素；
> 2.fadeOut();淡出可见元素；
> 3.fadeToggle():在前两个方法之间切换；
> 4.fadeTo():允许渐变为给定的不透明度(值介于0-1之间)；

2、fadeIn()方法——显示隐藏元素
> 1.作用：淡入已隐藏的元素；
> 2.语法：`$(selector).fadeIn(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是fading完成之后所执行的函数名称；
```
.div1{
    width: 80px;
    height: 80px;
    background-color:#2e6da4;
    display: none;
}
.div2{
    width: 80px;
    height: 80px;
    background-color:#398439;
    display: none;
}
.div3{
    width: 80px;
    height: 80px;
    background-color:#761c19;
    display: none;
}

<script type="text/javascript">
    $(document).ready(function(){
        $("#fadeIn").click(function(){
            $("#div1").fadeIn("fast");
            $("#div2").fadeIn("slow");
            $("#div3").fadeIn(3000);
        });
    });
</script>

<button id="fadeIn">淡入已隐藏的元素</button><br><br>
<div class="div1" id="div1"></div><br>
<div class="div2" id="div2"></div><br>
<div class="div3" id="div3"></div><br>
```

3、fadeOut()方法——隐藏可见元素
> 1.作用：用于淡出可见元素；
> 2.语法：`$(selector).fadeOut(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是fading完成后所执行的函数名称；

4、fadeToggle()方法
> 1.作用：在fadeIn()和fadeOut()方法之间切换；
> 2.语法：`$(selector).fadeToggle(speed,callback)`

5、fadeTo()方法
> 1.作用：允许渐变为给定的不透明度(值介于0与1之间)；
> 2.语法：`$(selector).fadeTo(speed,opacity,callback)`
> 3.必须的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.必须的opacity参数将淡入淡出效果设置为给定的不透明度(值介于0与1之间)；
> 5.可选的callback参数是fading完成后所执行的函数名称；
```
$(document).ready(function(){
    $("#fadeTo").click(function(){
        $("#div111").fadeTo(3000,0.15);
        $("#div222").fadeTo("slow",0.4);
        $("#div333").fadeTo("fast",0.6);
    })
})
```

6、jQuery滑动方法——不断改变元素的高度来实现
> 1.slideDown():向下滑动元素；
> 2.slideUp():向上滑动元素；
> 3.slideToggle():在向上和向下滑动之间切换；

7、slideDown()方法
> 1.作用：向下滑动元素；
> 2.语法：`$(selector).slideDown(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；

8、slideUp()方法
> 1.作用：向上滑动元素；
> 2.语法：`$(selector).slideUp(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；

9、slideToggle()方法
> 1.作用：切换上下滑动；
> 2.语法：`$(selector).slideToggle(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；
```
$(document).ready(function(){
    $("#toggle").click(function(){
        $("#change").slideToggle();
    });
});

<button id="toggle">滑动切换</button>
<p id="change">你可以找到你所需要的所有网站建设教程</p>
```

10、显示和隐藏方法：hide()和show()——透明度，高度和宽度不断改变来实现
> 1.语法：`$(selector).hide(speed,callback)`和`$(selector).show(speed,callback)`
> 2.可选的speed参数规定隐藏/显示的速度，可以取值："slow"、"fast"或毫秒；
> 3.可选的callback参数是隐藏或显示完成后所执行的函数名称；
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#hide").click(function(){
            $("p").hide(1000);
        });
        $("#show").click(function(){
            $("p").show();
        });
    });
</script>

<p>如果点击"隐藏"，我就会消失</p>
<button id="hide">隐藏</button>
<button id="show">显示</button>
```

11、切换显示和隐藏：toggle()
> 1.语法：`$(selector).toggle(speed,callback)`
> 2.可选的speed参数规定隐藏/显示的速度，可以取值："slow"、"fast"或毫秒；
> 3.可选的callback参数是toggle()方法完成后执行的函数名称；
```
$(document).ready(function(){
    $("#toggle").click(function(){
        $("p").toggle();
    });
});

<p>如果点击"隐藏"，我就会消失</p>
<button id="toggle">切换显示和隐藏</button>
```

12、jQuery动画：animate()方法
> 1.作用：创建自定义动画；
> 2.语法：`$(selector).animate({params},speed,callback)`
> 3.必须的params参数定义形成动画的css属性；
> 4.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 5.可选的callback参数是动画完成后所执行的函数名称；
**注意：对位置进行操作，首先要把元素的CSS position属性设置为relative、fixed或absolute**
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#start").click(function(){
            $("#startAnimate").animate({left:'250px'});
        });
    });
</script>
<style>
    .start{
        height: 50px;
        width:50px;
        background-color:#f00;
        position:relative;       //设置属性
    }
</style>

<button id="start">开始动画</button>
<div class="start" id="startAnimate"></div>
```

13、animate操作多个属性
> 1.animate()方法几乎可以操作所有的css属性，
> 2.但是，在使用时，必须使用Camel标记法书写所有的属性名，例如，paddingLeft而不是padding-left；
> 3.色彩动画不包含在核心jQuery库中，需要下载 Color Animations插件；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
        left:'250px',
        opacity:'0.5',
        height:'150px'
        });
    });
});
```

14、animate()使用相对值
> 1.在值的前面加上`+=`或`-=`；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
        left:'250px',
        height:'+=150px',
        width:'-=50px'
        });
    });
});
```

15、animate()使用预定义值
> 1.show:显示；
> 2.hide:隐藏
> 3.toggle:切换显示和隐藏；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
          height:'toggle'
          });
    });
});
```

16、animate()队列功能
> 1.编写多个animate()调用，然后会逐一调用这些方法；
```
$(document).ready(function(){
    $("#start").click(function(){
         var temp = $("#startAnimate");
         temp.animate({height:'300px',opacity:'0.4'},"slow");
         temp.animate({width:'300px',opacity:'0.8'},"slow");
         temp.animate({height:'100px',opacity:'0.4'},"slow");
         temp.animate({width:'100px',opacity:'0.8'},"slow");
    });
});
```

17、stop()方法
> 1.作用：用于停止动画或效果(在他们完成之前)；
> 2.适用的效果：包括滑动，淡入淡出和自定义动画；
> 3.语法：`$(selector).stop(stopAll,goToEnd)`
> 4.可选的stopAll参数规定是否应该清楚动画队列。默认是false，仅停止活动的动画，允许任何排入队列的动画向后执行；
> 5.可选的goToEnd参数规定是否立即完成当前动画。默认是false。
**注意：默认的无参数方法：stop()会清除在被选元素上指定的当前动画**

18、stop()滑动效果，无参数
> 1.无参数：表示仅停止当前正在活动的动画，后面的动画依旧会继续执行；
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#down").click(function(){
            $("p").slideDown(5000);
        });
        $("#stop").click(function(){
            $("p").stop();
        });
    });
</script>
<style>
    p{
        display:none;
        background-color: #2e6da4;
    }
</style>

<button id="stop">停止滑动</button>
<button id="down">点击这里，向下滑动</button>
<p>Hello World!</p>
```

19、stop()动画效果，有参数
> 1.一个参数true：表示停止所有的动画，包括正在活动的动画和未活动的动画；
> 2.两个参数true：表示停止所有的动画效果，直接显示动画的结果。
```
$(document).ready(function(){
    $("#top1").click(function(){
        $("#animate").animate({left:'100px'},5000);
        $("#animate").animate({fontSize:'3em'},5000);
    });
    $("#top2").click(function(){
       $("#animate").stop();
    });
    $("#top3").click(function(){
        $("#animate").stop(true);
    });
    $("#top4").click(function(){
        $("#animate").stop(true,true);
    });
});
.animate{
    height:100px;
    width:100px;
    background-color: #1b6d85;
    position: relative;
}

<button id="top1">开始</button>
<button id="top2">停止</button>
<button id="top3">停止所有</button>
<button id="top4">停止但要完成</button>
<div class="animate" id="animate">Hello</div>
```

1、多库共存
> 1.存在两个库都使用了`$`符号，就存在冲突；
> 2.解决：jquery库可以释放`$`的使用，让另一个库正常使用，此时的jquery库只能使用jQuery了；
> 3.jquery库释放`$`符：`jQuery.noConflict();`

1、onload和ready的写法
```
window.onload = function(){

}

$(function(){

})
$(document).ready(function(){       //等同于第二种写法

})
```

2、onload和ready的执行顺序
> 1.window.onload
> 1. 包括页面的图片加载完成之后才会调用（晚）；
> 2. 只能有一个回调监听；
```
```
> 2.$(document).ready()
> 1. 等同于：`$(function(){})`；
> 2. 页面加载完成就回调，不管图片（早）；
> 3. 可以有多个监听回调；

1、自定义插件
> 1.扩展`$`的工具方法：`$.extend();`
> 2.扩展`$()`的功能方法；`$.fn.extend();`
```
(function () {              //立即执行函数
    /*
* 给 $ 添加4个工具方法
* min(a,b)：返回较小值；
* max(a,b)：返回较大值；
* leftTrim()：去掉字符串左边的空格；
* rightTrim()：去掉字符串右边的空格；
*
* 例如：$.min(3,8);
* */
    $.extend({
        min: function (a, b) {
            return a < b ? a : b;
        },
        max: function (a, b) {
            return a < b ? b : a;
        },
        leftTrim: function (str) {
            return str.replace(/^\s+/, '');
        },
        rightTrim: function (str) {
            return str.replace(/\s+$/, '');
        }
    });

    /*
* 给jquery对象 添加3个功能方法(针对checkbox的应用)
* checkAll()：全选；
* uncheckAll()：全不选；
* reverseCheck()：全反选；
*
* 例如：$('input').checkAll();
* */
    $.fn.extend({
        checkAll: function () {
            this.prop('checked', true);                   //this指jquery对象
        },
        uncheckAll: function () {
            this.prop('checked', 'false');
        },
        reverseCheck: function () {
            this.each(function () {                       //this指jquery对象
                this.checked = !this.checked;             //this指dom元素
            })
        }
    })
})();
```

1、jquery-validation
> 1.主要用于做表单验证；
> 2.验证规则：
```
messages: {
	required: "This field is required.",
	remote: "Please fix this field.",
	email: "Please enter a valid email address.",
	url: "Please enter a valid URL.",
	date: "Please enter a valid date.",
	dateISO: "Please enter a valid date ( ISO ).",
	number: "Please enter a valid number.",
	digits: "Please enter only digits.",
	creditcard: "Please enter a valid credit card number.",
	equalTo: "Please enter the same value again.",
	maxlength: $.validator.format( "Please enter no more than {0} characters." ),
	minlength: $.validator.format( "Please enter at least {0} characters." ),
	rangelength: $.validator.format( "Please enter a value between {0} and {1} characters long." ),
	range: $.validator.format( "Please enter a value between {0} and {1}." ),
	max: $.validator.format( "Please enter a value less than or equal to {0}." ),
	min: $.validator.format( "Please enter a value greater than or equal to {0}." )
}
```
```
$.extend($.validator.messages, {
	required: "这是必填字段",
	remote: "请修正此字段",
	email: "请输入有效的电子邮件地址",
	url: "请输入有效的网址",
	date: "请输入有效的日期",
	dateISO: "请输入有效的日期 (YYYY-MM-DD)",
	number: "请输入有效的数字",
	digits: "只能输入数字",
	creditcard: "请输入有效的信用卡号码",
	equalTo: "你的输入不相同",
	extension: "请输入有效的后缀",
	maxlength: $.validator.format("最多可以输入 {0} 个字符"),
	minlength: $.validator.format("最少要输入 {0} 个字符"),
	rangelength: $.validator.format("请输入长度在 {0} 到 {1} 之间的字符串"),
	range: $.validator.format("请输入范围在 {0} 到 {1} 之间的数值"),
	max: $.validator.format("请输入不大于 {0} 的数值"),
	min: $.validator.format("请输入不小于 {0} 的数值")
});
```
> 3.例子
```
<html>
<head>
<meta charset="utf-8">
<title>validation</title>
<script src="js/jquery.js"></script>
<script src="js/jquery.validate.min.js"></script>
<script src="js/messages_zh.js"></script>
<script>
$.validator.setDefaults({
    submitHandler: function() {
      alert("提交事件!");
    }
});
$().ready(function() {
// 在键盘按下并释放及提交后验证提交表单
  $("#signupForm").validate({
	    rules: {
	      firstname: "required",
	      lastname: "required",
	      username: {
	        required: true,
	        minlength: 2
	      },
	      password: {
	        required: true,
	        minlength: 5
	      },
	      confirm_password: {
	        required: true,
	        minlength: 5,
	        equalTo: "#password"
	      },
	      email: {
	        required: true,
	        email: true
	      },
	      "topic[]": {
	        required: "#newsletter:checked",
	        minlength: 2
	      },
	      agree: "required"
	    },
	    messages: {
	      firstname: "请输入您的名字",
	      lastname: "请输入您的姓氏",
	      username: {
	        required: "请输入用户名",
	        minlength: "用户名必需由两个字母组成"
	      },
	      password: {
	        required: "请输入密码",
	        minlength: "密码长度不能小于 5 个字母"
	      },
	      confirm_password: {
	        required: "请输入密码",
	        minlength: "密码长度不能小于 5 个字母",
	        equalTo: "两次密码输入不一致"
	      },
	      email: "请输入一个正确的邮箱",
	      agree: "请接受我们的声明",
	      topic: "请选择两个主题"
	    }
	});
});
</script>
<style>
.error{
	color:red;
}
</style>
</head>
<body>
<form class="cmxform" id="signupForm" method="get" action="">
  <fieldset>
    <legend>验证完整的表单</legend>
    <p>
      <label for="firstname">名字</label>
      <input id="firstname" name="firstname" type="text">
    </p>
    <p>
      <label for="lastname">姓氏</label>
      <input id="lastname" name="lastname" type="text">
    </p>
    <p>
      <label for="username">用户名</label>
      <input id="username" name="username" type="text">
    </p>
    <p>
      <label for="password">密码</label>
      <input id="password" name="password" type="password">
    </p>
    <p>
      <label for="confirm_password">验证密码</label>
      <input id="confirm_password" name="confirm_password" type="password">
    </p>
    <p>
      <label for="email">Email</label>
      <input id="email" name="email" type="email">
    </p>
    <p>
      <label for="agree">请同意我们的声明</label>
      <input type="checkbox" class="checkbox" id="agree" name="agree">
    </p>
    <p>
      <label for="newsletter">我乐意接收新信息</label>
      <input type="checkbox" class="checkbox" id="newsletter" name="newsletter">
    </p>
    <fieldset id="newsletter_topics">
      <legend>主题 (至少选择两个) - 注意：如果没有勾选“我乐意接收新信息”以下选项会隐藏，但我们这里作为演示让它可见</legend>
      <label for="topic_marketflash">
        <input type="checkbox" id="topic_marketflash" value="marketflash" name="topic[]">Marketflash
      </label>
      <label for="topic_fuzz">
        <input type="checkbox" id="topic_fuzz" value="fuzz" name="topic[]">Latest fuzz
      </label>
      <label for="topic_digester">
        <input type="checkbox" id="topic_digester" value="digester" name="topic[]">Mailing list digester
      </label>
      <label for="topic" class="error" style="display:none">至少选择两个</label>
    </fieldset>
    <p>
      <input class="submit" type="submit" value="提交">
    </p>
  </fieldset>
</form>
</body>
</html>
```

1.什么是jquery？
> 1.兼容多浏览器的javascriot库；
> 2.核心理念：写的更少，做的更多；

2.jquery的优点
> 1.免费、开源、使用MIT许可协议；
> 2.开发便捷：例如操作文档对象，选择DOM对象，制作动画效果，事件处理，使用ajax等；
> 3.提供API让开发者编写插件：文档说明很全；

3、jquery特点
> 1.动态特效；
> 2.AJAX；
> 3.通过插件来扩展；
> 4.方便的工具——例如浏览器版本的判断；
> 5.渐进增强；
> 6.链式调用；
> 7.多浏览器支持；


## jquery实例

https://www.cnblogs.com/huchaoheng/p/5711864.html
1、锚方法
> 1.一种简单的返回顶部的功能实现;
> 2.该实现主要在页面顶部放置一个指定名称的锚点链接，
> 3.然后我们在页面下方放置一个返回到该锚点的链接，
> 4.用户点击该链接即可返回到该锚点所在的顶部位置
```
<!-- 定义一个名称为top的锚点链接 -->
<a name="top"></a>

<!-- 返回页面顶部top锚点的链接 -->
<a href="#top">返回顶部</a>
```
**注意：在现代浏览器中，如果浏览器找不到指定的锚点(例如top)，浏览器将会尝试跳转到id为top的HTML元素的起始位置。因此，我们也可以在头部放置一个id为top的HTML元素，遗憾的是，并不是所有的浏览器——尤其是某些浏览器的旧版本，都兼容这种行为。**

2、js操作DOM样式
> 1.使用js将body或html等元素的scrollTop属性设置为0，即可滚动到页面的顶部。
```
// 以下三种方式均可实现返回页面顶部

$(window).scrollTop(0);
$('body').scrollTop(0);
$('html').scrollTop(0);
```
> 2.使用jQuery的动画效果函数animate()来实现平滑滚动到页面顶部的动画效果
```
// 在500毫秒内平滑滚动到页面顶部
$('body').animate( {scrollTop: 0}, 500);
```
```html
//完整例子
<div class="gotop">
    <a href="#top">回到顶部</a>
</div>
```
```css
.gotop {
    height: 50px;
    width: 50px;
    position: fixed;
    bottom: 20px;
    right: 40px;
}
```
```js
$('a[href="#top"]').on('click',function(){
  $('html, body').animate({scrollTop: 0}, 1000, "easeInOutQuint");
  return false;
});
```

3、js函数scrollTo()
> 1.利用JavaScript为我们提供的函数scrollTo(x, y)来实现返回到页面顶部的功能;
> 2.scrollTo函数可以滚动到指定坐标(x, y)处的内容。我们将坐标设定为(0, 0)即可起到返回顶部的作用;
```
<a href="javascript:scrollTo(0,0);">返回顶部</a>
```


## w3cschool

1、jQuery库的特性
> 1.HTML元素选取
> 2.HTML元素操作
> 3.CSS操作
> 4.HTML事件函数
> 5.JavaScript特效和动画
> 6.HTML DOM遍历和修改
> 7.AJAX
> 8.Utilities

2、jQuery语法
> 1.基本语法：`$(selector).action()`
> 1. 美元符号：定义jQuery；
> 2. selector：选择符，“查找和查询”HTML元素；
> 3. action：执行对元素的操作；
```
$(this).hide();                  //隐藏当前的HTML元素
$("p").hide();                   //隐藏所有的<p>元素
$(".class").hide();              //隐藏所有class="class"的元素
$("#id").hide();                 //隐藏所有id="id"的元素
```

3、jQuery选择器有哪些
> 1.元素选择器：使用CSS选择器来选取HTML元素；
```
$("p").hide();              //选取所有的<p>元素
$("p.class").hide();        //选取所有class="class"的<p>元素
$("p#id").hide();           //选取所有id="id"的<p>元素
```
> 2.属性选择器：使用XPath表达式来选择带有给定属性的元素；
```
$("[href]");               //选取所有带href属性的元素
$("[href='#']")            //选取所有带href值等于"#"的元素
$("[href!='#']")           //选取所有带href值不等于"#"的元素
$("[href$='.jpg']")        //选取所有href值以".jpg"结尾的元素
```
> 3.CSS选择器：用于改变HTML元素的CSS属性
```
$("p").css("background-color","red");       //将所有p元素的背景颜色改为红色
```

4、jQuery事件
> 1.事件处理程序指的是：当HTML中发生某些事件时所调用的方法，术语由事件"触发"(或"激发")经常被使用。

5、jQuery处理事件遵循的原则
> 1.把所有的jQuery代码置于事件处理函数中；
> 2.把所有事件处理函数置于文档就绪事件处理器中；
> 3.把jQuery代码置于单独的.js文件中；
> 4.如果存在命名冲突，则重命名jQuery库；

6、jQuery命名冲突
> 1.jQuery使用`$`符号作为jQuery的简介方式；
> 2.某些其他的JavaScript库中的函数(比如Prototype)同样使用`$`符号；
> 3.jQuery使用名为noConflict()方法来解决该问题；
> 4.`var jq = jQuery.noConflict()`，帮助使用自己的名称(使用jq来代替`$`符号)；

1、显示和隐藏方法：hide()和show()
> 1.语法：`$(selector).hide(speed,callback)`和`$(selector).show(speed,callback)`
> 2.可选的speed参数规定隐藏/显示的速度，可以取值："slow"、"fast"或毫秒；
> 3.可选的callback参数是隐藏或显示完成后所执行的函数名称；
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#hide").click(function(){
            $("p").hide(1000);
        });
        $("#show").click(function(){
            $("p").show();
        });
    });
</script>

<p>如果点击"隐藏"，我就会消失</p>
<button id="hide">隐藏</button>
<button id="show">显示</button>
```

2、切换显示和隐藏：toggle()
> 1.语法：`$(selector).toggle(speed,callback)`
> 2.可选的speed参数规定隐藏/显示的速度，可以取值："slow"、"fast"或毫秒；
> 3.可选的callback参数是toggle()方法完成后执行的函数名称；
```
$(document).ready(function(){
    $("#toggle").click(function(){
        $("p").toggle();
    });
});

<p>如果点击"隐藏"，我就会消失</p>
<button id="toggle">切换显示和隐藏</button>
```

3、淡入淡出方法：Fading方法
> 1.fadeIn():淡入已隐藏的元素；
> 2.fadeOut();淡出可见元素；
> 3.fadeToggle():在前两个方法之间切换；
> 4.fadeTo():允许渐变为给定的不透明度(值介于0-1之间)；

4、fadeIn()方法
> 1.作用：淡入已隐藏的元素；
> 2.语法：`$(selector).fadeIn(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是fading完成之后所执行的函数名称；
```
.div1{
    width: 80px;
    height: 80px;
    background-color:#2e6da4;
    display: none;
}
.div2{
    width: 80px;
    height: 80px;
    background-color:#398439;
    display: none;
}
.div3{
    width: 80px;
    height: 80px;
    background-color:#761c19;
    display: none;
}

<script type="text/javascript">
    $(document).ready(function(){
        $("#fadeIn").click(function(){
            $("#div1").fadeIn("fast");
            $("#div2").fadeIn("slow");
            $("#div3").fadeIn(3000);
        });
    });
</script>

<button id="fadeIn">淡入已隐藏的元素</button><br><br>
<div class="div1" id="div1"></div><br>
<div class="div2" id="div2"></div><br>
<div class="div3" id="div3"></div><br>
```

5、fadeOut()方法
> 1.作用：用于淡出可见元素；
> 2.语法：`$(selector).fadeOut(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是fading完成后所执行的函数名称；

6、fadeToggle()方法
> 1.作用：在fadeIn()和fadeOut()方法之间切换；
> 2.语法：`$(selector).fadeToggle(speed,callback)`

7、fadeTo()方法
> 1.作用：允许渐变为给定的不透明度(值介于0与1之间)；
> 2.语法：`$(selector).fadeTo(speed,opacity,callback)`
> 3.必须的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.必须的opacity参数将淡入淡出效果设置为给定的不透明度(值介于0与1之间)；
> 5.可选的callback参数是fading完成后所执行的函数名称；
```
$(document).ready(function(){
    $("#fadeTo").click(function(){
        $("#div111").fadeTo(3000,0.15);
        $("#div222").fadeTo("slow",0.4);
        $("#div333").fadeTo("fast",0.6);
    })
})
```

8、jQuery滑动方法
> 1.slideDown():向下滑动元素；
> 2.slideUp():向上滑动元素；
> 3.slideToggle():在向上和向下滑动之间切换；

9、slideDown()方法
> 1.作用：向下滑动元素；
> 2.语法：`$(selector).slideDown(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；

10、slideUp()方法
> 1.作用：向上滑动元素；
> 2.语法：`$(selector).slideUp(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；

11、slideToggle()方法
> 1.作用：切换上下滑动；
> 2.语法：`$(selector).slideToggle(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；
```
$(document).ready(function(){
    $("#toggle").click(function(){
        $("#change").slideToggle();
    });
});

<button id="toggle">滑动切换</button>
<p id="change">你可以找到你所需要的所有网站建设教程</p>
```

12、jQuery动画：animate()方法
> 1.作用：创建自定义动画；
> 2.语法：`$(selector).animate({params},speed,callback)`
> 3.必须的params参数定义形成动画的css属性；
> 4.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 5.可选的callback参数是动画完成后所执行的函数名称；
**注意：对位置进行操作，首先要把元素的CSS position属性设置为relative、fixed或absolute**
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#start").click(function(){
            $("#startAnimate").animate({left:'250px'});
        });
    });
</script>
<style>
    .start{
        height: 50px;
        width:50px;
        background-color:#f00;
        position:relative;       //设置属性
    }
</style>

<button id="start">开始动画</button>
<div class="start" id="startAnimate"></div>
```

13、animate操作多个属性
> 1.animate()方法几乎可以操作所有的css属性，
> 2.但是，在使用时，必须使用Camel标记法书写所有的属性名，例如，paddingLeft而不是padding-left；
> 3.色彩动画不包含在核心jQuery库中，需要下载 Color Animations插件；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
        left:'250px',
        opacity:'0.5',
        height:'150px'
        });
    });
});
```

14、animate()使用相对值
> 1.在值的前面加上`+=`或`-=`；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
        left:'250px',
        height:'+=150px',
        width:'-=50px'
        });
    });
});
```

15、animate()使用预定义值
> 1.show:显示；
> 2.hide:隐藏
> 3.toggle:切换显示和隐藏；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
          height:'toggle'
          });
    });
});
```

16、animate()队列功能
> 1.编写多个animate()调用，然后会逐一调用这些方法；
```
$(document).ready(function(){
    $("#start").click(function(){
         var temp = $("#startAnimate");
         temp.animate({height:'300px',opacity:'0.4'},"slow");
         temp.animate({width:'300px',opacity:'0.8'},"slow");
         temp.animate({height:'100px',opacity:'0.4'},"slow");
         temp.animate({width:'100px',opacity:'0.8'},"slow");
    });
});
```

17、stop()方法
> 1.作用：用于停止动画或效果(在他们完成之前)；
> 2.适用的效果：包括滑动，淡入淡出和自定义动画；
> 3.语法：`$(selector).stop(stopAll,goToEnd)`
> 4.可选的stopAll参数规定是否应该清楚动画队列。默认是false，仅停止活动的动画，允许任何排入队列的动画向后执行；
> 5.可选的goToEnd参数规定是否立即完成当前动画。默认是false。
**注意：默认的无参数方法：stop()会清除在被选元素上指定的当前动画**

18、stop()滑动效果，无参数
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#down").click(function(){
            $("p").slideDown(5000);
        });
        $("#stop").click(function(){
            $("p").stop();
        });
    });
</script>
<style>
    p{
        display:none;
        background-color: #2e6da4;
    }
</style>

<button id="stop">停止滑动</button>
<button id="down">点击这里，向下滑动</button>
<p>Hello World!</p>
```

19、stop()动画效果，有参数
```
$(document).ready(function(){
    $("#top1").click(function(){
        $("#animate").animate({left:'100px'},5000);
        $("#animate").animate({fontSize:'3em'},5000);
    });
    $("#top2").click(function(){
       $("#animate").stop();
    });
    $("#top3").click(function(){
        $("#animate").stop(true);
    });
    $("#top4").click(function(){
        $("#animate").stop(true,true);
    });
});
.animate{
    height:100px;
    width:100px;
    background-color: #1b6d85;
    position: relative;
}

<button id="top1">开始</button>
<button id="top2">停止</button>
<button id="top3">停止所有</button>
<button id="top4">停止但要完成</button>
<div class="animate" id="animate">Hello</div>
```

20、callback函数

# Vue

## 起步

1、在html中配置
> 1.通过`<router-view></router-view>`来渲染路由匹配的组件；
```html
<template>
  <div id="app">
    <img src="./assets/logo.png">
    <router-view></router-view>
  </div>
</template>
```


2、JavaScript中配置路由
> 1.使用模块化编程，首先，在main.js中，要导入Vue和VueRouter，然后调用方法`Vue.use(VueRouter)`
```
//导入两个模块
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router);
```
> 2.在routes.js中导入需要的Vue组件
```
import Login from './views/Login.vue'
```
> 3.在main.js文件中创建router实例，然后，在routes.js文件中配置routes，并且导出routes配置
```routes.js
let routes = [
  {
    path: '/',
    name: 'HelloWorld',
    component: HelloWorld
  },
  {
    path: '/Login',
    name: '',
    component: Login
  }
];

export default routes;
```
```
import Router from 'vue-router'
import routes from './routes'      //导入在routes.js中配置的路由

Vue.use(Router);

//创建router实例
const router = new Router({
  routes
});
```
> 4.在main.js中，创建和挂载根实例。
> 1. 这里要通过router配置参数注入路由，从而让整个应用都有路由功能。
```
new Vue({
  router,
  //这个是vue2.0版本以上，渲染视图的函数，如果没有这个函数，页面的内容就无法加载出来
  render: h >= h(app)
}).$mount("#app");
```

3、注入路由器之后，我们可以在任何的组件中访问路由器
> 1.`$route`：表示当前路由信息对象；包含了当前URL解析得到的信息，还有URL匹配到的路由记录；
> 1. `$route.path`：字符串，对应当前路由的路径，解析为绝对路径。如`/login`
> 2. `$route.params`：key/value对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象；
> 2. `$route.query`：key/value对象，表示URL查询参数。例如，对于路径 /login?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。
> 2. `$route.hash`：字符串，当前路由的hash值(不带#)，如果没有hash值，则为空。
> 2. `$route.fullPath`：完成解析后的URL，包含查询参数和hash的完整路径。
> 2. `$route.matched`：数组，包含当前匹配的路径中所包含的所有片段对应的配置参数对象；
> 2. `$route.name`：当前路径名字
> 2. `$route.meta`：路由元信息
```
<div>
<h1>{{msg}}</h1>
<p>$route.path：{{$route.path}}</p>
<p>$route.params：{{$route.params}}</p>
<p>$route.query：{{$route.query}}</p>
<p>$route.hash：{{$route.hash}}</p>
<p>$route.fullPath：{{$route.fullPath}}</p>
</div>
```
> 2.`$router`：表示全局的路由实例，是router构造方法的实例
> 1. 常用的`$router.options.routes`：数组，获取所有的全局路由配置；

4、路由实例的方法-go()
> 1.作用：页面路由跳转；
> 2.参数：-1表示后退
```
this.$router.go(-1) // 后退
```

5、路由实例的方法-replace()
> 1.作用：替换当前的页面，不会向history栈添加新纪录，一旦替换了新页面，就不能返回老页面了；
```
this.$router.replace('home');
```

6、路由实例的方法-push()
> 1.作用：跳转页面，会向history栈添加新纪录，当我们点击浏览器的返回按钮时可以看到之前的页面；
```
// 字符串
      this.$router.push('home')
// 对象
      this.$router.push({ path: 'home' })
// 命名的路由
      this.$router.push({ name: 'user', params: { userId: 123 }})
// 带查询参数，变成 /register?plan=123
      this.$router.push({ path: 'register', query: { plan: '123' }})
```
```html
<button @click="replace1">replace</button>
<button @click="push1">push</button>
```
```js
export default {
  name: "Login",
  methods:{
    replace1(){
      this.$router.replace('home');   //路由从http://localhost:8080/#/替换为http://localhost:8080/#/home
    },
    push1(){
      this.$router.push('home');
    }
  }
}
```

## 动态路由匹配

1、动态路由
> 1.功能：需要把某种模式匹配到的所有路由，都映射到同一个组件中；
> 2.方法：在`vue-router`的路由路径中，使用"动态路径参数"，以**冒号**开头；
> 3.当匹配到一个路由时，冒号后的参数值会被设置到`$route.params`中，可以在每个组件中使用，
> 4.其他的一些值也会被设置到`$route`的各个参数中；
```
let routes = [
  {
    path: '/',
    name: 'Login',
    component: Login
  },
  {
    path: '/:id',            //这里，不管是http://localhost:8080/#/hello，还是http://localhost:8080/#/home，都会映射到HelloWorld组件的视图上
    name: 'HelloWorld',
    component: HelloWorld
  }
];
```
```
<p>$route.params.id：{{$route.params.id}}</p>    //在组件内会显示对应的参数，在/home路径下，会显示为"home"
```

|模式|匹配路径|$route.params|
|---|---|---|
|/login/:username|/login/evan|{username:"evan"}|
|/login/:username/post/:post_id|/login/evan/post/123|{username:"evan",post_id:"123"}|

2、响应路由参数的变化
> 1.动态路由模式，例如，从"/user/foo"导航到"/user/bar"，使得**原来的组件会被复用**；
> 2.这样，比起销毁再创建，复用显得更加高效；
> 3.**不过，这也意味着组件的生命周期钩子不会再被调用。**
> 4.复用组件时，想对路由参数的变化做出响应的话，可以对复用的组件进行简单的检测变化(watch)`$route`对象;
```
watch:{
  '$route'(to,from){
    console.log('to',to);
    console.log('from',from);
  }
}
```
> 5.也可以使用导航守卫`beforeRouteUpdate`
```
beforeRouteUpdate(to,from,next){
  console.log('beforeRouteUpdate-to',to);
  console.log('beforeRouteUpdate-from',from);
  console.log('beforeRouteUpdate-next',next);
}
```

3、捕获所有路由或404 Not Found路由
> 1.常规参数只会匹配被`/`分隔的URL片段中的字符；
> 2.想匹配仁义路径，可以使用通配符`*`；
```
{
  path: '*',           //会匹配所有路径
  name: '',
},
{
  path: 'user-*',      //会匹配"user-"开头的任意路径
  name: '',
}
```
> 3.使用通配符路由时，确保路由顺序是正确的，也就是说，含有通配符的路由应该放在最后；
> 4.路由`{path:'*',...}`通常用于客户端404错误。
> 5.当使用一个通配符时，`$route.params`内会自动添加一个名为`pathMatch`参数。它包含了URL通过通配符匹配的部分；
```
// 给出一个路由 { path: '/user-*' }
this.$router.push('/user-admin')
this.$route.params.pathMatch // 'admin'
// 给出一个路由 { path: '*' }
this.$router.push('/non-existing')
this.$route.params.pathMatch // '/non-existing'
```

4、匹配路由优先级
> 1.当同一个路径可以匹配多个路由时，匹配的优先级按照路由定义的顺序：谁先定义的，谁的优先级就高；

## 嵌套路由

1、嵌套路由
> 1.在实际中，一个应用界面，通常是由多层嵌套的组件组合而成的；
> 2.同样，URL中的各段动态路径也按某种结构对应嵌套的各个组件；
> 3.实际步骤：
> 1. 在应用界面中使用`<router-view/>`，表示在此处渲染组件模板；
```html
//Login.vue文件
<template>
  <div>
    <h1>{{msg}}</h1>
    <button @click="push2">Home</button>
    //这个地方会渲染其他的组件模板
    <router-view/>
  </div>
</template>
```
```js
export default {
  name: "Login",
  data() {
    return {
      msg: '你好'
    }
  },
  methods: {
    push2() {
      this.$router.push('home');
    }
  }
}
```
> 2. 在路径中使用`children`配置路径；
```js
{
  path: '/',
  name: 'Login',
  component: Login,
  children:[
    {
      //'/home'路径下渲染Home组件
      path:'home',
      component:Home,
    }
  ]
}
```
> **注意：以`/`开头的嵌套路径会被当做根路径，这让你充分的使用嵌套组件而无需设置嵌套的路径**


2、嵌套路由的主路由与子路由
> 1.例如，上面的主路由是`/`，子路由为`/home`，在访问主路由时，子组件不会渲染，只有访问子路由时，子组件才会渲染出来；
> 2.设置主路由下的默认页面的方法，是在`children`中设置一个空的路径，渲染一个默认的页面；
```js
let routes = [
  {
    path: '/',
    name: 'Login',
    component: Login,
    children:[
      {
        //'/home'路径，渲染Home子组件
        path:'home',
        component:Home,
      },
      //'/'路径，默认主路由渲染的页面
      {
        path:'',
        component:HelloWorld
      }
    ]
  }
```


## 编程式的导航

1、编程式导航
> 1.除了通过`<router-link>`，创建a标签来定义导航链接，还可以使用`router`的实例方法，编码实现。

2、`router-link`导航
> 1.支持用户在具有路由功能的应用中点击导航；
> 2.通过to属性指定目标地址，默认渲染为带有正确连接的`<a>`标签，可以通过tag属性生成别的标签。
> 3.另外，当路由成功激活时，链接元素自动设置一个表示激活的css类名。
> 4.to属性：
> 1. to属性，字符串形式
```
<router-link to="home">homeLink</router-link>
```
> 2. to属性，动态绑定
```
//v-bind绑定
<router-link :to="home">homeLinkBind</router-link>
```
```
export default {
  name: "Login",
  data() {
    return {
      home:'home'
    }
}
```
> 3. to属性，动态绑定
```
<router-link :to="{path:'home'}">homeLinkPath</router-link>
```
> 4. to属性，动态绑定，在路由中配置name
```
<router-link :to="{name:'home'}">homeLinkName</router-link>
```
```
{
  path:'home',
  name:'home',       //配置name值
  component:Home,
},
```
> 5.tag属性
> 1. 将`<router-link>`渲染成`<li>`标签
```
<router-link :to="{name:'home'}" tag="li">homeLinkName</router-link>
```
> 2. 在渲染的`<li>`标签中添加`<a>`标签，可以不为a标签添加href属性；此时，a标签将作为真实的链接(会获得正确的href属性)，而激活的css类名(router-link-active)，设置到li标签上；
```
<router-link to="home" tag="li">
  <a>homeLinkLiName</a>
</router-link>
```

3、push()方法
> 1.会向history栈添加一个新的记录；
> 2.所以，当用户点击浏览器后退按钮时，会回到之前的URL。
```
//语法
router.push(location, onComplete?, onAbort?);
```

|声明式|编程式|
|---|---|
|`router-link :to="..."`|`router.push(...)`|
> 3.push方法的参数可以是一个祖父穿路径，或者描述地址的对象；
```
router.push('home');                                         //字符串
router.push({path:'home'})                                   //对象
router.push({name:'user',params:{userId:'123'}});            //命名的路由
router.push({path:'register',query:{plan:'private'}});       //带查询参数"/register?plan=private"
```
> 4.**注意：如果提供了`path`，则`params`会被忽略；此时，可以提供路由的name或者手写完整的带参数的path**
```
const userId = 123;
router.push({name:'user',params:{userId}})              //--'/user/123'
router.push({path:'/user/${userId}'});                  //--'/user/123'
router.push({path:'/user',params:{userId}});             //--'/user'，这里的params不生效
```
> 5.在2.2.0+，可选的`router.push`和`router.replace`中提供`onComplete`和`onAbort`回调作为第二个和第三个参数。
> 1. 这些回调会在导航成功完成(在所有异步钩子被解析之后)或终止(导航到相同的路由，或在当前导航完成之后导航到另一个不同的路由)的时候进行相应的调用；
> 2. **注意：如果目的地和当前路由相同，只有参数发生了变化(比如一个用户跳到另一个，从`/user/1`到`/user/2`，需要`beforeRouteUpdate来响应这个变化`**


4、replace()方法
> 1.用法与push()方法相同；
> 2.唯一不同，就是不会向history添加新的记录，而是直接替换掉当前的history记录；

5、go()方法
> 1.参数：是一个整数，
> 2.参数的意义：在history记录中向前或向后多少步，类似`window.history.go(n)`;
```
router.go(1);             //在浏览器记录中前进一步，类似于'history.forward()'方法
router.go(-1);            //在浏览器记录中后退一步，类似于'history.back()'方法
router.go(3);             //在浏览器记录中前进三步
```

## 命名路由

1、命名路由
> 1.定义：通过一个名称标识一个路由；
> 2.在`routes.js`中配置路由时们可以给路由设置名称`name`;
```
{
  path: '/user/:userId',
  name: 'user',               //命名的标识
  component: User
}
```
> 3.在`router-link`中的to属性直接传一个对象
```
<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
```
> 4.在`router.push()`中使用
```
router.push({ name: 'user', params: { userId: 123 }})
```


## 命名视图

1、同级命名视图
> 1.同级展示多个视图，例如创建一个布局，有sidebar(侧导航)和main(主内容)；
> 2.在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。
> 3.如果`router-view`没有设置名字，那么默认为`default`。
> 4.多个视图，正确使用`components`配置，加上`s`；
```html
//在App.vue中
<template>
  <div id="app">
    <img src="./assets/logo.png">
    <router-view/>
    <router-view name="a"/>
    <router-view name="b"/>
  </div>
</template>
```
```js
{
  path: '/',
  name: '',
  components: {
    default: Login,     //匹配的组件
    a: HelloWorld,
    b: Home
  },
}
```

2、嵌套命名视图
> 1.创建嵌套视图的复杂布局，使用`router-view`；
```html
//在Login.vue中配置嵌套路由
<template>
  <div>
    <h1>{{msg}}</h1>

    <button @click="push1">helloWorld</button>

    <router-link to="home" tag="li">
      <a>homeLinkLiName</a>
    </router-link>

    <router-view class="default"/>
    <router-view name="helper" class="helper"/>
  </div>
</template>
```
```js
{
  path: '/',
  name: 'Login',
  component: Login,
  children: [
    {
      //'/home'路径下渲染Home组件
      path: 'home',
      name: 'home',
      component: Home,
    },
    {
      path:'hello',
      name:'',
      components:{
        default: Home,
        helper: HelloWorld
      }
    }
  ]
}
```
```
export default {
  name: "Login",
  data() {
    return {
      msg: '你好',
    }
  },
  methods: {
    push1() {
      this.$router.push('hello');
    }
  }
}
```

## 重定向和别名
1、重定向
> 1.把一个路径重定向为另一个路径，例如：`/a`重定向为`/b`;
```
{
  path: '/a',
  redirect: '/b'
}
```
> 2.重定向的目标也可以是一个命名的路由
```
{
  path:'/a',
  redirect: {name:'b'}
}
```
> 3.重定向的目标还可以是一个方法(不会)
```
{
  path:'/home',
  redirect: to=>{
    //方法接受 目标路由 作为参数
    //return 重定向的 字符串路径/路径对象
  }
}
```

2、别名——alias
> 1.作用：自由的将UI结构映射到任意的URL，而不受限于配置的嵌套路由结构；
> 2.举例：`/a`的别名是`/b`，意味着，用户访问`/b`时，URL会保持为`/b`，但是，路由匹配则为`/a`，就像用户访问`/a`一样；
```
//"/home"的别名是"/h"，则我们可以直接访问"/h"
{
  path: '/home',
  component: Home,
  alias:'/h'
}
```
```
<router-link to="h"></router-link>         //直接把to属性的值，设置为别名，同样可以访问'/home'路径下的组件，但是，URL还是'/h'
```
> 3.在嵌套路由中使用
```html
<button @click="push4">aliasHello</button>
```
```js
export default {
  name: "Login",
  methods: {
    push4(){
      this.$router.push('/b');     //这里可以直接访问URL为'/login/hello'中的内容
    }
  }
}
```
```js
{
  path: '/login',
  name: '',
  component: Login,
  children: [
    {
      //'/home'路径下渲染Home组件
      path: 'home',
      name: 'home',
      component: Home,
    },
    {
      path: 'hello',
      name: '',
      components: {
        default: Home,
        helper: HelloWorld
      },
      //原来的访问URL是'/login/hello'，现在的访问路径可以使用别名'/b'直接访问
      alias:'/b',
    }
  ]
}
```


## 路由组件传参

1、路由组件传参-布尔模式
> 1.在组件中使用`$route`会使之与其对应路由形成高度耦合，从而使得组件只能在某些特定的URL上使用，限制了其灵活性。
> 2.使用`props`，将组件和路由解耦。
```
{
  path: '/:id',
  component: Home,
  props: true,      //设置为 true，route.params 将会被设置为组件属性
}
```
```
export default {
  name: "Home",
  props:['id'],
}
```
```
<p>home:id:{{id}}</p>
```
> 2.对于包含命名视图的路由，必须分别为每个命名视图添加`props`属性；
```
{
  path: '/user/:id',
  components: { default: User, sidebar: Sidebar },
  props: { default: true, sidebar: false }
}
```

2、路由组件传参-对象模式
> 1.如果`props`是一个对象，它会被按原样设置为组件属性。当`props`是静态的时候有用。
```
{ path: '/promotion/from-newsletter', component: Promotion, props: { newsletterPopup: false } }
```

3、路由组件传参-函数模式
> 1. 创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等
```
//URL '/search?q=vue' 会将 {query: 'vue'} 作为属性传递给 SearchUser 组件
{ path: '/search', component: SearchUser, props: (route) => ({ query: route.query.q }) }
```


## History模式

1、hash模式
> 1.`vue-router`默认模式是hash模式；
> 2.hash模式，使用URL的hash来模拟一个完整的URL，当URL改变时，页面不会重新加载；
```
hash模式下的URL——"http://localhost:8080/#/"
```

2、History模式
> 1.URL比较正常，也好看
```
history模式下的URL——"http://localhost:8080/"
```
> 2.方法：
```
//创建router实例
const router = new Router({
  mode: 'history',               //定义history模式
  routes
});
```


## 导航守卫

1、导航守卫
> 1.作用：用来通过跳转或取消的方式守卫导航；

2、全局前置守卫
> 1.使用`router.beforeEach(to,from,next)`注册一个全局前置守卫；
> 2.当一个导航被触发时，全局前置守卫按照创建的顺序调用。守卫是异步执行的是，此时，导航在所有守卫resolve完之前一直处于**等待中**。
> 3.每个守卫方法接受三个参数：
> 1. `to:route`：即将要进入的目标
> 2. `from:route`：当前导航正要离开的路由
> 3. `next:function`：一定要调用该方法来resolve这个钩子。执行效果依赖`next`方法的调用参数
```
next()：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed(确认的)；
next(false)：中断当前的导航。如果浏览器的URL改变了(可能是用户手动或浏览器后退按钮)，那么URL地址会重置到from路由对应的地址；
next('/')或next({path:'/'})：跳转带一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向next传递任意位置对象，且允许设置诸如replace:true,name:'home'之类的选项以及任何用在router-link的to属性和router.push中的选项；
next(error)：如果传入的参数是一个Error实例，则导航会被终止且该错误会被传递给router.onError()注册过得回调；
```
> **注意：一定要调用next方法，否则钩子就不会被resolved**

2、全局解析守卫
> 1.`2.5.0版本`新增；
> 2.使用`router.beforeResolve`注册一个全局解析守卫，
> 3.与`router.beforeEach`类似，区别是，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。

3、全局后置钩子
> 1.全局后置钩子，与守卫不同的是，这些钩子不会接受`next`函数，也不会改变导航本身。
> 2.使用`router.afterEach(to,from)`注册全局后置钩子；

4、路由独享守卫
> 1.在路由配置上直接定义`beforeEnter`守卫；
> 2.参数与全局前置守卫的方法参数一致；
```
let routes = [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
```

5、组件内守卫
> 1.在组件内直接定义路由导航守卫；
```
beforeRouteEnter
beforeRouteUpdate(2.2新增)
beforeRouteLeave
```
> 2.beforeRouteEnter (to, from, next)
> 1. 在渲染该组件的对应路由被 confirm 前调用;
> 2. 不！能！获取组件实例 `this`，因为当守卫执行前，组件实例还没被创建;
> 3. 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
```
beforeRouteEnter (to, from, next) {
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
}
```
> **beforeRouteEnter是支持给 next 传递回调的唯一守卫，其他两个的`this`可用了，不支持传递回调，因为没有必要了。**
> 3.beforeRouteUpdate (to, from, next)
> 1. 在当前路由改变，但是该组件被复用时调用;
> 2. 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候;
> 3. 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
> 4. 可以访问组件实例 `this`
```HelloWorld.vue
export default {
  name: 'HelloWorld',
  watch:{
    '$route'(to,from){
      console.log('watch-to',to);
      console.log('watch-from',from);
    }
  },
  beforeRouteUpdate(to,from,next){
     // just use `this`
    this.name = to.params.name;
    next();

    console.log('beforeRouteUpdate-to',to);
    console.log('beforeRouteUpdate-from',from);
    console.log('beforeRouteUpdate-next',next);
  }
}
```
> 4.beforeRouteLeave (to, from , next)
> 1. 导航离开该组件的对应路由时调用;
> 2. 可以访问组件实例 `this`
> 3. 通常用来禁止用户在还未保存修改前突然离开，该导航可以通过 next(false) 来取消
```
beforeRouteLeave (to, from , next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
```

6、完整导航解析流程
> 1.导航被触发；
> 2.在失活的组件里调用离开守卫；
> 3.调用全局的`beforeEach`守卫；
> 4.在重用的组件里调用`beforeRouteUpdate`守卫；
> 5.在路由配置里调用`beforeEnter`守卫；
> 6.解析异步路由组件；
> 7.在被激活的组件里调用`beforeRouteEnter`守卫；
> 8.调用全局的`beforeResolve`守卫；
> 9.导航被确认；
> 10.调用全局后置钩子`afterEach`；
> 11.触发DOM更新；
> 12.用创建好的实例，调用`beforeRouteEnter`守卫传给next的回调函数。


## 路由元信息

1、路由元信息
> 1.定义路由的时候，配置`meta`字段；
```
{
    path: '/foo',
    component: Foo,
    children: [
      {
        path: 'bar',
        component: Bar,
        // a meta field
        meta: { requiresAuth: true }
      }
    ]
}
```
> 2.路由记录：在rotues中配置的每一个路由对象。路由记录是可以嵌套的，当一个路由匹配成功后，它可能会匹配多个路由记录；
> 3.例如，上面的配置，`/foo/bar`，这个URL将会匹配到父路由记录和子路由记录；
> 4.一个路由匹配到的所有路由记录会暴露为` $route` 对象 (还有在导航守卫中的路由对象) 的 `$route.matched` 数组；
> 5.因此，我们需要遍历 `$route.matched` 来检查路由记录中的 `meta` 字段。
```
//在全局导航守卫中检查元字段
router.beforeEach((to, from, next) => {
  if (to.matched.some(record => record.meta.requiresAuth)) {
    // this route requires auth, check if logged in
    // if not, redirect to login page.
    if (!auth.loggedIn()) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
  } else {
    next() // 确保一定要调用 next()
  }
})
```


## 过渡动效

1、过渡动效
> 1.用 `<transition>` 组件给它添加一些过渡效果;
```
<transition>
  <router-view/>
</transition>
```

2、单个路由的过渡
> 1.在各路由组件内使用 <transition> 并设置不同的 name;
```
<transition name="slide">
  <div class="foo">...</div>
</transition>

<transition name="fade">
  <div class="bar">...</div>
</transition>
```


3、基于路由的动态过渡
> 1.基于当前路由与目标路由的变化关系，动态设置过渡效果;
```html
<!-- 使用动态的 transition name -->
<transition :name="transitionName">
  <router-view></router-view>
</transition>
```
```js
// 接着在父组件内
// watch $route 决定使用哪种过渡
watch: {
  '$route' (to, from) {
    const toDepth = to.path.split('/').length
    const fromDepth = from.path.split('/').length
    this.transitionName = toDepth < fromDepth ? 'slide-right' : 'slide-left'
  }
}
```


## 数据获取

1、数据获取的方法
> 1.导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示；
> 2.导航完成之前获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航；

2、导航完成后获取数据
> 1.当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据;
> 2.让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态；
```html
//假设我们有一个 Post 组件，需要基于 $route.params.id 获取文章数据：
<template>
  <div class="post">
    <div class="loading" v-if="loading">
      Loading...
    </div>

    <div v-if="error" class="error">
      {{ error }}
    </div>

    <div v-if="post" class="content">
      <h2>{{ post.title }}</h2>
      <p>{{ post.body }}</p>
    </div>
  </div>
</template>
```
```js
export default {
  data () {
    return {
      loading: false,
      post: null,
      error: null
    }
  },
  created () {
    // 组件创建完后获取数据，
    // 此时 data 已经被 observed 了
    this.fetchData()
  },
  watch: {
    // 如果路由有变化，会再次执行该方法
    '$route': 'fetchData'
  },
  methods: {
    fetchData () {
      this.error = this.post = null
      this.loading = true
      // replace getPost with your data fetching util / API wrapper
      getPost(this.$route.params.id, (err, post) => {
        this.loading = false
        if (err) {
          this.error = err.toString()
        } else {
          this.post = post
        }
      })
    }
  }
}
```

3、在导航完成前获取数据
> 1.在导航转入新的路由前获取数据;
> 2.在接下来的组件的 beforeRouteEnter 守卫中获取数据，当数据获取成功后只调用 next 方法;
```js
export default {
  data () {
    return {
      post: null,
      error: null
    }
  },
  beforeRouteEnter (to, from, next) {
    getPost(to.params.id, (err, post) => {
      next(vm => vm.setData(err, post))
    })
  },
  // 路由改变前，组件就已经渲染完了
  // 逻辑稍稍不同
  beforeRouteUpdate (to, from, next) {
    this.post = null
    getPost(to.params.id, (err, post) => {
      this.setData(err, post)
      next()
    })
  },
  methods: {
    setData (err, post) {
      if (err) {
        this.error = err.toString()
      } else {
        this.post = post
      }
    }
  }
}
```


## 滚动行为

1、滚动行为
> 1.当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样;
> 2.vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动;
**注意: 这个功能只在支持 history.pushState 的浏览器中可用。**
```
const router = new Router({
  routes,
  scrollBehavior (to, from, savedPosition) {
    // return 期望滚动到哪个的位置
  }
})
```
> 3.scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用;
> 4.这个方法返回滚动位置的对象信息：
```
{ x: number, y: number }
{ selector: string, offset? : { x: number, y: number }} (offset 只在 2.6.0+ 支持)
```
> 5.如果返回一个 falsy (注：falsy 不是 false)，或者是一个空对象，那么不会发生滚动。
```
//不会发生滚动，页面在顶部
scrollBehavior (to, from, savedPosition) {
  return { x: 0, y: 0 }
}
```
> 6.模拟“滚动到锚点”的行为：
```
scrollBehavior (to, from, savedPosition) {
  if (to.hash) {
    return {
      selector: to.hash
    }
  }
}
```

2、异步滚动(2.8.0+)
> 1.可以返回一个 Promise 来得出预期的位置描述；
```
scrollBehavior (to, from, savedPosition) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({ x: 0, y: 0 })
    }, 500)
  })
}
```

## 路由懒加载

1、路由懒加载
> 1.当打包构建应用时，JavaScript 包会变得非常大，影响页面加载；
> 2.如果把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了；
> 3.首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：
```
const Foo = () => Promise.resolve({ /* 组件定义对象 */ })
```
> 4.然后，使用动态 import语法来定义代码分块点 (split point)：
```
import('./Foo.vue') // 返回 Promise
```
> 5.结合这两点：定义一个能够被 Webpack 自动代码分割的异步组件
```
const Foo = () => import('./Foo.vue')
```
```
routes: [
  {
    path: '/',
    component: resolve => require(['components/Hello.vue'], resolve)
  },
  {
      path: '/about',
      component: resolve => require(['components/About.vue'], resolve)
  }
]
---------------------
链接：https://www.cnblogs.com/lijuntao/p/7777581.html
```

2、把组件按组分块
> 1.把某个路由下的所有组件都打包在同个异步块 (chunk) 中；
> 2.只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)；
> 3.Webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中
```
const Foo = () => import(/* webpackChunkName: "group-foo" */ './Foo.vue')
const Bar = () => import(/* webpackChunkName: "group-foo" */ './Bar.vue')
const Baz = () => import(/* webpackChunkName: "group-foo" */ './Baz.vue')
```
```
//实际应用，还需要在webpack output加个chunkFilename
//添加：chunkFilename: '[name].js'
//在build文件下面的webpack.prod.conf.js中
routes: [
    {
        path: '/',
        name: 'Navigator',
        component: () => import(/* webpackChunkName: "navigator" */ './../components/Navigator')
    },
    {
        path: '/tucao',
        name: 'Tucao',
        component: () => import(/* webpackChunkName: "tucao" */ './../components/Tucao')
    }
]
链接：https://segmentfault.com/a/1190000012705647
```


## Vue 基础

1、Vue项目的目录结构
> 1.build:项目构建(webpack)相关代码；
> 2.config:配置目录，包括端口号等；
> 3.node_modules：npm加载的项目依赖模块；
> 4.src：主要开发的目录
> 1. assets：放置一些图片。如logo等
> 2. components：目录里面放了一个组件文件，可以不用；
> 3. App.vue：项目入口文件
> 4. main.js：项目核心文件；
```
```
> 5.static：静态资源文件，如字体，图标等
> 6.test：初始测试目录，可删除；
> 7..xxx文件：配置文件，包括语法配置，git配置等
> 8.index.html：首页入口文件，可以添加一些meta信息或统计代码的
> 9.package.json：项目配置文件
> 10.README.md：项目说明文档


1、Vue实例化
> 1.每个vue应用，都需要实例化Vue来实现
> 2.语法格式：
```
var vm = new Vue({
    //选项
})
```

2、Vue构造器中的参数
> 1.el参数：它是DOM元素中的id值；意味着只有id内部的元素会受影响；
```
<div id="vue-det"></div>
```
```
var vm = new Vue({
    el:'#vue-det'
})
```
> 2.data参数：用于定义属性；
> 3.methods参数：用于定义函数，可以通过return来返回函数值；
> 4.`{{ }}`：用于输出对象属性和函数返回值；
```html
<div id="vue-det">
	<h1>site:{{site}}</h1>
	<h1>url:{{url}}</h1>
	<h1>{{details}}</h1>
</div>
```
```js
var data = {site:"菜鸟教程",url:'www.baidu.com'};
	var vm = new Vue({
		el:'#vue-det',
		data:data
	})
```

3、Vue的数据属性
> 1.Vue实例和data属性石互相影响的；
```js
// 它们引用相同的对象！
document.write(vm.site === data.site) // true
document.write("<br>")
// 设置属性也会影响到原始数据
vm.site = "Runoob"
document.write(data.site + "<br>") // Runoob

// ……反之亦然
data.url = '1234'
document.write(vm.url) // '1234'
```

4、Vue的实例属性和方法
> 1.他们有前缀`$`，便于与用于定义的属性区分开来；
```js
document.write(vm.$data === data) // true
document.write("<br>")
document.write(vm.$el === document.getElementById('vue_det')) // true
```


1、vue模板语法
> 1.基于HTML的模板语法，允许开发者声明式的将DOM绑定至底层Vue实例的数据；
> 2.核心：允许采用简洁的模板语法来声明式的将数据渲染进DOM系统；
> 3.结合响应式系统，在引用状态改变时，能够只能计算出重新渲染组件的最小代价并应用到DOM操作上。

2、文本值
> 1.常见形式：使用双大括号`{{...}}`；
```
<div id="app">
	<p>{{message}}</p>
</div>
```

3、HTML值
> 1.使用`v-html`指令：输出html代码；
```html
<div id="app">
	<p v-html="message"></p>
</div>
```
```js
var vm = new Vue({
  el:'#app',
  data:{
      message:'<h1>HTML插值</h1>'
  }
});
```

4、属性值
> 1.使用`v-bind`指令，绑定属性值；
```html
//如果use为true，则使用class1类的样式
<div id="app">
	<p v-bind:class="{'class1':use}"></p>
</div>
//如果use为true，则使用class1类的样式
```

5、表达式
> 1.Vue.js提供了完全的JavaScript表达式支持；
```html
<div id="app">
	<p v-bind:id="'list-'+id"></p>
	{{5+5}}}<br>
	{{ok?'YES':'NO'}}<br>
	{{message.split('').reverse().join('')}}
</div>
```
```js
var vm = new Vue({
  el:'#app',
  data:{
    id:1,
    ok:true,
    message:'RUNOOB',
  }
});
```

6、指令
> 1.定义：带有`v-`前缀的特殊属性；
> 2.作用：用于在表达式值改变时，某些行为应用到DOM上

7、参数
> 1.参数在指令后用冒号指明

8、修饰符
> 1.以半角句号`.`指明的特殊后缀，用于一个指令应该以特殊方式绑定；
```html
//.prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault()方法
<form v-on:submit.prevent="onSubmit"></form>
```

9、用户输入
> 1.在input框中使用`v-model`指令来实行双向数据绑定；
> 2.`v-model`用来在input，select，text，checkbox，radio等表单控件上创建双向数据。根据表单上的值，自动更新绑定的元素的值
```html
<div id="app">
    <p>{{ message }}</p>
    <input v-model="message">
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    message: 'Runoob!'
  }
})
```

10、过滤器
> 1.允许自动以过滤器，用于一些常见的文本格式化。
> 2.过滤器函数，接受表达式的第一个值作为第一个参数；
```html
<div id="app">
  {{ message | capitalize }}
</div>
```
```js
var vm = new Vue({
    el: '#app',
    data: {
        message: 'runoob',
    },
    filters: {
        capitalize: function (value) {
            if (!value) return '';
            value = value.toString();
            return value.charAt(0).toUpperCase() + value.slice(1);
        }
    }
});
```
> 3.格式（由管道符指示）：
> 1. 在两个大括号中：
```
{{message|capitalize}}
```
> 2. 在`v-bind`指令中
```
<div v-bind:id="rawId|formatId"></div>
```


1、条件判断`v-if`
> 1.指令：`v-if`；
> 2.作用：根据条件判断的真假，来决定是否插入元素；
```html
<div id="app">
    <p v-if="seen">现在你看到我了</p>
    <template v-if="ok">
      <h1>菜鸟教程</h1>
      <p>学的不仅是技术，更是梦想！</p>
      <p>哈哈哈，打字辛苦啊！！！</p>
    </template>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    seen: true,
    ok: true
  }
})
```

2、条件判断`v-else`
> 1.`v-if`指令的一个else模块；
```html
<div id="app">
    <div v-if="Math.random() > 0.5">
      Sorry
    </div>
    <div v-else>
      Not sorry
    </div>
</div>
```
```js
new Vue({
  el: '#app'
})
```

3、条件判断`v-else-if`
> 1.在2.1.0新增，用作`v-if`的`v-else`块，可以多次使用；
```html
<div id="app">
    <div v-if="type === 'A'">
      A
    </div>
    <div v-else-if="type === 'B'">
      B
    </div>
    <div v-else-if="type === 'C'">
      C
    </div>
    <div v-else>
      Not A/B/C
    </div>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    type: 'C'
  }
})
```

4、`v-show`指令
> 1.根据条件展示元素
```html
<div id="app">
    <h1 v-show="ok">Hello!</h1>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    ok: true
  }
})
```


1、循环指令`v-for`
> 1.`v-for`需要以site in sites形式的特殊语法；
> 2.site是数组元素迭代的别名；
> 3.sites是源数据数组。
> 4.`v-for`可以绑定数据来渲染一个列表；
```html
<div id="app">
  <ul>
    <template v-for="site in sites">
      <li>{{ site.name }}</li>
      <li>--------------</li>
    </template>
  </ul>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    sites: [
      { name: 'Runoob' },
      { name: 'Google' },
      { name: 'Taobao' }
    ]
  }
})
```


2、`v-for`迭代对象
> 1.通过对象的属性来迭代数据；
```html
<div id="app">
  <ul>
    <li v-for="value in object">
    {{ value }}
    </li>
  </ul>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    object: {
      name: '菜鸟教程',
      url: 'http://www.runoob.com',
      slogan: '学的不仅是技术，更是梦想！'
    }
  }
})
```
> 2.提供第二个参数为键名
```html
<div id="app">
  <ul>
    <li v-for="(value, key) in object">    //这个顺序要注意
    {{ key }} : {{ value }}
    </li>
  </ul>
</div>
```
> 3.提供第三个参数为索引
```html
<div id="app">
  <ul>
    <li v-for="(value, key, index) in object">
     {{ index }}. {{ key }} : {{ value }}
    </li>
  </ul>
</div>
```

3、`v-for`迭代整数
```html
<div id="app">
  <ul>
    <li v-for="n in 10">
     {{ n }}
    </li>
  </ul>
</div>
```
```js
new Vue({
  el: '#app'
})
```


1、vue计算属性`computed`
> 1.计算属性在处理一些复杂逻辑时很有用；
```html
<div id="app">
  <p>原始字符串: {{ message }}</p>
  <p>计算后反转字符串: {{ reversedMessage }}</p>
</div>`
```
```
var vm = new Vue({
  el: '#app',
  data: {
    message: 'Runoob!'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

2、`methods`与`computed`
> 1.我们可以使用methods来替代computed，效果是一样的
> 2.但是，computed是基于它的依赖缓存，只有相关缓存发生改变时才会重新获取值；
> 3.而，methods。在重新渲染时，函数总会执行调用。


3、`computed`的getter和setter
> 1.computed属性，默认只有getter，不过可以自己提供一个setter；
```html
<div id="app">
  <p>{{ site }}</p>
</div>
```
```js
var vm = new Vue({
  el: '#app',
  data: {
	name: 'Google',
	url: 'http://www.google.com'
  },
  computed: {
    site: {
      // getter
      get: function () {
        return this.name + ' ' + this.url
      },
      // setter
      set: function (newValue) {
        var names = newValue.split(' ')
        this.name = names[0]
        this.url = names[names.length - 1]
      }
    }
  }
})
// 调用 setter， vm.name 和 vm.url 也会被对应更新
vm.site = '菜鸟教程 http://www.runoob.com';
document.write('name: ' + vm.name);
document.write('<br>');
document.write('url: ' + vm.url);
```

1、vue监听属性——watch
> 1.通过watch来响应数据的变化；
```html
<div id = "app">
 <p style = "font-size:25px;">计数器: {{ counter }}</p>
 <button @click = "counter++" style = "font-size:25px;">点我</button>
</div>
```
```js
var vm = new Vue({
   el: '#app',
   data: {
      counter: 1
   }
});
vm.$watch('counter', function(nval, oval) {
   alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');
});
```


1、样式绑定
> 1.使用`v-bind`来设置样式属性；
> 2.Vue在使用`v-bind`处理class和style时，增强了它。
> 3.表达式的结果类型除了字符串之外，还可以是对象或数组；
```html
<div id="app">
  <div v-bind:class="{ active: isActive }"></div>
</div>
```
```css
.active {
	width: 100px;
	height: 100px;
	background: green;
}
```
```js
new Vue({
  el: '#app',
  data: {
    isActive: true
  }
})
```
> 4.传入更过属性用来动态切换多个class
```html
<div id="app">
  <div v-bind:class="{ 'active': isActive, 'text-danger': hasError }">
  </div>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    isActive: true,
	  hasError: true
  }
})
```

2、数组绑定
> 1.给`v-bind:class`传入一个数组；
```html
<div id="app">
	<div v-bind:class="[activeClass, errorClass]"></div>
</div>
```
```css
.active {
	width: 100px;
	height: 100px;
	background: green;
}
.text-danger {
	background: red;
}
```
```js
new Vue({
  el: '#app',
  data: {
    activeClass: 'active',
    errorClass: 'text-danger'
  }
})
```

3、内联样式绑定
> 1.使用`v-bind:style`，直接设置样式；
```html
<div id="app">
	<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }">菜鸟教程</div>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    activeColor: 'green',
	  fontSize: 30
  }
})
```


1、事件监听——直接绑定事件
> 1.使用`v-on`指令；
> 2.接受一个定义的方法来调用，直接绑定；
```html
<div id="app">
   <!-- `greet` 是在下面定义的方法名 -->
  <button v-on:click="greet">Greet</button>
</div>
```
```js
var app = new Vue({
  el: '#app',
  data: {
    name: 'Vue.js'
  },
  // 在 `methods` 对象中定义方法
  methods: {
    greet: function (event) {
      // `this` 在方法里指当前 Vue 实例
      alert('Hello ' + this.name + '!')
      // `event` 是原生 DOM 事件
	  if (event) {
		  alert(event.target.tagName)
	  }
    }
  }
})
```

2、内联javascript语句绑定方法
```html
<div id="app">
  <button v-on:click="say('hi')">Say hi</button>
  <button v-on:click="say('what')">Say what</button>
</div>
```
```js
new Vue({
  el: '#app',
  methods: {
    say: function (message) {
      alert(message)
    }
  }
})
```

3、事件修饰符
> 1.描述：由(.)表示的指令后缀来调用修饰符

|值|描述|
|---|---|
|.stop|阻止单击事件冒泡|
|.prevent|提交事件不再重载页面|
|.capture|添加事件监听器时使用捕获模式|
|.self|只当事件在该元素本身(而不是子元素)触发时回调|
|.once|click事件只能点击一次|

4、按键修饰符
> 1.允许为 v-on 在监听键盘事件时添加按键修饰符
```
<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
<input v-on:keyup.13="submit">
```
> 2.记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：
```
<!-- 同上 -->
<input v-on:keyup.enter="submit">
<!-- 缩写语法 -->
<input @keyup.enter="submit">
```

|值|描述|
|---|---|
|.enter||
|.tab||
|.delete||
|.esc||
|.space||
|.up||
|.down||
|.left||
|.right||
|.ctrl||
|.alt||
|.shift||
|.meta||


1、表单应用
> 1.使用`v-model`实现双向数据绑定；

2、输入框
```html
<div id="app">
  <p>input 元素：</p>
  <input v-model="message" placeholder="编辑我……">
  <p>消息是: {{ message }}</p>

  <p>textarea 元素：</p>
  <p style="white-space: pre">{{ message2 }}</p>
  <textarea v-model="message2" placeholder="多行文本输入……"></textarea>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    message: 'Runoob',
	  message2: '菜鸟教程\r\nhttp://www.runoob.com'
  }
})
```

3、复选框
```html
<div id="app">
  <p>单个复选框：</p>
  <input type="checkbox" id="checkbox" v-model="checked">
  <label for="checkbox">{{ checked }}</label>

  <p>多个复选框：</p>
  <input type="checkbox" id="runoob" value="Runoob" v-model="checkedNames">
  <label for="runoob">Runoob</label>
  <input type="checkbox" id="google" value="Google" v-model="checkedNames">
  <label for="google">Google</label>
  <input type="checkbox" id="taobao" value="Taobao" v-model="checkedNames">
  <label for="taobao">taobao</label>
  <br>
  <span>选择的值为: {{ checkedNames }}</span>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
	checked : false,
    checkedNames: []
  }
})
```

4、单选按钮
```html
<div id="app">
  <input type="radio" id="runoob" value="Runoob" v-model="picked">
  <label for="runoob">Runoob</label>
  <br>
  <input type="radio" id="google" value="Google" v-model="picked">
  <label for="google">Google</label>
  <br>
  <span>选中值为: {{ picked }}</span>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
	picked : 'Runoob'
  }
})
```

5、select列表
```html
<div id="app">
  <select v-model="selected" name="fruit">
    <option value="">选择一个网站</option>
    <option value="www.runoob.com">Runoob</option>
    <option value="www.google.com">Google</option>
  </select>

  <div id="output">
      选择的网站是: {{selected}}
  </div>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
	selected: ''
  }
})
```

6、`v-model`中的修饰符
> 1.`.lazy`：转变为在change事件中同步；
```html
<input v-model.lazy="msg" >
```
> 2.`.number`：将输入的值Number值（如果原值的转换结果为NaN，则返回原值）
```html
<input v-model.number="age" type="number">
```
> 3.`.trim`：自动过滤用户输入的首尾空格；
```html
<input v-model.trim="msg">
```


1、组件Component
> 1.作用：可以扩展HTML元素，封装可重用的代码；
> 2.组件系统让我们可以独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树；
> 3.注册全局组件的语法：
> 1. tagName为组件名；
> 2. options为配置选项；
```js
Vue.component(tagName,options)
```
> 3. 注册完成后调用组件的方法：
```html
<tagName><tagName>
```

2、全局组件实例
> 1.创建一个全局组件runoob；
```html
<div id="app">
	<runoob></runoob>
</div>
```
```js
// 注册
Vue.component('runoob', {
  template: '<h1>自定义组件!</h1>'
})
// 创建根实例
new Vue({
  el: '#app'
})
```

3、局部组件
> 1.组件只能在这个实例中使用
```html
<div id="app">
	<runoob></runoob>
</div>
```
```js
var Child = {
  template: '<h1>自定义组件!</h1>'
}

// 创建根实例
new Vue({
  el: '#app',
  components: {
    // <runoob> 将只在父模板可用
    'runoob': Child
  }
})
```

4、prop属性
> 1.prop是父组件用来传递数据的一个自定义属性；
> 2.父组件通过props把数据传递给子组件，子组件需要显式地用props选项声明"prop"；
```html
<div id="app">
	<child message="hello!"></child>
</div>
```
```js
// 注册
Vue.component('child', {
  // 声明 props
  props: ['message'],
  // 同样也可以在 vm 实例中像 “this.message” 这样使用
  template: '<span>{{ message }}</span>'
})
// 创建根实例
new Vue({
  el: '#app'
})
```

5、动态prop
> 1.类似用`v-bind`绑定HTML特性到一个表达式，
> 2.也可以用`v-bind`动态绑定props的值到父组件的数据中；
> 3.每当父组件的数据变化时，该变化也会传导给子组件；
```html
<div id="app">
	<div>
	  <input v-model="parentMsg">
	  <br>
	  <child v-bind:message="parentMsg"></child>
	</div>
</div>
```
```js
// 注册
Vue.component('child', {
  // 声明 props
  props: ['message'],
  // 同样也可以在 vm 实例中像 “this.message” 这样使用
  template: '<span>{{ message }}</span>'
})
// 创建根实例
new Vue({
  el: '#app',
  data: {
	parentMsg: '父组件内容'
  }
})
```

6、自定义事件
> 1.父组件是使用props传递数据给子组件；
> 2.但是，如果子组件要把数据传递回去，就需要使用自定义事件；
> 3.可以使用`v-on`绑定自定义事件，每个Vue实例都实现了事件接口(Events interface)，即：
> 1. 使用`$on(eventName)`监听事件；
> 2. 使用`$emit(eventName)`触发事件；
```html
<div id="app">
	<div id="counter-event-example">
	  <p>{{ total }}</p>
	  <button-counter v-on:increment="incrementTotal"></button-counter>
	  <button-counter v-on:increment="incrementTotal"></button-counter>
	</div>
</div>
```
```js
Vue.component('button-counter', {
  template: '<button v-on:click="incrementHandler">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    incrementHandler: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})


new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
```

7、`.native`修饰符
> 1.作用：在某个组件的根元素上监听原生事件；

1、注册全局指令
> 1.语法：
```js
Vue.directive(tagName,options)
```
```html
<div id="app">
	<p>页面载入时，input 元素自动获取焦点：</p>
	<input v-focus>
</div>
```
```js
// 注册一个全局自定义指令 v-focus
Vue.directive('focus', {
  // 当绑定元素插入到 DOM 中。
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
// 创建根实例
new Vue({
  el: '#app'
})
```

2、注册局部指令
> 1.语法：使用directives选项来注册；
```html
<div id="app">
  <p>页面载入时，input 元素自动获取焦点：</p>
  <input v-focus>
</div>
```
```js
// 创建根实例
new Vue({
  el: '#app',
  directives: {
    // 注册一个局部的自定义指令 v-focus
    focus: {
      // 指令的定义
      inserted: function (el) {
        // 聚焦元素
        el.focus()
      }
    }
  }
})
```

3、钩子函数
> 1.bind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作；
> 2.inserted：被绑定元素插入父节点时嗲用(父节点存在即可调用，不必存在于document中)
> 3.update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的值，可以忽略不必要的模板更新；
> 4.componentUpdated：被绑定元素所在模板完成一次更新周期时调用；
> 5.unbind：只调用一次，指令与元素解绑时调用；

4、钩子函数参数
> 1.el：指令所绑定的元素，可以用来直接操作DOM
> 2.binding：
```
name：指令名，不包括v-前缀；
value：指令的绑定值
oldValue：指令绑定的前一个值，仅在update和componentUpdated钩子中可用。无论值是否改变都可用；
expression：绑定值得表达式或变量名
arg：传给指令的参数
modifiers：一个包含修饰符的对象
```
> 3.vnode：Vue编译生成的虚拟节点；
> 4.oldVnode：上一个虚拟节点，仅在update和componentUpdated钩子中使用；
```html
<div id="app"  v-runoob:hello.a.b="message">
</div>
```
```js
Vue.directive('runoob', {
  bind: function (el, binding, vnode) {
    var s = JSON.stringify
    el.innerHTML =
      'name: '       + s(binding.name) + '<br>' +
      'value: '      + s(binding.value) + '<br>' +
      'expression: ' + s(binding.expression) + '<br>' +
      'argument: '   + s(binding.arg) + '<br>' +
      'modifiers: '  + s(binding.modifiers) + '<br>' +
      'vnode keys: ' + Object.keys(vnode).join(', ')
  }
})
new Vue({
  el: '#app',
  data: {
    message: '菜鸟教程!'
  }
})
```


1、路由
> 1.允许我们通过不同的URL访问不同的内容；
> 2.需要载入`vue-router`库；


1、过渡
> 1.Vue在插入、更新或者移除DOM时，提供多种不同方式的应用的过渡效果；
> 2.Vue提供了内置的过渡封装组件，该组件用于包裹要实现过渡效果的组件；
> 3.语法格式：
```
<transition name="fade">
  <div></div>
</transition>
```
> 4.过渡本质是一个淡入淡出的效果。Vue在元素显示与隐藏的过程中，提供了6个class来切换；
> 1. v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除；
> 2. v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡或动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。
> 3. v-enter-to：**2.1.8版本及以上**，定义进入过渡的结束状态。在元素被插入之后下一帧生效(与此同时，v-enter被移除)，在过渡或动画完成之后移除；
> 4. v-leave：定义离开果醋的开始状态。在离开过渡被触发时立即生效，下一帧被移除；
> 5. v-leave-active：定义离开过渡生效的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立即生效，在过渡或动画完成之后移除。这个类可以用来定义离开过渡的过程时间，延迟和曲线函数；
> 6. v-leave-to：**2.1.8版本及以上**，定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效(与此同时，v-leave被移除)，在过渡或动画完成之后移除；


2、css过渡
> 1.通常使用css过渡来实现效果；
```html
<div id = "databinding">
  <button v-on:click = "show = !show">点我</button>
  <transition name="slide-fade">
    <p v-if="show">菜鸟教程</p>
  </transition>
</div>
```
```js
new Vue({
    el: '#databinding',
    data: {
        show: true
    }
})
```
```css
/* 可以设置不同的进入和离开动画 */
/* 设置持续时间和动画函数 */
.slide-fade-enter-active {
  transition: all .9s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-to
/* .slide-fade-leave-active 用于 2.1.8 以下版本 */ {
  transform: translateX(10px);
  opacity: 0;
}
```

3、css动画
> 1.css动画类似css过渡，但是在动画中`v-enter`类名，在节点插入DOM之后不会立即删除，而是在animationend事件触发时删除；
```html
<div id = "databinding">
  <button v-on:click = "show = !show">点我</button>
  <transition name="slide-fade">
    <p v-if="show">菜鸟教程</p>
  </transition>
</div>
```
```js
new Vue({
    el: '#databinding',
    data: {
        show: true
    }
})
```
```css
.bounce-enter-active {
  animation: bounce-in .5s;
}
.bounce-leave-active {
  animation: bounce-in .5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.5);
  }
  100% {
    transform: scale(1);
  }
}
```

4、自定义过渡的类名
> 1.通过以下特性来自定义过渡类名
```
enter-class
enter-active-class
enter-to-class
leave-class
leave-active-class
leave-to-class
```
> 2.自定义过渡的类名优先级高于普通的类名；
```html
<div id = "databinding">
  <button v-on:click = "show = !show">点我</button>
  <transition
    enter-active-class="animated tada"
    leave-active-class="animated bounceOutRight"
  >
    <p v-if="show">菜鸟教程 -- 学的不仅是技术，更是梦想！！！</p>
  </transition>
</div>
```
```js
new Vue({
    el: '#databinding',
    data: {
        show: true
    }
})
```

5、同时使用过渡和动画
> 1.Vue为了知道过渡的完成，必须设置相应的事件监听器。它可以是transitionend和animationend，这取决于给元素应用的CSS规则。如果使用其中一种，Vue能够自动识别类型并设置监听；
> 2.但是，在某个场景中，给同一个元素同时设置了两种过渡效果，比如animation很快的被触发完成了，而transition效果还没有结束。
> 3.此时，需要使用type特性并设置animation或transition来明确声明你需要Vue监听的类型。


6、显性的过渡持续时间
> 1.在很多情况下，Vue可以自动得出过渡效果的完成时机。
> 2.默认情况下，Vue会等待其在过渡效果的根元素的第一个transitionend或animationend时间。
> 3.也可以不这样设定，可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡时间；
> 4.这时，可以用`<transition>`组件上的duration属性定制一个显性的过渡时间(以毫秒计)；
```
<transition :duration="1000">...</transition>
```
> 5.也可以定制进入和移除的持续时间
```
<transition :duration="{enter:500,leave:800}">...</transition>
```

7、初始渲染的过渡
> 1.通过`appear`特性设置节点在初始渲染的过渡；
```
<transiton appear>
//.....
</transiton>
```
> 2.自定义CSS类名
```html
<transition
  appear
  appear-class="custom-appear-class"
  appear-to-class="custom-appear-to-class" (2.1.8+)
  appear-active-class="custom-appear-active-class"
>
  <!-- ... -->
</transition>
```

8、多个元素的过渡
> 1.可以设置多个元素的过渡，一般列表与描述；
> 2.需要注意：当有相同标签名的元素切换时，需要通过key特性设置唯一的值来标记，以让Vue区分它们，否则Vue为了效率只会替换相同标签内部的内容；
```html
<transition>
  <button v-if="isEditing" key="save">
    Save
  </button>
  <button v-else key="edit">
    Edit
  </button>
</transition>
```
```html
<transition>
  <button v-bind:key="isEditing">
    {{ isEditing ? 'Save' : 'Edit' }}
  </button>
</transition>
```


## Vuex

1、什么是Vuex
> 1.Vuex是一个专门为Vue.js应用程序开发的状态管理模式。
> 2.它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

2、什么是"状态管理模式"
> 1.包括三个部分:
> 1. `state`：驱动应用的数据源；
> 2. `view`：以声明方式将state映射到视图；
> 3. `actions`：响应在view上的用户输入导致的状态变化；
> 4. 这三个部分组成了单向数据流：
```
actions--->state--->view--->action
```

3、当应用遇到多个组件共享状态时，单向数据流很容易破坏
> 1.原因：
> 1. 多个视图依赖同一个状态；
> 2. 来自不同视图的行为需要变更同一状态；

4、什么时候使用Vuex
> 1.Vuex可以帮助我们管理共享状态，并附带了更多的概念和框架。
> 2.如果不打算开发大型单页应用，使用Vuex可能是冗余的；
> 3.如果应用够简单，最好不好使用Vuex。

5、Vuex应用核心
> 1.核心：store(仓库)。"store基本是一个容器，它包含着你的应用中大部分的状态(state)"。
> 2.Vuex和单纯的全局对象的不同点：
> 1. Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效的更新；
> 2. 不能直接的改变store中的状态。改变store状态的唯一途径就是显示的提交(commit)mutation。这样，使得我们可以方便的跟踪每一个状态的变化。

6、项目中使用Vuex的具体步骤
> 1.在项目中使用`cnpm install vuex --save`安装vuex模块；
> 1.在项目的，src文件夹中，新建一个文件夹（命名为store），用来存放store的操作；
> 2.在store文件夹下新建一个store.js文件，主要进行store的初始配置；
```
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex);

let store = new Vuex.Store({
    state: {
    num: 5,
  },
});

export default store;
```
> 3.在项目起始配置文件main.js中，新建的router实例中引入之前创建的store实例
```
import Vue from 'vue'
import App from './App'
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
import VueRouter from 'vue-router'
import routes from './routes'
import Vuex from 'vuex'
import store from'./store/store'     //引入store实例

Vue.use(ElementUI);
Vue.use(VueRouter);
Vue.use(Vuex);

//创建router实例
const router = new VueRouter({
  mode: 'history',
  routes,
  store,                  //引入store实例，以便于在以后的各个子组件中，都能使用this.$store来访问store实例
});
```
> 4.在子组件中访问store实例中的值，要在`computed`属性中；
```
<template>
  <div>
    //这里会输出"5"
    <p>state:{{count}}</p>
  </div>
</template>
```
```
export default {
  name: "Page5",
  computed: {
    count() {
      return this.$store.state.num;
    }
}
```


1、单一状态树
> 1.定义用一个对象就包含了全部的应用层级状态；至此它便作为一个“唯一数据源 (SSOT)”而存在。
> 2.这也意味着，每个应用将仅仅包含一个 store 实例。
> 3.单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。

2、在 Vue 组件中获得 Vuex 状态
> 1.Vuex 的状态存储是响应式的，
> 2.从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态
```
// 创建一个 Counter 组件，子组件中返回store实例的state里面的值
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
```
> 3.每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM；
> 4.但是，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态；
> 5.Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）；
```
const app = new Vue({
  el: '#app',
  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件，在main.js文件中配置
  store
})
```
> 6.通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。
```
//在子组件中通过this.$store访问store实例
export default {
  computed: {
    count () {
      return this.$store.state.count;
    }
  }
}
```

3、mapState 辅助函数
> 1.当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余；
> 2.为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键；
```
// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state => state.count,

    // 传字符串参数 'count' 等同于 `state => state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}
```
> 3.当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组；
```
computed: mapState([
  // 映射 this.count 为 store.state.count
  'count'
])
```

4、对象展开运算符
> 1.mapState 函数返回的是一个对象；
> 2.为了将它与局部计算属性混合使用，需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。
> 3.对象展开符：`...`，用三个点号表示；
```
computed: {
  localComputed () { /* ... */ },
  // 使用对象展开运算符将此对象混入到外部对象中
  ...mapState({
    // ...
  })
}
```

5、组件仍然保有局部状态
> 1.使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。
> 2.虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观；
> 3.如果有些状态严格属于单个组件，最好还是作为组件的局部状态；
> 4.应该根据你的应用开发需要进行权衡和确定。


1、getter
> 1.vuex允许在'store'实例中定义getter(类似于store的计算属性)；
> 2.就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变时，才会被重新计算；
```js
let store = new Vuex.Store({
  state: {
    num: 5,
  },
  getters: {
    changeNum(state) {
      return state.num++;
    }
  },
});
```

2、访问getter——属性访问
> 1.以属性的形式访问值——`store.getters`对象；
```js
export default {
  name: "Page5",

  computed: {
    getterNum(){
      return this.$store.getters.changeNum;
    }
  },
}
```

3、getter中传参——方法访问
> 1.通过让getter返回一个函数，来实现给getter传参；
> 2.在对store中的数组进行查询时非常有用。
```js
let store = new Vuex.Store({
  state: {
    num: 5,
    todos: [
      {
        id: 1, text: 'hello'
      },
      {
        id: 2, text: 'world'
      }
    ]
  },
  getters: {
    changeCount(state) {
      return state.num++;
    },
    getId: state => id => {
      return state.todos.find(todo => todo.id === id)
    }
  }
});
```
```js
computed: {
  count() {
    return this.$store.state.num;
  },
  getterNum(){
    return this.$store.getters.changeCount;
  },
  getId(){
    return this.$store.getters.getId(2);  //'{id: 2, text: 'world'}'
  }
},
```

4、传入第二个参数getters——指的是store中的getter中的所有方法
```js
state: {
  num: 5,
},
getters: {
  changeCount(state) {
    return state.num++;
  },
  getCounts(state, getters) {
    //这里的getters参数指向整个getters对象
    return state.num + getters.changeCount;
  }
},
```
```js
computed: {
  count() {
    return this.$store.state.num;              //6
  },
  getterNum(){
    return this.$store.getters.changeCount;    //5
  },
  getterNums(){
    return this.$store.getters.getCounts;      //11
  },
},
```

5、mapGetters辅助函数
> 1.`mapGetters`辅助函数仅仅是将store中的getter映射到局部计算属性；
```js
import {mapGetters} from 'vuex'

computed: {
  ...mapGetters({
    getMapId:'getId',
  })
},
```
```html
<p>getMapId:{{getMapId(1)}}</p>      //'{ "id": 1, "text": "hello" }'
```


1、Mutation
> 1.用途：更新vuex中的store里面的state；
> 2.Mutation非常类似于事件：每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)。
> 3.这个回调函数就是进行状态更改的地方，并且会接受state作为第一个参数。
```
let store = new Vuex.Store({
  state: {
    num: 5,
  mutations: {
    eventCount(state) {
      //变更状态
      state.num -= 1;
    }
  },
});
```
> 4.不能直接调用`mutation.handler`。这个选项更像是一个事件注册。
> 5.当触发一个`eventCount`的mutation时，调用此函数；
> 6.唤醒mutation handler，需要以相应的type调用`store.commit()`方法；
```
//在组件的methods方法中，唤醒handler
methods: {
  eventCount() {
    this.$store.commit('eventCount');
  }
}
```

2、提交载荷(Playload)
> 1.定义：可以向`store.commit`传入额外的参数，即为mutation的载荷(playload)；
```js
mutations: {
  eventCount(state, temp) {
    state.num += temp;
  }
},
```
```js
methods: {
  eventCount() {
    this.$store.commit('eventCount',5);
  }
}
```
```html
<button @click="eventCount">eventCount mutation:</button>
```
> 2.在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的mutation会更易读
```js
mutations: {
  eventCount(state, playload) {
    state.num += playload.temp;
  }
},
```
```js
methods: {
  eventCount() {
    this.$store.commit('eventCount',{temp:10});
  }
}
```

3、对象风格的提交方式
> 1.提交mutation的另一种方式，直接使用包含type属性的对象；
```js
methods: {
  eventCount() {
    this.$store.commit({
      type:'eventCount',
      temp:5
    })
  }
}
```

4、Mutation需要遵循Vue的响应规则
> 1.Vuex中的状态是响应性的，当我们变更状态时，监视状态的Vue组件也会自动更新。
> 2.这就意味着，Vuex中的mutation需要遵循一些规则：
> 3.最好提前在你的store中初始化好所有所需属性。
> 4.当需要在对象上添加新属性时，使用：
> 1. `Vue.set(obj,'newProp',123)`，或者
> 2. 以新对象替换老对象。例如，
```
state.obj = { ...state.obj, newProp:123 }
```

5、使用常量代替Mutation事件类型
> 1.使用常量替代mutation事件类型在各种Flux实现中是很常见的模式。
> 2.这样，可以使得linter之类的工具发挥作用；
> 3.同时，把这些常量放在单独的文件中可以让你的代码合作者对整个app包含的mutation一目了然。
```js
// mutation-types.js
export const SOME_MUTATION = 'SOME_MUTATION'
```
```js
// store.js
import Vuex from 'vuex'
import { SOME_MUTATION } from './mutation-types'

const store = new Vuex.Store({
  state: { ... },
  mutations: {
    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名
    [SOME_MUTATION] (state) {
      // mutate state
    }
  }
})
```

6、Mutation必须是同步函数
>

7、提交Mutation
> 1.在组件中提交`this.$store.commit('')`；
> 2.使用`mapMutations`辅助函数将组件中的methods映射为`store.commit`调用
```js
import { mapMutations } from 'vuex'

export default {
  // ...
  methods: {
    ...mapMutations([
      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`

      // `mapMutations` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`
    ]),
    ...mapMutations({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`
    })
  }
}
```
> 3.


1、Action
> 1.类似于mutation，不同之处在于：
> 2.Action提交的是mutation，而不是直接变更状态；
> 3.Action可以包含任意异步操作。
> 4.Action函数接受一个与store实例具有相同方法和属性的context对象，可以调用`context.commit()`提交一个mutation，或者
> 5.通过`context.state`和`context.getters`啦获取state和getters。
```js
mutations: {
  eventCount(state, playload) {
    state.num += playload.temp;
  }
},
actions: {
  eventAction (context) {
    context.commit('eventCount',{temp:2});
  }
}
```
```js
//需要调用多次commit方法时，用ES的参数解构，简化为
actions: {
  eventAction ({ commit }) {
    commit('eventCount')
  }
}
```

2、分发Action
> 1.Action通过`store.dispatch()`方法触发
```
store.dispatch('eventAction');
```
```js
mutations: {
  eventCount(state, playload) {
    state.num += playload.temp;
  }
},
actions: {
  eventAction (context) {
    context.commit('eventCount',{temp:2});
  }
}
```
```js
//在子组件中调用该方法
methods: {
  eventAction(){
    this.$store.dispatch('eventAction');
  }
}
```
```html
<button @click="eventAction">eventAction 同步Action:</button>
```
> 2.因为mutation必须同步执行，而action不受约束，可以在action内部执行异步操作
```js
mutations: {
  eventCount(state, playload) {
    state.num += playload.temp;
  }
},
actions: {
  //同步action
  eventAction(context) {
    context.commit('eventCount', {temp: 2});
  },
  //异步action,延迟一秒之后进行计算
  eventAsync({commit}) {
    setTimeout(() => {
      commit('eventCount', {temp: 5});
    },1000)
  }
}
```
```js
methods: {
  eventAction(){
    this.$store.dispatch('eventAction');
  },
  eventAsync(){
    this.$store.dispatch('eventAsync');
  }
},
```
```html
<button @click="eventAsync">eventAsync 异步Action:</button>
```

3、载荷分发和对象分发(未用到)
```
// 以载荷形式分发
store.dispatch('incrementAsync', {
  amount: 10
})

// 以对象形式分发
store.dispatch({
  type: 'incrementAsync',
  amount: 10
})
```

4、在组件中分发Action
> 1.方法一：`this.$store.dispatch('xxx')`分发action;
> 2.方法二：使用`mapActions`辅助函数将组件的methods映射为`store.dispatch`调用（需要在根节点注入store实例）
```js
import { mapActions } from 'vuex'

export default {
  // ...
  methods: {
    ...mapActions([
      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`

      // `mapActions` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
    ]),
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
  }
}
```

5、组合Action
> 1.Action通常是异步的，通过组合Action来解决多个异步action何时结束的问题；
> 2.`store.dispatch`可以处理被触发的action的处理函数返回的Promise，并且`store.dispatch`仍旧返回Promise；


1、Module-模块化
> 1.由于使用单一状态树，应用的所有状态会集中到一个比较大的对象中。
> 2.当应用变得非常复杂时，store对象就有可能变得非常臃肿。
> 3.为了解决这个问题，Vuex允许将store分割成模块(module)。
> 4.每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块——从上至下进行同样方式的分割；
```js
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

2、模块的局部状态
> 1.对于模块内的mutation和getter，接受的第一个参数是模块的局部状态对象；
```js
const moduleA = {
  state: { count: 0 },
  mutations: {
    increment (state) {
      // 这里的 `state` 对象是模块的局部状态
      state.count++
    }
  },

  getters: {
    doubleCount (state) {
      return state.count * 2
    }
  }
}
```
> 2.同样，对于模块内的action，局部状态通过`context.state`暴露出来，根节点状态则为`context.rootState`；
```js
const moduleA = {
  // ...
  actions: {
    incrementIfOddOnRootSum ({ state, commit, rootState }) {
      if ((state.count + rootState.count) % 2 === 1) {
        commit('increment')
      }
    }
  }
}
```
> 3.对于模块内部的getter，根节点状态会作为第三个参数暴露出来;；
```js
const moduleA = {
  // ...
  getters: {
    sumWithRootCount (state, getters, rootState) {
      return state.count + rootState.count
    }
  }
}
```

3、命名空间——嵌套模块
> 1.默认情况下，模块内部的action，mutation和getter是注册在全局命名空间的，这样使得多个模块能够对同一mutation或action做出响应。
> 2.如果希望模块具有更好的封装和复用性，可以通过添加`namespace:true`的方式使其成为带命名空间的模块，
> 3.当模块被注册后，它所有的getter，action和mutation都会自动根据模块注册的路径调整命名。
```js
const store = new Vuex.Store({
  modules: {
    account: {
      namespaced: true,

      // 模块内容（module assets）
      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响
      getters: {
        isAdmin () { ... } // -> getters['account/isAdmin']
      },
      actions: {
        login () { ... } // -> dispatch('account/login')
      },
      mutations: {
        login () { ... } // -> commit('account/login')
      },

      // 嵌套模块
      modules: {
        // 继承父模块的命名空间
        myPage: {
          state: { ... },
          getters: {
            profile () { ... } // -> getters['account/profile']
          }
        },

        // 进一步嵌套命名空间
        posts: {
          namespaced: true,

          state: { ... },
          getters: {
            popular () { ... } // -> getters['account/posts/popular']
          }
        }
      }
    }
  }
})
```

4、在带命名空间的模块内访问全局内容
> 1.希望使用全局的state和getter，`rootState`和`rootGetter`会作为第三和第四个参数传入getter，也会通过`context`对象的属性传入action。
> 2.若要在全局命名空间内分发action或提交mutation，将`{root:true}`作为第三个参数传给`dispatch`或`commit`即可。
```js
modules: {
  foo: {
    namespaced: true,

    getters: {
      // 在这个模块的 getter 中，`getters` 被局部化了
      // 你可以使用 getter 的第四个参数来调用 `rootGetters`
      someGetter (state, getters, rootState, rootGetters) {
        getters.someOtherGetter // -> 'foo/someOtherGetter'
        rootGetters.someOtherGetter // -> 'someOtherGetter'
      },
      someOtherGetter: state => { ... }
    },

    actions: {
      // 在这个模块中， dispatch 和 commit 也被局部化了
      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit
      someAction ({ dispatch, commit, getters, rootGetters }) {
        getters.someGetter // -> 'foo/someGetter'
        rootGetters.someGetter // -> 'someGetter'

        dispatch('someOtherAction') // -> 'foo/someOtherAction'
        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'

        commit('someMutation') // -> 'foo/someMutation'
        commit('someMutation', null, { root: true }) // -> 'someMutation'
      },
      someOtherAction (ctx, payload) { ... }
    }
  }
}
```

5、在带命名空间的模块注册全局action
> 1.需要在带命名空间的模块内注册全局action，可以添加`root:true`，并将这个action的定义放在函数`handler`中。
```js
{
  actions: {
    someOtherAction ({dispatch}) {
      dispatch('someAction')
    }
  },
  modules: {
    foo: {
      namespaced: true,

      actions: {
        someAction: {
          root: true,
          handler (namespacedContext, payload) { ... } // -> 'someAction'
        }
      }
    }
  }
}
```

6、带命名空间的绑定函数
> 1.当使用`mapState`,`mapGetters`,`mapActions`和`mapMutations`这些函数来绑定带命名空间的模块时，写起来会比较复杂；
```js
computed: {
  ...mapState({
    a: state => state.some.nested.module.a,
    b: state => state.some.nested.module.b
  })
},
methods: {
  ...mapActions([
    'some/nested/module/foo', // -> this['some/nested/module/foo']()
    'some/nested/module/bar' // -> this['some/nested/module/bar']()
  ])
}
```
> 2.对于这种情况，可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有的绑定都会自动将该模块作为上下文。
```js
computed: {
  ...mapState('some/nested/module', {
    a: state => state.a,
    b: state => state.b
  })
},
methods: {
  ...mapActions('some/nested/module', [
    'foo', // -> this.foo()
    'bar' // -> this.bar()
  ])
}
```
> 3.而且，你可以通过使用`createNamespacedHelpers`创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数。
```js
import { createNamespacedHelpers } from 'vuex'

const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state => state.a,
      b: state => state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      'foo',
      'bar'
    ])
  }
}
```

7、插件开发的注意事项
> 1.如果插件提供了模块并允许用户将其添加到Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，可以通过插件的参数对象来允许用户指定空间名称；
```js
// 通过插件的参数对象得到空间名称
// 然后返回 Vuex 插件函数
export function createPlugin (options = {}) {
  return function (store) {
    // 把空间名字添加到插件模块的类型（type）中去
    const namespace = options.namespace || ''
    store.dispatch(namespace + 'pluginAction')
  }
}
```

8、模块动态注册
> 1.在store创建之后，可以使用`store.registerModule`方法注册模块；
```js
// 注册模块 `myModule`
store.registerModule('myModule', {
  // ...
})
// 注册嵌套模块 `nested/myModule`
store.registerModule(['nested', 'myModule'], {
  // ...
})
```
> 2.之后就可以通过`store.state.myModule`和`store.state.nested.myModule`访问模块的状态；
> 3.模块动态注册功能使得其他Vue插件可以通过在store中附加新模块的方式来实现Vuex管理状态。
> 4.例如，`vuex-router-sync`插件就是通过动态注册模块将vue-router和vuex结合在一起，实现应用的路由状态管理。
> 5.使用`store.unregisterModule(moduleName)`来动态卸载模块。注意，不能使用该方法卸载静态模块（即创建store时声明的模块）。

9、保留state
> 1.在注册一个新的module时，可能想保留过去的state，例如，从一个服务器端渲染的应用保留state。
> 2.可以通过`preserveState`选项将其归档：`store.registerModule('a',module,{preserveState:true})`
> 3.当设置`preserveState:true`时，该模块会被注册，action，mutation和getter会被添加到store中，但是state不会。

10、模块重用
> 1.需要创建一个模块的多个实例，例如：
> 1. 创建多个store，它们公用同一个模块(例如，`runInNewContext`选项时`false`或`once`时，为了在服务器端渲染中避免有状态的单例)；
> 2. 在一个store中多次注册同一个模块；
```
```
> 2.如果我们可以使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时store或模块间数据互相污染的问题；
> 3.实际上，这和Vue组件被的data是同样的问题。解决方法是——使用一个函数来声明模块状态(仅2.3.0+支持)
```js
const MyReusableModule = {
  state () {
    return {
      foo: 'bar'
    }
  },
  // mutation, action 和 getter 等等...
}
```


1、Vuex遵循的规则
> 1.应用层级的状态应该集中到单个store对象中；
> 2.提交mutation是更改状态的唯一方法，并且这个过程是同步的；
> 3.异步逻辑都应该封装带action里面；

2、项目结构
> 1.对于大型应用，store文件过大，只需将action，mutation和getter分割到单独的文件
```
├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块
```
