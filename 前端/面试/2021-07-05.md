[TOC]

# 面试
## html

1、语义化的理解
> 1.去掉或者丢失样式的时候能够让页面呈现出清晰的结构;
> 2.有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
> 3.方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
> 4.便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化;

2、怎样实现语义化html
> 1.尽可能少的使用无语义的标签div和span；
> 2.在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；
> 3.不要使用纯样式标签，如：b、font、u等，改用css设置；
> 4.需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；
> 5.使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
> 6.表单域要用fieldset标签包起来，并用legend标签说明表单的用途；
> 7.每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。

3、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?
> 1.`<!DOCTYPE>` 声明位于文档中的最前面，处于`<html>`标签之前。告知浏览器以何种模式来渲染文档;
> 2.严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行;
> 3.在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作;
> 4.DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现;

4、Doctype文档类型有哪些
> 1.该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档;
> 2.HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset;
> 3.XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset;
> 4.Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页


5、HTML与XHTML——二者有什么区别
>1.所有的标记都必须要有一个相应的结束标记
2.所有标签的元素和属性的名字都必须使用小写
3.所有的XML标记都必须合理嵌套
4.所有的属性必须用引号""括起来
5.把所有<和&特殊符号用编码表示
6.给所有属性赋一个值
7.不要在注释内容中使“--”
8.图片必须有说明文字

6、html5有哪些新特性、移除了那些元素？
> 1.* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加
>
> 拖拽释放(Drag and drop) API
  语义化更好的内容标签（header,nav,footer,aside,article,section）
  音频、视频API(audio,video)
  画布(Canvas) API
  地理(Geolocation) API
  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
  sessionStorage 的数据在浏览器关闭后自动删除
  表单控件，calendar、date、time、email、url、search  
  新的技术webworker, websocket, Geolocation

> 2.移除的元素

>纯表现的元素：basefont，big，center，font, s，strike，tt，u；
>对可用性产生负面影响的元素：frame，frameset，noframes；

7、如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？
> 1.IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签;
> 2.浏览器支持新标签后，还需要添加标签默认的样式，最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
```
<!--[if lt IE 9]>
<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
<![endif]-->
```
> 3.如何区分： DOCTYPE声明，新增的结构元素，功能元素。

8、iframe有那些缺点？
> 1.优点：解决加载缓慢的第三方内容如图标和广告等的加载问题
> 1. 解决加载缓慢的第三方内容如图标和广告等的加载问题
> 2. Security sandbox
> 3. 并行加载脚本
```
```
> 2.`<iframe>`的缺点：
> 1. iframe会阻塞主页面的Onload事件；
> 2. 即时内容为空，加载也需要时间
> 3. 没有语意

9、行内元素有哪些？块级元素有哪些？空元素有哪些？
> 1.行内元素有：span a img input select strong
> 2.块级元素有：div ul ol dl dt dd h1 h2 h3 h4 p...
> 3.常见的空元素：br hr img input link meta  base area command embed keygen param source track wbr....

10、canvas和svg的区别?
> 1.svg
> 1. SVG是一种使用XML描述2D图形的语言;
> 2. SVG基于XML, 这意味着SVG DOM中的每个元素都是可用的. 所以可以为每个元素附加JavaScript事件处理器;
> 3. 在SVG中, 每个被绘制的图像均被视为对象. 如果SVG对象的属性发生变化, 那么浏览器能够自动重现图像;
```
```
> 2.Canvas
> 1. Canvas通过js来绘制2D图形;
> 2. Canvas是逐像素进行渲染的;
> 3. 在Canvas中, 一旦图形被绘制完成, 它就不会继续得到浏览器的关注. 如果其位置发生变化, 那么整个场景也需要重新绘制, 包括任何或许已被图形覆盖的对象
```
```
> 3.区别
> 1. Canvas支持分辨率, SVG不支持
> 2. Canvas不支持事件处理器, SVG支持
> 3. Canvas只有弱的文本渲染能力, 而SVG最适合带有大型渲染区域的应用程序(比如谷歌地图)
> 4. Canvas能够以.png或.jpg格式保存结果图像
> 5. SVG的复杂度过高的话会减慢渲染速度(任何过度使用DOM的应用都不快)
> 6. Canvas最适合图像密集型的游戏, 其中的许多对象会被频繁重绘. 而SVG不适合游戏应用
> 7. Canvas是基于位图的图像,它不能够改变大小, 只能缩放显示; SVG是基于矢量的, 所以它能够很好地处理图形大小的改变
> 8. Canvas提供的功能更原始, 适合像素处理, 动态渲染和大数据量绘制; SVG功能更完善, 适合静态图片显示, 高保真文档查看和打印的应用场景
> 9. 绘制Canvas对象后, 不能使用脚本和CSS对它进行修改; 而SVG对象是文档对象模型的一部分, 所以可以随时使用脚本和CSS修改它们

11、src和href的区别?
> 1.src指向外部资源的位置, 用于替换当前元素, 比如js脚本, 图片等元素;
> 2.href指向网络资源所在的位置, 用于在当前文档和引用资源间确定联系, 加载css

12、从前端角度出发谈谈做好seo需要考虑什么?
> 1.语义化html标签
> 2.合理的title, description, keywords;
> 3.重要的html代码放前面
> 4.少用iframe, 搜索引擎不会抓取iframe中的内容
> 5.图片加上alt

13、如果网页内容需要多语言,要怎么做?
> 1.采用统一编码utf-8模式

14、 `data-*`属性的作用
> 1.html5规范里增加了一个自定义data属性
> 1. 这些属性集可以通过对象的dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取;
```
<div data-author="david" data-time="2011-06-20" data-comment-num="10">
//内容
</div>
div.dataset.commentNum; // 可通过js获取 10
```
> 2.需要注意的是，data-之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格

15、请描述一下 cookies，sessionStorage 和 localStorage 的区别？
> 1.cookie:
> 1. cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）
> 2. cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递
```
```
> 2.sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存
> 3.存储大小：
> 1. cookie数据大小不能超过4k
> 2. sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
```
```
> 4.有期时间：
> 1. localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
> 2. sessionStorage  数据在当前浏览器窗口关闭后自动删除
> 3. cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
```
```
> 5.作用域不同:
> 1. sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面，仅在当前页中有效；
> 2. localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

16、浏览器本地存储与服务器端存储之间的区别
> 1.其实数据既可以在浏览器本地存储，也可以在服务器端存储
> 2.浏览器端可以保存一些数据，需要的时候直接从本地获取，sessionStorage、localStorage和cookie都由浏览器存储在本地的数据
> 3.服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据
> 1. 服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端
> 2. 服务器端也可以保存用户的临时会话数据。服务器端的session机制，如jsp的 session 对象，数据保存在服务器上。实现上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象。会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期.
```
```
> 4.服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分布保存在用户各自的浏览器中
> 5.浏览器端一般只用来存储小数据，而服务器可以存储大数据或小数据
> 6.服务器存储数据安全一些，浏览器只适合存储一般数据

17、sessionStorage和页面js数据对象的区别（有问题）
> 1.页面中一般的 js 对象或数据的生存期是仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了
> 2.而sessionStorage 只要同源的同窗口（或tab）中，刷新页面或进入同源的不同页面，数据始终存在。也就是说只要这个浏览器窗口没有关闭，加载新页面或重新加载，数据仍然存在


## css

1、display:none和visibility:hidden的区别？
> 1.display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在;
> 2.visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间;

2、CSS中 link 和@import 的区别是？
> 1.link属于HTML标签，而@import是CSS提供的;
> 2.页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
> 3.import只在IE5以上才能识别，而link是HTML标签，无兼容问题;
> 4.link方式的样式的权重 高于@import的权重。

3、position的absolute与fixed共同点与不同点
> 1.共同点：
> 1. 改变行内元素的呈现方式，display被置为block；
> 2. 让元素脱离普通流，不占据空间；
> 3. 默认会覆盖到非定位元素上;
```
```
> 2.不同点：
> 1. absolute的”根元素“是可以设置的，
> 2. 而fixed的”根元素“固定为浏览器窗口。
> 3. 当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的


4、介绍一下CSS的盒子模型？
> 1.有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 padding;
> 2.盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border);

5、CSS 选择符有哪些？
> 1.id选择器（ # myid）
> 2.类选择器（.myclassname）
> 3.标签选择器（div, h1, p）
> 4.相邻选择器（h1 + p）
> 5.子选择器（ul > li）
> 6.后代选择器（li a）
> 7.通配符选择器（ * ）
> 8.属性选择器（a[rel = "external"]）
> 9.伪类选择器（a: hover, li:nth-child）
> 10.伪元素选择器（span:after）

6、哪些属性可以继承？
> 1.可继承：font-size ,font-family, color, text-indent;
> 2.不可继承：border padding margin width height；

7、选择器的优先级算法如何计算？
> 1.优先级就近原则，同权重情况下样式定义最近者为准;
> 2.优先级：
```   
!important > 内联样式 >  id > class > tag  
important 比 内联优先级高,但内联比 id 要高
```

8、CSS3新增伪类有那些？
```
p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。
p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。
p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。
:enabled  :disabled 控制表单控件的禁用状态。
:checked        单选框或复选框被选中。
```

9、列出display的值，说明他们的作用
> 1.block 像块类型元素一样显示;
> 2.inline 缺省值。像行内元素类型一样显示
> 3.inline-block 像行内元素一样显示，但其内容象块类型元素一样显示
> 4.list-item 象块类型元素一样显示，并添加样式列表标记

10、block, inline和inline-block的区别
> 1.起新行
> 1. block元素会独占一行, 多个block元素会各自新起一行. 默认情况下, block元素宽度自动填满其父元素宽度;
> 2. inline元素不会独占一行, 多个相邻的行内元素会排列在同一行里, 直到一行排列不下, 才会新换一行, 其宽度随元素的内容而变化;
```
```
> 2.设置宽高
> 1. block元素可以设置width, height属性. 块级元素即使设置了宽度, 仍然独占一行;
> 2. inline元素设置width, height无效
```
```
> 3.内外边距
> 1. block元素可以设置margin和padding属性
> 2. inline元素的margin和padding属性,水平方向的padding-left, padding-right, margin-left, margin-right都会产生边距效果. 但是数值方向的 margin/padding-top/bottom不会产生边距效果
```
```
> 4.包含
> 1. block可以包含inline和block元素,
> 2. inline元只能包含inline元素;
```
```
> 5.display: inline-block
> 1. 将对象呈现为inline对象, 但是对象的内容作为block对象呈现,之后的内联对象会被排列到一行内;
> 2. 比如我们可以给一个link(a元素)inline-block的属性, 使其既有block的高宽特性又有inline的同行特性

11、position的值， relative和absolute分别是相对于谁进行定位的？
> 1.absolute：生成绝对定位的元素，相对于除 static 定位以外的第一个祖先元素进行定位；
> 2.fixed （老IE不支持）：生成绝对定位的元素，相对于浏览器窗口进行定位；
> 3.relative：生成相对定位的元素，相对于其在普通流中的位置进行定位;
> 4.static  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）；
> 5.inherit 规定从父元素继承 position 属性的值；

12、CSS3有哪些新特性？
```
CSS3实现圆角（border-radius），阴影（box-shadow），
对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
增加了更多的CSS选择器  多背景 rgba
在CSS3中唯一引入的伪元素是::selection.
媒体查询，多栏布局
border-image
```

13、为什么要初始化CSS样式
> 1. 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异；
> 2.当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化;
> 3.最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议）;

14、对BFC规范的理解？
> 1.BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠;

15、解释下 CSS sprites，以及你要如何在页面或网站中使用它
> 1.CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位;
> 2.background-position可以用数字能精确的定位出背景图片的位置.
> 3.可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个;

16、box-sizing属性
> 1.box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box；
> 2.content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高;
> 3.border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content;
> 4.标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局

17、解释浮动和工作原理
> 1.浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次;
> 2.假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐;
> 3.清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示;

18、清除浮动的方法
> 1.父级div定义伪类：after和zoom
> 2.在结尾处添加空div标签clear:both
> 3.父级div定义height
> 4.父级div定义overflow:hidden
> 5.父级div定义overflow:auto
> 6.父级div也一起浮动
> 7.父级div定义display:table
> 8.结尾处加br标签clear:both

19、img设置属性title和alt的区别?
> 1.Alt是img的特有属性, 或与<input type="image">配合使用，规定图像的替代文本. 如果无法显示图像, 浏览器将显示替代文本. 用于图片无法加载显示、读屏器阅读图片，可提高图片可 访问性，搜索引擎会重点分析。最长可包含1024个字符
> 2.Title为元素提供附加的提示信息，用于鼠标滑到元素上的时候显示。其值可以比alt属性值设置的更长, 但是有些浏览器会截断过长的文字.

20、css3动画和js动画的优缺点
> 1.CSS3的动画
> 1. 优点：在性能上会稍微好一些，浏览器会对CSS3的动画做一些优化（比如专门新建一个图层用来跑动画）
> 2. 代码相对简单
```
```
> 1. 缺点：在动画控制上不够灵活
> 2. 兼容性不好
> 3. 部分动画功能无法实现（如滚动动画，视差滚动等）
```
```
> 2.JavaScript的动画
> 1. 优点：控制能力很强，可以单帧的控制、变换
> 2. 兼容性好，写得好完全可以兼容IE6，且功能强大
```
```
> 2. 缺点：计算没有css快，另外经常需要依赖其他的库


## js

1、apply和call的用法和区别
> 1.用法: 都能继承另一个对象的方法和属性,区别在于参数列表不一样;
> 2.区别
> 1. Function.apply(obj, args) args是一个数组,作为参数传给Function
> 2. Function.call(obj, arg1, arg2,...)  arg*是参数列表
> 3. apply一个妙用: 可以将一个数组默认的转化为一个参数列表（举个例子: 有一个数组arr要push进一个新的数组中去, 如果用call的话需要把数组中的元素一个个取出来再push, 而用apply只有Array.prototype.push.apply(this, arr)）

2、bind函数的兼容性
> 1.bind()函数会创建一个新函数, 为绑定函数。当调用这个绑定函数时,绑定函数会以创建它时传入bind方法的第一个参数作为this,传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数
> 2.一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数;

3、事件代理
> 1.事件委托利用了事件冒泡, 只指定一个事件处理程序, 就可以管理某一类型的所有事件
```html
<ul id="list">
    <li id="li-1">Li 2</li>
    <li id="li-2">Li 3</li>
    <li id="li-3">Li 4</li>
    <li id="li-4">Li 5</li>
    <li id="li-5">Li 6</li>
    <li id="li-6">Li 7</li>
</ul>
```
```js
//js部分
document.getElementById("list").addHandler("click", function(e){
    var e = e || window.event;
    var target = e.target || e.srcElement;
    if(target.nodeName.toUpperCase == "LI"){
        console.log("List item", e,target.id, "was clicked!");
    }
});
```

4、 解释下js中this是怎么工作的?
> 1.this 在 JavaScript 中主要由以下五种使用场景
> 1. 作为函数调用，this 绑定全局对象，浏览器环境全局对象为 window
> 2. 内部函数的 this 也绑定全局对象，应该绑定到其外层函数对应的对象上，这是 JavaScript的缺陷，用that替换
> 3. 作为构造函数使用，this 绑定到新创建的对象
> 4. 作为对象方法使用，this 绑定到该对象
> 5. 使用apply或call调用 this 将会被显式设置为函数调用的第一个参数

5、什么是闭包? 闭包有什么作用?
> 1.闭包是指有权访问另一个函数作用域中的变量的函数. 创建闭包常见方式,就是在一个函数内部创建另一个函数
> 2.作用
> 1. 匿名自执行函数  (function (){ ... })();   创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象
> 2. 缓存, 可保留函数内部的值
> 3. 实现封装
> 4. 实现模板

6、 undefined和null的区别
> 1.null表示没有对象, 即此处不该有此值. 典型用法
> 1. 作为函数的参数，表示该函数的参数不是对象
> 2. 作为对象原型链的终点
> 3. null可以作为空指针. 只要意在保存对象的值还没有真正保存对象,就应该明确地让该对象保存null值
```
```
> 2.undefined表示缺少值, 即此处应该有值, 但还未定义
> 1. 变量被声明了，但没有赋值时，就等于undefined
> 2. 调用函数时，应该提供的参数没有提供，该参数等于undefined
> 3. 对象没有赋值的属性，该属性的值为undefined
> 4. 函数没有返回值时，默认返回undefined

7、IIFE(立即调用的函数表达式)：function foo(){ }();
> 1.函数定义（语句以function关键字开始）是不能被立即执行的，这无疑会导致语法的错误（SyntaxError）
> 2.当函数定义代码段包裹在括号内，使解析器可以将之识别为函数表达式，然后调用。IIFE:  (function foo(){})()　

8、"attribute" 和 "property" 的区别是什么
> 1.DOM元素的attribute和property两者是不同的东西。attribute翻译为“特性”，property翻译为“属性”
> 2.attribute是一个特性节点，每个DOM元素都有一个对应的attributes属性来存放所有的attribute节点，attributes是一个类数组的容器，说得准确点就是NameNodeMap，不继承于Array.prototype，不能直接调用Array的方法。attributes的每个数字索引以名值对(name=”value”)的形式存放了一个attribute节点。
> 3.property就是一个属性，如果把DOM元素看成是一个普通的Object对象，那么property就是一个以名值对(name=”value”)的形式存放在Object中的属性。要添加和删除property和普通的对象类似。
> 4.很多attribute节点还有一个相对应的property属性，比如上面的div元素的id和class既是attribute，也有对应的property，不管使用哪种方法都可以访问和修改
> 5.总之，attribute节点都是在HTML代码中可见的，而property只是一个普通的名值对属性

9、请指出 document load 和 document ready 两个事件的区别
> 1.JavaScript文档加载完成事件。页面加载完成有两种事件
> 1. 一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）
> 2. 二是onload，指示页面包含图片等文件在内的所有元素都加载完成
```
```
> 2.jQuery中$(function(){/* do something*/});他的作用或者意义就是:在DOM加载完成后就可以可以对DOM进行操作。一般情况先一个页面响应加载的顺序是，域名解析-加载html-加载js和css-加载图片等其他信息

10、什么是use strict? 其好处坏处分别是什么?
> 1.在所有的函数 (或者所有最外层函数) 的开始处加入 "use strict"; 指令启动严格模式
> 2."严格模式"有两种调用方法
> 1. 将"use strict"放在脚本文件的第一行，则整个脚本都将以"严格模式"运行。如果这行语句不在第一行，则无效，整个脚本以"正常模式"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意
> 2. 将整个脚本文件放在一个立即执行的匿名函数之中
```
```
> 3.好处
> 1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为
> 2. 消除代码运行的一些不安全之处，保证代码运行的安全；
> 3. 提高编译器效率，增加运行速度；
> 4. 为未来新版本的Javascript做好铺垫。
```
```
4.坏处
> 1. 同样的代码，在"严格模式"中，可能会有不一样的运行结果；一些在"正常模式"下可以运行的语句，在"严格模式"下将不能运行

11、浏览器端的js包括哪几个部分?
> 1.核心( ECMAScript) , 文档对象模型(DOM), 浏览器对象模型(BOM)

12、DOM包括哪些对象?
> 1.DOM是针对HTML和XML文档的一个API(应用程序编程接口). DOM描绘了一个层次化的节点树, 允许开发人员添加, 移除和修改页面的某一部分;
> 2.常用的DOM方法
```
getElementById(id)
getElementsByTagName()
appendChild(node)
removeChild(node)
replaceChild()
insertChild()
createElement()
createTextNode()
getAttribute()
setAttribute()
```
> 3.常用的DOM属性
```
innerHTML  节点(元素)的文本值
parentNode  节点(元素)的父节点
childNodes
attributes   节点(元素)的属性节点
```

13、js有哪些基本类型?
> 1. Undefined, Null, Boolean, Number, String
> 2.Object是复杂数据类型, 其本质是由一组无序的名值对组成的

14、基本类型与引用类型有什么区别?
> 1.基本类型如上题所示. 引用类型则有: Object, Array, Date, RegExp, Function
> 2.存储
> 1. 基本类型值在内存中占据固定大小的空间,因此被保存在栈内存中
> 2. 引用类型的值是对象, 保存在堆内存中. 包含引用类型的变量实际上包含的并不是对象本身, 而是一个指向改对象的指针s
```
```
> 3.复制
> 1. 从一个变量向另一个变量复制基本类型的值, 会创建这个值的一个副本
> 2. 从一个变量向另一个变量复制引用类型的值, 复制的其实是指针,　因此两个变量最终都指向同一个对象
```
```
> 3.检测类型
> 1. 确定一个值是哪种基本类型可以用typeof操作符
> 2. 而确定一个值是哪种引用类型可以使用instanceof操作符　

15、关于js的垃圾收集例程
> 1.js是一门具有自动垃圾回收机制的编程语言,开发人员不必关心内存分配和回收问题
> 2.离开作用域的值将被自动标记为可以回收, 因此将在垃圾收集期间被删除
> 3."标记清除"是目前主流的垃圾收集算法, 这种算法的思路是给当前不使用的值加上标记, 然后再回收其内存
> 4.另一种垃圾收集算法是"引用计数", 这种算法的思想是跟踪记录所有值被引用的次数. js引擎目前都不再使用这种算法, 但在IE中访问非原生JS对象(如DOM元素)时, 这种算法仍然可能会导致问题
> 5.当代码中存在循环引用现象时, "引用计数" 算法就会导致问题
> 6.解除变量的引用不仅有助于消除循环引用现象, 而且对垃圾收集也有好处. 为了确保有效地回收内存, 应该及时解除不再使用的全局对象, 全局对象属性以及循环引用变量的引用

16、js有几种函数调用方式?
> 1.方法调用模型    var obj = { func : function(){};}    obj.func()
> 2.函数调用模式　　var func = function(){}    func();
> 3.构造器调用模式
> 4.apply/ call调用模式

17、描述事件模型?IE的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？
> 1.捕获->处于目标->冒泡，IE应该是只有冒泡没有捕获
> 2.事件代理就是在父元素上绑定事件来处理，通过event对象的target来定位

18、js动画有哪些实现方法?
> 1.用定时器 setTimeout和setInterval

19、还有什么实现动画的方法
> 1.js动画: 使用定时器
> 2.CSS : transition , animation
> 1. transition 包含4种属性：transition-delaytransition-durationtransition-propertytransition-timing-function，对应动画的4种属性： 延迟、持续时间、对应css属性和缓动函数，
> 2. transform 包含7种属性：animation-nameanimation-durationanimation-timing-functionanimation-delayanimation-directionanimation-iteration-countanimation-fill-modeanimation-play-state，它们可以定义动画名称，持续时间，缓动函数，动画延迟，动画方向，重复次数，填充模式
```
```
> 3.HTML5 动画
> 1. canvas
> 2. svg
> 3. webgl

20、面向对象有哪几个特点?
> 1.封装, 继承, 多态

21、如何判断属性来自自身对象还是原型链?
> 1.hasOwnPrototype

22、图片预加载的实现
> 1.使用jQuery图片预加载插件Lazy Load
> 1. 加载jQuery, 与jquery.lazyload.js
> 2. 设置图片的占位符为data-original, 给图片一个特别的标签,比如class=".lazy"
> 3. 然后延迟加载: $('img.lazy').lazyload();这个函数可以选择一些参数:
```
图片预先加载距离：threshold，通过设置这个值，在图片未出现在可视区域的顶部距离这个值时加载。
事件绑定加载的方式：event
图片限定在某个容器内：container
```
> 2.使用js实现图片加载: 就是new一个图片对象, 绑定onload函数, 赋值url
> 3.用CSS实现图片的预加载
> 1. 写一个CSS样式设置一批背景图片，然后将其隐藏
> 2. 改进: 使用js来推迟预加载时间, 防止与页面其他内容一起加载
```
```
> 4.用Ajax实现预加载：其实就是通过ajax请求请求图片地址. 还可以用这种方式加载css,js文件等

23、如果在同一个元素上绑定了两个click事件, 一个在捕获阶段执行, 一个在冒泡阶段执行. 那么当触发click条件时, 会执行几个事件? 执行顺序是什么?
> 1.绑定在目标元素上的事件是按照绑定的顺序执行的
> 1. 绑定在被点击元素的事件是按照代码顺序发生，
> 2. 其他元素通过冒泡或者捕获“感知”的事件，
> 3. 按照W3C的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -> 本元素代码顺序事件 -> 其他元素冒泡阶段事件
```html
<div class="div1" id="one">
    <div class="div2" id="two"></div>
</div>
```
```js
//点击div2，触发的事件顺序是：首先是找到父元素div1的捕获事件，其次是目标元素div2的事件（按照代码顺序执行），最后执行div1的冒泡事件
//捕获 one
//冒泡 two
//捕获 two
//冒泡 one
let div1 = document.getElementById('one');
let div2 = document.getElementById('two');

div2.addEventListener('click', function () {
    console.log('冒泡', 'two');
}, false);
div2.addEventListener('click', function () {
    console.log('捕获', 'two');
}, true);
div1.addEventListener('click', function () {
    console.log('冒泡', 'one');
}, false);
div1.addEventListener('click', function () {
    console.log('捕获', 'one');
}, true);
```

24、js中怎么实现块级作用域?
> 1.使用匿名函数, (立即执行函数)
```
(function(){...})()
```
> 2.es6：块级作用域引入了两种新的声明形式,可以用它们定义一个只存在于某个语句块中的变量或常量。
> 1. let: 语法上非常类似于var, 但定义的变量只存在于当前的语句块中
> 2. const: 和let类似,但声明的是一个只读的常量;
> **注意：使用let代替var可以更容易的定义一个只在某个语句块中存在的局部变量,而不用担心它和函数体中其他部分的同名变量有冲突.在let语句内部用var声明的变量和在let语句外部用var声明的变量没什么差别,它们都拥有函数作用域,而不是块级作用域**

25、构造函数里定义function和使用prototype.func的区别？
> 1.直接调用function，每一个类的实例都会拷贝这个函数，弊端就是浪费内存;
> 2.prototype方式定义的方式，函数不会拷贝到每一个实例中，所有的实例共享prototype中的定义，节省了内存;
> 3.但是如果prototype的属性是对象的话，所有实例也会共享一个对象（这里问的是函数应该不会出现这个情况）,
> 4.如果其中一个实例改变了对象的值，则所有实例的值都会被改变。同理的话，如果使用prototype调用的函数，一旦改变，所有实例的方法都会改变

26、js实现对象的深克隆
> 1.js中数据类型分为基本数据类型(number, string, boolean, null, undefined)和引用类型值(对象, 数组, 函数). 这两类对象在复制克隆的时候是有很大区别的;
> 2.原始类型存储的是对象的实际数据, 而对象类型存储的是对象的引用地址(对象的实际内容单独存放, 为了减少数据开销通常放在内存中)
> 3.此外, 对象的原型也是引用对象, 它把原型的属性和方法放在内存中, 通过原型链的方式来指向这个内存地址.
> 4.于是克隆也会分为两类:
> 1. 浅度克隆: 原始类型为值传递, 对象类型仍为引用传递
> 2. 深度克隆: 所有元素或属性均完全复制, 与原对象完全脱离, 也就是说所有对于新对象的修改都不会反映到原对象中.


# 网站开发流程
## html页面开发流程

1、开发整站的两种方式
> 1.从头往下依次把每个盒子写完；
> 2.先把网站的布局搞定，然后将每个布局的盒子中的元素补齐（模块化）；

2、整站项目的目录结构
> 1.所有的文件放在一个文件夹中；
> 2.所有的图片放在img文件夹；
> 3.所有的css文件放在css文件夹；
> 4.所有的js文件放在js文件夹；
> 5.整站的入口：index.html；

3、CSS Reset(css初始化)
> 1.不同的浏览器对每一个标签都有默认样式，大部分的浏览的默认样式都有区别，所以，要让所有的默认样式清零。
```yui3
html {
    color: #000;
    background: #FFF
}

body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, code, form, fieldset, legend, input, textarea, p, blockquote, th, td {
    margin: 0;
    padding: 0
}

table {
    border-collapse: collapse;
    border-spacing: 0
}

fieldset, img {
    border: 0
}

address, caption, cite, code, dfn, em, strong, th, var {
    font-style: normal;
    font-weight: normal
}

ol, ul {
    list-style: none
}

caption, th {
    text-align: left
}

h1, h2, h3, h4, h5, h6 {
    font-size: 100%;
    font-weight: normal
}

q:before, q:after {
    content: ''
}

abbr, acronym {
    border: 0;
    font-variant: normal
}

sup {
    vertical-align: text-top
}

sub {
    vertical-align: text-bottom
}

input, textarea, select {
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    *font-size: 100%
}

legend {
    color: #000
}

#yui3-css-stamp.cssreset {
    display: none
}

```

4、精灵图
> 1.其他名称：雪碧图，雪碧技术，css sprite。
> 2.作用：用于将网站上的一些小图片管理到一个大的图片中；
> 3.制作：
> 1. 一定是一些小图片（最好不太会发生变化）
> 2. 精灵图在制作的时候宽度一定要大于最大的那张图片宽度；
> 3. 图片与图片之间要有空隙；
> 4. 在精灵图制作完成之后，一定要将精灵图的下方留出足够的位置，用来方便进行扩展；

5、IconFont
> 1.定义：指用字体文件代替图片文件，来展示图标，特殊字体等元素；
> 2.优点:
> 1. 加载文件体积小；
> 2. 可以直接通过css的font-size，和color修改它的大小和颜色，对于需要做多个尺寸的图标，是个很好的方法；
> 3. 支持一些css3对文字的效果，如：阴影、旋转、透明度。
> 4. 兼容低版本浏览器；
```
```
> 3.缺点：
> 1. 矢量图只能是纯色的；
> 2. 制作门槛高，耗时长，维护成本很高。

6、生成IconFont字体文件
> 1.设计矢量图，然后通过工具直接转换为相应的字体；
> 2.使用第三方IconFont在线服务（阿里巴巴IconFont平台），直接上传设计的图标矢量图生成字体文件；

7、使用IconFont字体文件
> 1.font-face字体声明：不同的浏览器调用不同的字体文件；
```
@font-face {font-family: "iconfont";
  src: url('iconfont.eot'); /* IE9*/
  src: url('iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
  url('iconfont.woff') format('woff'), /* chrome, firefox */
  url('iconfont.ttf') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/
  url('iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */
}
```
> 2.定义IconFont样式
```
.iconfont {
   font-family:"iconfont" !important;
   font-size:16px;
}
```
> 3.挑选图标对应的字体编码，应用于页面中
```
<i class="icon iconfont">&#xe60e;</i>
```

8、IconFont存在的问题(实践)
> 1.字体图标在一些浏览器下会遇到被加粗的问题，设置-webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;解决。
> 2.跨域访问不到字体，由于怕字体版权得不到保护，默认跨域的字体文件是访问不到的，一般通过服务器设置 Access-Control-Allow-Origin指定自己需要的网站和设置同域来解决这个问题。
> 3.不要包含没有使用的@font-face，IE将不分他是否使用，统统加载下来。万恶的IE。
> 4.@font-face声明之前，如果有script标签的话，直到字体文件完成下载之前，IE将都不会渲染任何东西。

IconFont三种使用方式，推荐第二种：https://blog.csdn.net/qq_39176732/article/details/81390423

## 网站布局

https://www.cnblogs.com/yanayana/p/7066948.html

1、静态布局（Static Layout）
> 1.即传统Web设计，网页上的所有元素的尺寸一律使用px作为单位。

> 2.布局特点：不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见与pc端。
> 3.设计方法：
　　PC：居中布局，所有样式使用绝对宽度/高度(px)，设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；
　　移动设备：另外建立移动网站，单独设计一个布局，使用不同的域名如wap.或m.。

> 4.在移动端开发中采用静态布局的两种方式：(来自：流布局与响应式网页设计有什么区别？)

> 1）在viewport meta标签上设置width=320，页面的各个元素也采用px作为单位。通过用JS动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。（见前端开发-web app 变革之rem）

> 2）设在viewport meta标签上设置content"width=640,user-scalable=no，页面的各个元素也采用px作为单位。由于640px超出了手机宽度，浏览器会自动缩小页面至刚好全屏。（具体见content"width=640,user-scalable=no" 然后再进行固定尺寸的px设计？ - 前端开发）

> 优点：这种布局方式对设计师和CSS编写者来说都是最简单的，亦没有兼容性问题。

> 缺点：显而易见，即不能根据用户的屏幕尺寸做出不同的表现。

> 当前，大部分门户网站、大部分企业的PC宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。


2、流式布局（Liquid Layout）

>流式布局（Liquid）的特点（也叫"Fluid") 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。

>网页中主要的划分区域的尺寸使用百分数（搭配`min-*、max-*`属性使用），例如，设置网页主体的宽度为80%，min-width为960px。图片也作类似处理（width:100%, max-width一般设定为图片本身的尺寸，防止被拉伸而失真）。

>1、布局特点：屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示】

>2、设计方法：使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。

>这种布局方式在Web前端开发的早期历史上，用来应对不同尺寸的PC屏幕（那时屏幕尺寸的差异不会太大），在当今的移动端开发也是常用布局方式，但缺点明显：主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。

3、自适应布局（Adaptive Layout）
>自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个系列。
1、布局特点：屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。
2、设计方法：使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。


4、响应式布局（Responsive Layout）

>随着CSS3出现了媒体查询技术，又出现了响应式设计的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的Web浏览器等等）都能显示出令人满意的效果，对CSS编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。

>响应式几乎已经成为优秀页面布局的标准。

>1、布局特点：每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。

>2、设计方法：媒体查询+流式布局。通常使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。

>优点：适应pc和移动端，如果足够耐心，效果完美

>缺点：（1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。（2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。

>总结：

>响应式与自适应的原理是相似的，都是检测设备，根据不同的设备采用不同的css，而且css都是采用的百分比的，而不是固定的宽度，不同点是响应式的模板在不同的设备上看上去是不一样的，会随着设备的改变而改变展示样式，而自适应不会，所有的设备看起来都是一套的模板，不过是长度或者图片变小了，不会根据设备采用不同的展示样式，流式就是采用了一些设置，当宽度大于多少时怎么展示，小于多少时怎么展示，而且展示的方式向水流一样，一部分一部分的加载，静态的就是采用固定宽度的了。

>流式布局是用于解决类似的设备不同分辨率之间的兼容(一般分辨率差异较少)；响应式是用于解决不用设备之间不用分辨率之间的兼容问题(一般是指PC，平板，手机等设备之间较大的分辨率差异)。

>如何实现响应式布局：折腾响应式布局设计，应运而生的web页面响应布局

5、弹性布局（rem/em布局）

>参考：流布局与响应式网页设计有什么区别？
1、rem,em区别：rem,em都是顺应不同网页字体大小展现而产生的。其中，em是相对其父元素，在实际应用中相对而言会带来很多不便；而rem是始终相对于html大小，即页面根元素。

>2、使用 em 或 rem 单位进行相对布局，相对%百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示，因为em是相对父级元素的原因没有得到推广。【中国站点制作网页的时候，习惯用CSS强制定义字体大小，保证每个人都看到一致的效果，包括网易、搜狐这些门户网站在内的大部分站点，用的都是绝对单位px（像素）。但是，如果从网站易用性方面考虑，字体大小应该是可变的，一些视力不是那么好的人需要放大字体才能看得清页面内容。然而，占据大部分浏览器市场的IE无法调整那些使用px作为单位的字体大小。国外人士非常重视网站的易用性，相当一部分外国站点已经使用em作为字体单位。】
3、这类布局的特点是，包裹文字的各元素的尺寸采用em/rem做单位，而页面的主要划分区域的尺寸仍使用百分数或px做单位（同「流式布局」或「静态/固定布局」）。早期浏览器不支持整个页面按比例缩放，仅支持网页内文字尺寸的放大，这种情况下。使用em/rem做单位，可以使包裹文字的元素随着文字的缩放而缩放。

>4、浏览器的默认字体高度一般为16px，即1em:16px，但是 1:16 的比例不方便计算，为了使单位em/rem更直观，CSS编写者常常将页面跟节点字体设为62.5%，比如选择用rem控制字体时，先需要设置根节点html的字体大小，因为浏览器默认字体大小16px*62.5%=10px。这样1rem便是10px，方便了计算。

Set body font-size to 62.5% for Easier em Conversion:
If you would like to use relative units (em) for your font sizes, declaring 62.5% for the font-size property of the body will make it easier to convert px to em. By doing it this way, converting to em is a matter of dividing the px value by 10 (e.g. 24px = 2.4em).
那么为什么一般多是 html{font-size:62.5%;} 而不是 html{font-size:10px;}呢？

>因为有些浏览器默认的不是16px，或者用户修改了浏览器默认的字体大小（因浏览器分辨率大小，视力，习惯等因素）。如果我们将其设置为10px，一定会影响在这些浏览器上的效果，所以最好用绝大多数用户默认的16作为基数 * 62.5% 得到我们需要的10px。
html {font-size: 62.5%;/*10 ÷ 16 × 100% = 62.5%*/}
body {font-size: 1.4rem;/*1.4 × 10px = 14px */}
h1 { font-size: 2.4rem;/*2.4 × 10px = 24px*/}
实际项目设置成 font-size: 62.5%可能会出现问题，因为chrome不支持小于12px的字体，计算小于12px的时候，会默认取12px去计算，导致chrome的em/rem计算不准确。

>针对这个现象，可以尝试设置html字体为100px，body 修正为16px，这样 0.1rem 就是 10px，而body的字体仍然是默认大小，不影响未设置大小的元素的默认字体的大小。

>5、用em/rem定义尺寸的另一个好处是更能适应缩进/以字体单位padding或margin／浏览器设置字体尺寸等情况（因为em/rem相对于字体大小，会同步改变）。例如：p{ text-indent: 2em; }

>6、使用rem单位的弹性布局在移动端也很受欢迎。
工具ViewtoREM：PX转换到REM（自动预处理）
rem的定义：font size of the root element，rem是相对于根元素<html>来设置字体大小的，这就意味着，我们只需要根据自己的需求在根元素确定一个参考值。
rem与em、px的区别：
px：像素，比较精确的单位，但不好做响应式布局
em：以父节点font-size大小为参考点，标准不统一，容易造成混乱
REM支持的浏览器：Mozilla Firefox 3.6+、Apple Safari 5+、Google Chrome、IE9+和Opera11+。IE6-8无法支持。

>对于不同尺寸的屏幕，可以统一假设屏幕宽度为640px后编写CSS（当然你也可以假定统一为320px）。此时，我们设定html元素的font-size为40px（同样，只是举例），然后各处（元素尺寸、文字大小）使用rem作为单位，随后搭配媒体查询或JS，根据屏幕的大小来动态控制html元素的font-size（特定屏幕尺寸下，html元素的font-size应当设置为何值，是使用这个方案时设计师和程序员需要反复考虑后确定的，以下试举一段相关的CSS媒体查询代码），即可自动改变所有用rem定义尺寸的元素的大小（且CSS编写者在脑中进行换算的计算过程比em简单得多）。
 View Code
其实在移动端使用所谓的弹性布局，是比较勉强的。移动端弹性布局流行起来的原因归根结底是rem单位对于（根据屏幕尺寸）调整页面的各元素的尺寸、文字大小时比较好用。其实，使用vw、vh等后起之秀的单位，可以实现完美的流式布局（高度和文字大小都可以变得“流式”），弹性布局就不再必要了。详细可参考：视区相关单位vw, vh..简介以及可实际应用场景

>以下优缺点参考：响应式设计和REM布局的对比（有疑问）

>优点：理想状态是所有屏幕的高宽比和最初的设计高宽比一样，或者相差不多，完美适应。

>缺点：这种rem+js只不过是宽度自适应，高度没有做到自适应，一些对高度，或者元素间距要求比较高的设计，则这种布局没有太大的意义。如果只是宽度自适应，更推荐响应式设计。

>响应式和弹性布局之间的对比：

>响应式布局：改变浏览器宽度，“布局”会随之变化，不是一成不变的，例如导航栏在大屏幕下是横排，在小屏幕下是竖排，在超小屏幕下隐藏为菜单，也就是说如果有足够的耐心，在每一种屏幕下都应该有合理的布局，完美的效果。

>rem布局：改变浏览器宽度，页面所有元素的高宽都等比例缩放，也就是大屏幕下导航是横的，小屏幕下还是横的只不过变小了。

>结论：

>1.如果只做pc端，那么静态布局（定宽度）是最好的选择；
>2.如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份css+一份js调节font-size搞定；
>3.如果pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局。

# 网站优化

## h1标签优化logo

1、网站的logo使用h1标签进行优化
> 1.通常，网站的logo是一张图片，使用div来进行包裹；
> 2.但是，为了加重logo的权重，使用h1标签来包裹，并添加隐藏的文字说明，以便搜索引擎能够识别；
```html
<div class="logo">
    <h1 class="logo-l fl"><a href="#">梅兰商贸</a></h1>
    <div class="logo-r fr"></div>
</div>
```
```
.fl {
    float: left;
}

.fr {
    float: right;
}

.logo {
    width: 970px;
    height: 90px;
    margin: 0 auto;
}
.logo-l {
    width: 135px;
    height: 45px;
    margin: 20px 0 0 20px;
}

.logo-l a {
    display: inline-block;
    width: 100%;
    height: 100%;
    background: url("../img/logo.png") no-repeat;
    /*首行缩进，隐藏文字*/
    text-indent: -9999em;
}

.logo-r {
    width: 530px;
    height: 42px;
}
```


# BootStrap

## bootstrap v4.0官网

1、HTML5文档类型
> 1.Bootstrap使用部分HTML元素和CSS属性，需要将页面设置为HTML5文档类型；
```
<!DOCTYPE html>
<html lang="en">
  ...
</html>
```

2、移动设备优先
> 1.确保适当的绘制和触屏缩放，需要在head中添加`viewport`元数据标签；
```
<meta name="viewport" content="width=device-width, initial-scale=1", shrink-to-fit=no">
```
> 2.在移动设备上，设置meta属性为`user-scalable=no`，禁止缩放功能，使得用户只能滚动屏幕查看页面。
```
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
```

3、排版与链接
> 1.bootstrap排版，链接设置了基本的全局样式。分别是
> 1. 为body元素设置了`background-color:#fff;`
> 2. 使用`@font-family-base`、`@font-size-base`和`@line-height-base`变量作为排版的基本参数；
> 3. 为所有的链接设置了基本颜色`@link-color`，并且当链接处于`:hover`状态下时才添加下划线；
> 4. 源码：scaffolding.less文件

4、布局容器
> 1.Bootstrap需要为页面内容和栅格系统包裹一个`.container`容器。提供了两个作此作用的类。但由于padding等属性的原因，不能嵌套使用。
> 1. `.container`类：用于固定宽度并支持响应式布局的容器；
```
<div class="container">
//......
</div>
```
> 2. `.container-fluid`类：用于100%宽度，占据全部视口（viewport）的容器；
```
<div class="container-fluid">
//........
</div>
```

5、盒模型
> 1.为了在CSS中更直观的设置尺寸，将全局的`box-sizing`设置为`border-box`。确保了padding值不会影响元素的最终宽度计算。但是，第三方组件可能会出问题，比如Google地图和Google定制搜索，需要设置`box-sizing:content-box;`
> 2.`::before,::after`也都设置为`box-sizing: border-box;`;
```
//bootstrap源码
*, ::after, ::before {
    box-sizing: border-box
}
```


1、Bootstrap栅格系统
> 1.定义：随着屏幕或视口(Viewport)尺寸的增加，系统会自动分为最多12列；它包含了易于使用的预定义类，还有强大的mixin用于生成更具语义的布局；
> 2.是一套响应式、移动设备优先的流式栅格系统；

2、栅格系统的布局及工作原理
> 1.通过一系列的行(row)和列(column)的组合来创建页面布局。
> 2.工作原理：
> 1. 行(row)必须包含在`.container`或`.container-fluid`中，以便为其赋予合适的排列(aligment)和内补(padding)；
> 2. 通过行(row)在水平方向上创建一组列(column)；
> 3. 我们的内容应该放在列(column)中，并且，只有列(column)可以作为行(row)的直接子元素；
```
<div class="container">
    <div class="row">
        <div class="col-lg-4"></div>
        <div class="col-lg-3"></div>
        <div class="col-lg-5"></div>
    </div>
</div>
```
> 4. 类似`.row`和`.col-lg-4`，这种预定义类，可以用来创建栅格布局；
> 5. 通过为列(column)设置`padding`属性，从而创建列与列之间的间隔；通过为行(row)设置负值`margin`。从而抵消`.container`元素设置的`padding`,也就间接为行所包含的列抵消掉了padding；但是，如果想去除`.row`的负margin值和`.column`的padding值，可以在`.row`上设置`.no-gutters`；
```html
<div class="container">
    <div class="row no-gutters">       //添加no-gutters类
        <div class="col-lg">Resize</div>
        <div class="col-lg">22222</div>
        <div class="col-lg"></div>
    </div>
</div>
```
> 6. 负值的margin就是下面的实例为什么是向外突出的原因。在栅格列中的内容排成一行；
> 7. 栅格系统中的列是通过指定1到12的值来表示其跨越的范围，例如，三个等宽的列可以用三个`.col-lg-4`来创建；
> 8. 如果一行中包含的列大于12个，多余的列所在元素会被作为一个整体另起一行排列；
> 9. 栅格适用于与屏幕宽度大于或等于分界点大小的设备，并且针对小屏幕设备覆盖栅格类，因此，在元素上应用任何`.col-md-`不存在，也影响大屏幕。
> 10. 因为采用flex布局，没有指定宽度的网格列会自动布局为等宽列。例如四个`.col-lg`，会将12列等分为4列布局，即每一个`.col-lg`占据3列宽
```html
<div class="container">
    <div class="row">
        <div class="col-lg">Resize</div>       //占据560px的一半(7列宽的一半 )
        <div class="col-lg-5">22222</div>      //占据400px(5列宽)
        <div class="col-lg"></div>             //占据560px的一半(7列宽的一半 )
    </div>
</div>
```
```html
<div class="container">
    <div class="row">
        <div class="col-lg">Resize</div>       //占据320px(12列宽的1/3)
        <div class="col-lg">22222</div>        //占据320px(12列宽的1/3)
        <div class="col-lg"></div>             //占据320px(12列宽的1/3)
    </div>
</div>
```

3、媒体查询
> 1.适用媒体查询(media query)来创建关键的分界点阈值；
```
@media (min-width: 576px) {
    .container {
        max-width: 540px
    }
}

@media (min-width: 768px) {
    .container {
        max-width: 720px
    }
}

@media (min-width: 992px) {
    .container {
        max-width: 960px
    }
}

@media (min-width: 1200px) {
    .container {
        max-width: 1140px
    }
}
```

4、栅格参数
||超超小屏幕(<576px)|超小屏幕(手机>=576px)|小屏幕(平板>=768px)|中等屏幕(桌面显示器>=992px)|大屏幕(大桌面显示器>=1200px)|
|---|---|---|---|---|---|
|栅格系统行为||总是水平排列|开始是堆叠在一起的，当大于这些阈值时，将变成水平排列|---|---|---|
|`.container`最大宽度|auto|540px|720px|960px|1140px|
|类前缀|`.col-`|`.col-sm-`|`.col-md-`|`.col-lg-`|`col-xl-`|
|列数(column)|12|12|12|12|12|
|最大列宽|自动|45px|59.99px|80px|95px|
|槽宽(gutter)|30px，每列左右有15px的padding|---|---|---|---|
|可嵌套|是|是|是|是|是|
|偏移(Offsets)|是|是|是|是|是|
|列排序|是|是|是|是|是|

5、可变宽度内容——列宽根据内容自适应(`.col-lg-auto`)
> 1.宽度根据内容来确定。
```html
<div class="container">
    <div class="row">
        <div class="col-lg-2">Resize</div>
        <div class="col-lg-auto">2222222222222222222222222222222</div>
        <div class="col-lg-2"></div>
    </div>
</div>
```

6、等宽多行
> 1.通过插入`.w-100`来表示换行；
```
<div class="container">
    <div class="row">
        <div class="col-lg">Resize</div>
        <div class="col-lg">2222222222222</div>
        <div class="w-100"></div>
        <div class="col-lg">333333</div>
        <div class="col-lg">44444</div>
    </div>
</div>
```

7、对齐
> 1.竖直对齐：
> 1. 一行在竖直方向上的对齐方式：在`.row`上添加`.align-items-start`表示竖直居上，`.align-items-center`表示竖直居中，`.align-items-end`表示竖直居下。
```html
<div class="container">
    <div class="row align-items-center">
        <div class="col-lg">Resize</div>
        <div class="col-lg">2222222222222</div>
    </div>
</div>
```
> 2. 一行中各列在竖直方向上的对齐方式：在每个列上添加`.align-self-start`表示竖直居上，`.align-self-center`表示竖直居中，`.align-self-end`表示竖直居下.
```html
<div class="container">
    <div class="row">
        <div class="col-lg  align-self-center">Resize</div>
        <div class="col-lg align-self-end">2222222222222</div>
    </div>
</div>
```
> 2.水平对齐：在`.row`添加类；
> 1. `.justify-content-start`：左对齐；
> 2. `.justify-content-center`：居中对齐；
> 3. `.justify-content-end`：右对齐；
> 4. `.justify-content-around`：头尾留间隔的一半，其他列均匀分布，间隔相等
> 5. `.justify-content-between`：头尾不留间隔，其他列均匀分布；

8、列重排序
> 1.通过给列添加`.order-lg-0`到`.order-lg-12`来进行排序；
> 2.`.order-lg-start`表示排第一个(order:-1;)
> 3.`.order-lg-last`：表示排最后一个(order:13;)
```html
<div class="container">
    <div class="row">
        <div class="col-lg order-lg-4">44</div>
        <div class="col-lg order-lg-first">first</div>
        <div class="col-lg order-lg-last">last</div>
        <div class="col-lg order-lg-0">00</div>
    </div>
</div>
```

9、列偏移
> 1.使用`.offset-lg-`类可以实现向右偏移，本质是为当前元素增加了左边距(margin)。例如：`.offset-lg-4`，表示向右偏移了4个列宽。
> 1. `.offset-lg-`类采用`margin-left: (数字)%;`的形式。
```html
<div class="container">
    <div class="row">
        <div class="col-md-4 offset-md-1">Resize your viewport or check it out on your phone for an example.</div>
        <div class="col-md-1">2222222222222222</div>
    </div>
</div>
```

10、列间距
> 1.通过`.ml-lg-`类设置margin-left值，使得列之间有间隔；
> 2.`.ml-lg-3`，这种具体数字，会有固定的间隔；
> 3.`.ml-lg-auto`，表示`margin-left:auto;`
> 4.`.mr-lg-`类的用法类似。
```html
<div class="container">
    <div class="row">
        <div class="col-lg-2 ml-lg-1">44</div>
        <div class="col-lg-2 ml-lg-auto">first</div>
        <div class="col-lg-2 ml-lg-auto">first</div>
    </div>
</div>
```

11、列嵌套
> 1.允许在一个列中再添加一个行；
```html
<div class="container">
    <div class="row">
        <div class="col-lg-2">level：1</div>
        <div class="col-lg-2">level：1</div>
        <div class="col-lg-8">
            <div class="row">
                <div class="col-lg-3">level：2</div>
                <div class="col-lg-3">level：2</div>
                <div class="col-lg-3">level：2</div>
            </div>
        </div>
    </div>
</div>
```


1、标题`<h1>-<h6>`
> 1.HTML中所有的标题标签`h1`-`h6`，均可以使用；
> 2.还提供了`.h1`-`.h6`类，可以赋予标题的字体样式；
```
<h1>hello</h1>
<h6>hello</h6>
<div class="h3">aaa</div>
<div class="h6">aaa</div>
```

2、自定义标题
> 1.使用`.text-muted`类，创建辅助标题文本；
```
<h1>hello<span class="text-muted">first</span></h1>
<h2>hello<small class="text-muted">second</small></h2>
```

3、


1、使用Bootstrap的优点：
> 1.为开发人员创建接口提供了一个简洁同一的解决方案；
> 2.包含功能强大的内置组件，易于定制；
> 3.提供了基于web的定制；
> 4.开源的；

2、Bootstrap包的内容
> 1.基本结构：提供了一个带有网格系统、链接样式、背景的基本结构。
> 2.CSS：全局的css设置、定义基本的HTML元素样式、可扩展的class、以及一个先进的网格系统。
> 3.组件：包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等。
> 4.JavaScript插件：包含了十几个自定义的jQuuery插件。
> 5.定制：定制Bootstrap的组件、LESS变量和jQuery插件来得到自己的版本。

# CSS

## 常见问题

1、行内块元素与块元素的水平居中
> 1.行内块元素，本质为行内元素，要设置居中，可以通过`text-align: center;`设置父元素来实现自己的居中。
```html
<div class="div">
    <a class="a" href="#">我要居中</a>
</div>
```
```
.div{
    width:300px;
    height:200px;
    text-align:center;        //实现子行内块元素居中
}
.a{
    display:inline-block;     //行内块元素
    width:120px;
    height:100px;
}
```
> 2.块元素，与行内元素不同，可以通过`margin:0 auto;`直接设置居中
```
<div class="div">
    <a class="a" href="#">我要居中</a>
</div>
```
```
.div{
    width:300px;
    height:200px;
}
.a{
    display:block;            //块元素
    width:120px;
    height:100px;
    margin:0 auto;           //直接设置margin值，实现居中
}
```

1、关于`margin`和`padding`的百分数形式的参照对象
> 1.margin的4个值得参考对象都是父元素的`width`;
> 2.padding的4个值得参考对象都是父元素的`width`;
```html
<div class="g-container">
    <div class="margin"></div>
</div>
```
```css
.g-container {
    height: 100px;
    width: 100px;
    background: #6f42c1;
    overflow: hidden;         //必须加上，否则子元素外边距与父元素外边距重合，会导致子元素的margin-top应用到父元素身上
}

.margin {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    margin-left: 50%;       //相对于父元素的宽，实际为50px
    margin-top: 20%;        //相对于父元素的宽，实际为20px
}
```
```css
.g-container {
    height: 100px;
    width: 100px;
    background: #6f42c1;
}

.padding {
    width: 40px;
    height: 50px;
    border: 1px solid red;
    padding-left: 50%;      //相对于父元素的宽，实际为50px
    padding-top: 20%;       //相对于父元素的宽，实际为20px
}
```

**注意点**
**1、父子元素必须都是块元素，才会发生这些现象；**
**2、如果父子元素中只有一个是块元素，不会发生这些现象，会正常显示；**


1、第一个子元素（块元素）margin-top值应用到父元素（块元素）中
> 1.原因：**外边距合并**；
> 1. 外边距合并，指的是，当两个垂直的外边距相遇时，会合并成一个外边距；
> 2. 合并后的外边距的高度等于两个发生合并的外边距中较高的；
> 3. 当一个元素出现在另一个元素上面时，第一个元素的下边距会和第二个元素的上边距合并；
> 4. 当一个元素包含另一个元素时(假如没有内边距或边框把外边距分隔开)，他们的上和/或下外边距也会发生合并。
```html
<div class="g-container">
    <div class="margin">11</div>
</div>
```
```css
.g-container {
    height: 100px;
    width: 100px;
    background: #6f42c1;
}

.margin {
    width: 40px;
    height: 50px;
    border: 1px solid red;
    margin-top: 10px;           //这个值会用到父元素中，所以父元素也会有10px的上外边距
}
```

2、解决方法
> 1.给父元素设置`border`属性；
> 2.给父元素设置`overflow: hidden;`，推荐使用；
> 3.给父元素设置内边距`padding`；
> 4.给父元素或子元素设置`float`；
> 5.给父元素或子元素设置`position:absolute;`；
```css
.g-container {
    height: 100px;
    width: 100px;
    background: #6f42c1;
    /*position: absolute;*/
    /*padding-top: 1px;*/
    /*float:left;*/
    /*border: 1px solid red;*/
    /*overflow: hidden;         //必须加上，否则子元素外边距与父元素外边距重合，会导致子元素的margin-top应用到父元素身上*/
}

.margin {
    width: 40px;
    height: 50px;
    border: 1px solid red;
    /*float:left;*/
    /*position: absolute;*/
    margin-top: 10px;
}
```

**为什么要清除浮动？**
**因为子元素浮动之后，会导致父元素的高度塌陷。**


1、父级div定义伪类：after和zoom
> 1.原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题;
> 2.优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）;
> 3.缺点：代码多，不少初学者不理解原理，要两句代码结合使用，才能让主流浏览器都支持;
> 4.建议：推荐使用，建议定义公共类，以减少CSS代码;
```html
<div class="float clear">
    <div class="fl"></div>
    <div class="fr"></div>
</div>
```
```css
.float {
    width: 500px;
    border: 1px solid red;
}

//主要代码，如果不清除浮动，父元素的高度为0
.clear {
    zoom: 1;
}

.clear:after {
    display: block;
    content: '';
    clear: both;
    visibility: hidden;
    height: 0;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

2、在结尾处添加空div标签clear:both
> 1.原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度;
> 2.优点：简单，代码少，浏览器支持好，不容易出现怪问题;
> 3.缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不爽;
> 4.建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法;
```html
<div class="float">
    <div class="fl"></div>
    <div class="fr"></div>
    <div class="clear"></div>
</div>
```
```css
.float {
    width: 500px;
    border: 1px solid red;
}

.clear {
    clear: both;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

3、父级div定义height
> 1.原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题;
> 2.优点：简单，代码少，容易掌握;
> 3.缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题;
> 4.建议：不推荐使用，只建议高度固定的布局时使用;
```html
<div class="float">
    <div class="fl"></div>
    <div class="fr"></div>
</div>
```
```css
.float {
    height:80px;            //关键代码
    width: 500px;
    border: 1px solid red;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

4、父级div定义overflow:hidden
> 1.原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度;
> 2.优点：简单，代码少，浏览器支持好;
> 3.缺点：不能和position配合使用，因为超出的尺寸的会被隐藏;
> 4.建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用;
```html
<div class="float">
    <div class="fl"></div>
    <div class="fr"></div>
</div>
```
```css
.float {
    width: 500px;
    border: 1px solid red;
    overflow: hidden;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

5、父级div定义overflow:auto
> 1.原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度;
> 2.优点：简单，代码少，浏览器支持好;
> 3.缺点：内部宽高超过父级div时，会出现滚动条。
> 4.建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。
```html
<div class="float">
    <div class="fl"></div>
    <div class="fr"></div>
</div>
```
```css
.float {
    width: 500px;
    border: 1px solid red;
    overflow: auto;
}

.fl {
    height: 50px;
    width: 100px;
    background: gray;
    float: left;
}

.fr {
    height: 50px;
    width: 100px;
    background: pink;
    float: right;
}
```

6、父级div也一起浮动
> 1.原理：所有代码一起浮动，就变成了一个整体;
> 2.优点：没有优点;
> 3.缺点：会产生新的浮动问题。
> 4.建议：不推荐使用，只作了解。

7、父级div定义display:table
> 1.原理：将div属性变成表格;
> 2.优点：没有优点
> 3.缺点：会产生新的未知问题;
> 4.建议：不推荐使用，只作了解;

8、结尾处加br标签clear:both
> 1.原理：父级div定义zoom:1来解决IE浮动问题，结尾处加br标签clear:both;
> 2.建议：不推荐使用，只作了解

参考链接：https://www.cnblogs.com/nxl0908/p/7245460.html

## CSS3

1、border制作倒三角
> 1.将宽和高都设置为0，四个边框都变成了三角形；
> 2.将左右和下边框颜色设置为透明或与背景颜色相同的颜色，推荐透明；
> **注：两种写法：**
```
border-width:3px;
border-style:solid dashed dashed;
border-color:#333 transparent transparent;
```
```
border: 3px dashed transparent;
border-top: solid #333;
```
```html
<div class="test">
    <ul>
        <li><a href="#">建材网首页</a></li>
        <li><a href="#">我的商务室<i></i></a></li>
        <li><a href="#">我的收藏<i></i></a></li>
        <li><a href="#">建材服务<i></i></a></li>
        <li><a href="#">客服中心</a></li>
        <li><a href="#">网站导航<i></i></a></li>
    </ul>
</div>
```
```css
.test {
    height: 20px;
    border: 1px solid red;
}

.test ul li {
    float: left;
    padding-right: 10px;
    line-height: 20px;
}

.test ul li a i {
    height: 0;
    width: 0;
    /*制作倒三角*/
    border: 3px solid transparent;
    border-top: 3px solid #333;
    /*border-top-color: #333;*/
    /* 行内块元素*/
    display: inline-block;
}
```

制作倒三角详解：https://blog.csdn.net/hl_java/article/details/70148328

2、伪元素制作倒三角（before和after用法相同）
```css
span:before {
    content: "";
    border: 5px solid transparent;
    border-top-color: red;
    display: inline-block;               //一定要设置，才能调整位置
    margin-bottom:-2px;
    margin-left: 10px;
}
```
```html
<span>00</span>
```


1、div中的img标签水平数值居中的方法：
```html
<div class="div">
    <img src="img/test.jpg"/>
</div>
```
> 1.方法一:将display设置成table-cell，然后水平居中设置text-align为center，垂直居中设置vertical-align为middle
```css
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    display: table-cell;
    vertical-align: middle;
    text-align: center;
}

.div img {
    max-width: 80px;
    max-height: 80px;
}
```
> 2.方法二：弹性布局flex
```css
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    display: flex;
    justify-content: center;
    align-items: center;
}

.div img {
    max-width: 80px;
    max-height: 80px;
}
```
> 3.方法三：通过position定位实现(图片的宽和高的固定)
> **注意：有一个缺点，只有图片的尺寸固定的，才可以实现居中，因为需要设置margin值**
```CSS
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    position: relative;
}

.div img {
    /*图片的宽和高的固定*/
    width: 80px;
    height: 80px;
    position: absolute;
    top: 50%;
    left: 50%;
    /*宽和高的一般*/
    margin-top: -40px;
    margin-left: -40px;
}
```
> 3.方法四：通过position定位实现，解决了方法三中的缺陷(图片的宽和高不固定)
```css
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    position: relative;
}

.div img {
    max-width: 80px;
    max-height: 80px;
    position: absolute;
    top: 50%;
    left: 50%;
    /*宽和高的一般*/
    transform: translate(-50%,-50%);
}
```
> 5.方法五：通过position定位实现，利用margin:auto;
```css
.div {
    width: 100px;
    height: 100px;
    /*关键代码*/
    position: relative;
}

.div img {
    max-width: 80px;
    max-height: 80px;
    /*关键代码*/
    position: absolute;
    top: 0;
    bottom: 0;
    right: 0;
    left: 0;
    margin: auto;
}
```

1、给div添加滚动条
> 1.方法一：
> 1. 宽和高一定要设置。
```
<div style=" overflow:scroll; width:400px; height:400px;”></div>
```
> 2.方法二：
> 1. 宽和高一定要设置。
> 2. 垂直滚动条为： overflow-y:auto；
> 3. 水平滚动条为： overflow-x:auto
```
<div style=" overflow-y:auto; overflow-x:auto; width:400px; height:400px;”></div>
```
```
<div style="height:400px; overflow:auto"></div>
```

2、修改默认的滚动条样式
> 1.如果是指定的某个class的样式，在前面天上class名即可。
> 2.下面的方法默认修改所有的滚动条；
```
/*滚动条样式*/
::-webkit-scrollbar { /*滚动条整体样式*/
    width: 4px; /*高宽分别对应横竖滚动条的尺寸*/
    height: 4px;
    scrollbar-track-color: #FFFFFF; /*滚动条底色*/
    /*滚动条隐藏*/
    display: none;
}

::-webkit-scrollbar-thumb { /*滚动条里面小方块*/
    border-radius: 5px;
    -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
    background: rgba(0, 0, 0, 0.2);
}

::-webkit-scrollbar-track { /*滚动条里面轨道*/
    -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
    border-radius: 0;
}
```

> 3.滚动条隐藏
> 1.利用 css3的新特性  -webkit-scrollbar, 但是这种方式不兼容火狐和IE
```
::-webkit-scrollbar {
    /*滚动条隐藏*/
    display: none;
}
```

1、CSS3模块有哪些？
> 1.选择器；
> 2.盒模型；
> 3.背景和边框；
> 4.文字特效；
> 5.2D/3D转换；
> 6.动画；
> 7.多列布局；
> 8.用户界面；

2、CSS3的边框有哪些属性
> 1.`border-radius`：创建圆角；
> 2.`border-shadow`：添加阴影；
> 3.`border-image`：用图片来创建边框；

3、圆角属性
> 1.基本语法：`border-radius: 1-4 length|% / 1-4 length|%;`
> 2.参数意义：
> 1. 1-4指的是radius的四个值，length和%指的是值的单位;
> 2. 第一个参数表示圆角的水平半径，第二个参数表示圆角的垂直半径；
```
//左右不对称的圆角（4个角的水平半径是2em，垂直半径是1em）
.div{border-radius: 2em/1em}
```
> 3.参数顺序：左上，右上，右下，左下；
> 4.完整的参数有8个：
```
//
div{border-radius: 100px 60px 40px 10px /20px 40px 60px 80px;}
```
```
div{
    border:2px solid;
    border-radius:25px;
    width:250px;
}

<div>border-radius 属性允许您为元素添加圆角边框！</div>
```

4、盒阴影
> 1.语法：`box-shadow: inset x-offset y-offset blur-radius spread-radius color`
> 2.参数含义：
> 1. inset：可选。阴影类型，默认为外阴影；取值为"inset"，变成内阴影；
> 2. x-offset：可正可负。阴影水平偏移量，正值：阴影在对象的右边；负值：阴影在对象的左边；
> 3. y-offset：可正可负。阴影垂直偏移量，正值：阴影在对象的底部；负值：阴影在对象的顶部；
> 4. blur-radius：可选。阴影模糊半径，只能为正。为0：阴影不具有模糊效果；
> 5. spread-radius：可选。阴影扩展半径，可正可负，正值：整个阴影都延展扩大；反之缩小；
> 6. color：可选。不设颜色，会根据浏览器取默认色。
```
.shadows{
    box-shadow: 10px 10px 5px #888888;
    height:30px;
    width:250px;
    margin:20px 0;
}

<div class="shadows"></div>
```

5、边界图片
> 1.语法：
`border-image: url top right bottom left x-repeat y-repeat：`
> 2.参数含义：
> 1. url：图片的路径；
> 2. top right bottom left：定义border-image的显示区域的，不用单位；
> 3. x-repeat y-repeat：表示图片的变换样式，包括三个值 stretch拉伸 repeat重复  round平铺；
```
.images1{
    border-image:url(border.png) 10 10 round;
    -webkit-border-image:url(border.png) 10 10 round; /* Safari 5 and older */
    -o-border-image:url(border.png) 10 10 round; /* Opera */
}

<div class="images1">这里，图像平铺（重复）来填充该区域。</div>
```

6、CSS3背景的新属性
> 1.background-image：添加背景图片；
> 2.background-size：指定背景图像的大小；
> 3.background-origin：指定背景图像的位置区域；
> 4.background-clip：背景裁剪属性，从指定位置开始绘制；

7、background-image添加背景图片
> 1.语法：
```
.back{
    width:300px;
    height: 300px;
    //下面两种写法可达到同样的效果
    background:url(border.png) left 100px top 100px no-repeat;
    /*background-image:url(border.png);*/
    /*background-position: left 100px top 100px;*/
    /*background-repeat: repeat;*/
}
<div class="back">背景图片</div>
```
> 2.添加多个背景图片时，用逗号隔开；
```
background: url(img_flwr.png) right bottom no-repeat, url(paper.png) left top repeat;
```

8、background-size指定背景图像的大小
```
//指定固定的像素或者百分比大小（相对父元素而言）
background-size: 100% 100%;
```

9、background-Origin指定背景图像的位置区域
> 1.padding-box(padding):此值为background-origin的默认值，决定background-position起始位置从padding的外边缘（border的内边缘）开始显示背景图片；
> 2.border-box(border):此值决定background-position起始位置从border的外边缘开始显示背景图片；
> 3.content-box(content):此值决定background-position起始位置从content的外边缘（padding的内边缘）开始显示背景图片；

10、background-clip从指定位置开始绘制
> 1.将背景图片以border的尺寸、以padding的尺寸，以content的尺寸进行切割，其得到的结果是不完整的背景;
```
background-clip:content-box;
```

11、CSS3渐变（gradients）是什么
> 1.定义：让你在两个或多个指定的颜色之间显示平稳的过渡；
> 2.种类：线性渐变(Linear Gradients)和径向渐变(Radial Gradients)；

12、线性渐变(Linear Gradients)
> 1.基本语法：
```
background: linear-gradient(direction, color-stop1, color-stop2, ...);
```
> 2.参数direction(预定义方向)：向下(默认)/向上(to top)/向左(to left)/向右(to right)/对角方向(to bottom right等)；
> 3.使用自定义方向(使用角度)
> 1. 语法：
```
background: linear-gradient(angle, color-stop1, color-stop2,...);
```
> 2. 角度：指水平线和渐近线之间的角度，逆时针方向计算；一般以12点钟为0deg。
> **注意：在旧的标准中，要进行换算90-x=y，其中x为标准角度，y为非标准角度(在旧标准中，把3点钟方向作为0deg)**
> 4.使用透明度(transparent)
> 1. 作用：创建减弱变淡效果；
> 2. 使用rgba()函数定义颜色结点：rgba最后一个参数定义了透明度(0表示完全透明，1表示完全不透明)；
```
background: linear-gradient(to bottom,rgba(255,0,0,0),rgba(255,0,0,1));
```
> 5.重复的线性渐变
> 1. 使用repeating-linear-gradient()函数
```
background: repeating-linear-gradient(red,yellow 10%,blue 20%);
```

13、径向渐变(Radial Gradients)
> 1.基本语法：定义渐变的中心，形状(圆形或椭圆形)，大小。
```
background: radial-gradient([ [ <shape> || <size> ] [ at <position> ]? , | at <position>, ]?<color-stop>[ , <color-stop> ]+);
```
> 2.颜色结点均匀分布(默认情况)
```
background:radial-gradient(red,blue);
```
> 3.颜色结点不均匀分布
```
background:radial-gradient(red 10%,blue 20%);
```
> 4.设置参数渐变中心点[position]
> 1. 语法：at x轴 y轴（数值或百分比）
```
background:radial-gradient(circle at 10% 20%, red, blue, yellow);
background:radial-gradient(circle at 100px 20px, red, blue, yellow);
```
> 2. 单个值，默认为center(left,right,top,center,bottom)
```
background:radial-gradient(circle at right, red, blue, yellow);
```
> 5.设置参数渐变形状[shape]，默认为ellipse(椭圆形)，circle(圆形)；
> 6.设置参数渐变的大小[size]，默认为farthest-corner
> 1. closest-side：半径为从圆心到最近边；
> 2. closest-corner：半径为从圆心到最近角；
> 3. farthest-side：半径为从圆心到最远边；
> 4. farthest-corner：半径为从圆心到最远角；
> 5. 自定义固定的长度(px)；
```
background:radial-gradient(closest-corner at center, red, blue, yellow);
background:radial-gradient(circle 60px at center, red, blue, yellow);
```
> 7.重复的径向渐变
> 1. 使用函数repeating-radial-gradient();
```
background:repeating-radial-gradient(circle 20px at center, red, blue, yellow)
```

14、CSS3文本效果有哪些
> 1.text-shadow：文本阴影；
> 2.box-shadow：盒子阴影；
> 3.text-overflow：显示溢出内容的方式
> 4.word-wrap：换行；
> 5.word-break：单词拆分换行；

15、text-shadow文本阴影
> 1.语法： text-shadow: X轴  Y轴  Rpx  color;
> 2.参数说明：阴影的x轴，阴影的y轴，阴影模糊值(大小)，阴影的颜色；
```
text-shadow:5px 5px 5px #f00;
```

16、box-shadow盒子阴影
> 1.语法： box-shadow: X轴  Y轴  Rpx  color inset(内阴影);
```
.box-img{
    font-size:12px;
    text-align:center;
    margin: 30px;
    width:100px;
    box-shadow:0 4px 8px rgba(0,0,0,0.2),0 6px 20px rgba(0,0,0,0.19);
}
//卡片效果
<div class="box-img">
    <img src="box-img.jpg" height="100" width="100"/>
    <p>Hello World!</p>
</div>
```

17、text-overflow显示溢出内容
> 1.有两个值：clip(默认值，不显示省略标记...，而是简单裁剪)和ellipsis(当文本溢出时显示省略标记...)；
> 2.注意点：
> 1. 少了`overflow:hidden`，文字会横向撑到容器外面；
> 2. 少了`white-space:nowrap`，文字会纵向撑高；
```
.overflow{
    font-size: 12px;
    width:150px;
    border:1px solid #f00;
    overflow: hidden;
    white-space: nowrap;
    text-overflow:ellipsis;
}

//三个属性必须一起使用
<div class="overflow">容器内的文本无法完全显示，可以看到它被裁剪了</div>
```

18、word-wrap换行
> 1.长文本换行；
```
word-wrap: normal;  //默认值
```

19、word-break单词拆分换行
> 1.两个值：keep-all和break-all;

20、CSS3字体@font-face
> 1.只需要将字体文件包含在网站中，会自动的下载给用户使用；
```
@font-face {
    font-family: myfont;
    src:url('Sansation_Light.ttf');
}
//使用
div{
  font-family: myfont;
}
```

21、CSS3 2D转换方法
> 1.translate()：平移；
> 2.rotate()：旋转；
> 3.scale()：缩放；
> 4.skew()：

22、translate()方法
> 1.语法:transform:translate(x,y);
> 2.根据给定的x轴和y轴参数，平移到指定的位置（原位置的空间会一直占据）；
```
.two{
    height:100px;
    width:100px;
    background-color:#f00;
    -webkit-transform: translate(100px,100px); //适用于chorme
}

<div class="two"></div>
```
> 3.translateX(n):沿着x轴移动元素；
> 4.translateY(n):沿着y轴移动元素；

23、rotate()方法
> 1.语法：transform:rotate(deg);
> 2.根据给定的度数顺时针旋转的元素。负值表示逆时针旋转；
```
<div class="two2"></div>
.two2{
    height:100px;
    width:100px;
    background-color:#f00;
    -webkit-transform:rotate(30deg); //适用于chorme
}
```

24、scale()方法
> 1.语法：transform:scale(x,y);
> 2.横坐标的宽度放大x倍，纵坐标的高度放大y倍；
```
.two3{
    height:100px;
    width:100px;
    background-color:#f00;
    transform:scale(0.2,0.3);
}
<div class="two3"></div>
```

25、skew()方法
> 1.语法：transform:skew(<angle> [,<angle>]);
> 2.分别表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0；
> 3.参数为负，表示想相反的方向倾斜；
> 4.skewX(<angle>):表示只在x轴（水平方向）倾斜；
> 5.skewY(<angle>):表示只在y轴（垂直方向）倾斜；
```
.two4{
    height:100px;
    width:100px;
    background-color:#f00;
    transform:skew(20deg,30deg);
}
<div class="two4"></div>
```

26、matrix()方法
> 1.由六个参数，包含旋转，缩放，移动和倾斜功能；
> 2.这六个参数对应矩阵：matrix(a,b,c,d,e,f);
```
a c e
b d f
0 0 1
```
> 3.平移
```
translate(x,y);
matrix(1,0,0,1,x,y);
```
> 4.缩放
```
scale(x,y);
matrix(x,0,0,y,0,0);
```
> 5.旋转
```
rotate(x);
matrix(cosx,-sinx,sinx,cosx,0,0);
```
> 6.变形
```
skew(x,y);
matrix(1,tany,tanx,1,0,0);
```

27、CSS3过渡
> 1.添加某种效果可以从一种样式转变到另一个样式（无需使用flash和javascript）；
> 2.实现方法：
> 1. 指定要添加效果的CSS属性；
> 2. 指定效果的持续时间；
```
.transition1{
    width: 100px;
    height: 100px;;
    background-color: #12aa33;
    transition:width 2s,height 2s,transform 2s,font-size 2s;
}
.transition1:hover{         //鼠标移上去的效果
    font-size:30px;
    width:130px;
    height:130px;
    transform:rotate(360deg);
}
<div class="transition1">CSS3过渡</div>
```
```
div{
   transition: width 2s;
   -moz-transition: width 2s;	    /* Firefox 4 */
   -webkit-transition: width 2s;	/* Safari 和 Chrome */
   -o-transition: width 2s;     	/* Opera */
}
```

28、CSS3动画
> 1.动画使元素从一种样式逐渐变化为另一种样式的效果；
> 2.使用百分比来规定变化发生的时间，或用关键词"from"和"to"，等同于0%和100%；
> 3.0%是动画的开始，100%是动画的完成；
> 4.使用方法：
> 1. 规定动画的名称；
> 2. 规定动画的时长；
```
//动画改变颜色
.animation{
    width: 100px;
    height: 100px;
    background-color:#f00;
    animation:myFirst 5s;
}
@keyframes myFirst{
    from {background-color:#0ff;}
    to {background-color:#0f0;}
}
<div class="animation"></div>

//动画无限循环
.animation1{
    height:100px;
    width: 100px;
    background-color:#f0f;
    position:relative;
    animation:mySecond 5s infinite;
}
@keyframes mySecond{
    0%{left:0;top:0;}
    25%{transform:rotate(20deg);left:0;}
    50%{transform:rotate(0deg);left:500px;}
    75%{transform:rotate(0deg);left:500px; background-color:#0f0;}
    100%{transform:rotate(-360deg);left:0;}
}
<div class="animation1"></div>
```

29、CSS3动画属性animation
> 1.语法：animation:[<animation-name> || <animation-duration> || <animation-timing-function> || <animation-delay> || <animation-iteration-count> || <animation-direction> || <animation-fill-mode>]
> 2.animation-name：要绑定到选择器的关键帧的名称(动画的名称)；
> 3.animation-duration：指一个动画周期持续的时间，单位秒s或毫秒ms；
> 4.animation-timing-function：定义动画的速度曲线；
> 1. ease:动画以低速开始，然后加快，在结束前变慢；
> 2. linear:匀速；
> 3. ease-in:动画以低速开始；
> 4. ease-out:动画以低速结束；
> 5. ease-in-out:动画以低速开始和结束，相对ease缓慢，速度更均匀；
> 6. step-start:按keyframes设置逐帧显示，第一帧为keyframes设置的第一帧；
> 7. step-end:按keyframes设置逐帧显示，第一帧为样式的初始值；
> 8. steps(<number>,[start|end]):把keyframes里设置的一帧等分为几帧，start表示第一次显示第一帧，end表示第一次显示样式的初始值；例如：steps(4,start);
> 9. cubic-bezier(<number>,<number>,<number>,<number>):在cubic-bezier函数中自己的值。可能的值是从0到1。贝兹曲线限制了首尾两控制点的位置，通过调整中间两控制点的位置可以灵活得到常用的动画效果。
```
贝塞尔曲线：http://cubic-bezier.com/#.17,.67,.83,.67
```
> 5.animation-delay：指动画延时执行时间，单位秒s或毫秒ms；
> 6.animation-iteration-count：动画迭代次数，默认1次，可以设置10次，。。。infinite表示无限；
> 7.animation-direction：指动画时间轴上帧前进的方向；
> 1. normal:默认值，表示一直向前，最后一帧结束后回到第一帧；
> 2. reverse:与normal的运行方向相反；
> 3. alternate:往前播放完了之后，然后在倒带，倒带到头了再往后播放；
> 4. alternate-reverse:与alternate的运行方向相反；
```
.animation1{
    height:100px;
    width: 100px;
    background-color:#f0f;
    position:relative;
    animation:mySecond 5s cubic-bezier(0,.69,1,.17) alternate infinite;
}
@keyframes mySecond{
    0%{left:0;}
    100%{left:500px;}
  }
<div class="animation1"></div>
```
> 8.animation-fill-mode>：设置动画结束后的状态；
> 1. none:默认值。不设置对象动画之外的状态，DOM未进行动画前状态；
> 2. forwards:设置对象状态为动画结束时的状态，100%或to时，当设置animation-direction为reverse时，动画结束后显示keyframes第一帧；
> 3. backwards:设置对象状态为动画开始时的状态，（测试显示DOM未进行动画前状态）；
> 4. both:设置对象状态为动画结束或开始的状态，结束时状态优先；

30、CSS3多列属性
> 1.column-count:指定了需要分割的列数；
> 2.column-gap:指定了列与列间的间隙；
> 3.column-rule:指定了列与列间的边框；
> 1. column-rule-style:指定了列与列间的边框样式；
> 2. column-rule-width:指定了列的边框厚度；
> 3. column-rule-color:指定了列的边框颜色；
```
column-rule:1px solid #f00;
//两种写法效果相同
column-rule-style:solid;
column-rule-width:1px;
column-rule-color:#f00;
```
> 4.column-span:指定元素跨多少列；
```
div{
    border:1px solid #00f;
    width:500px;
    column-gap:40px;
    column-rule:1px solid #f00;
    column-width:50px;
}
h2{
    column-span:all;
    text-align:center;
}
<div>
    <h2>多列</h2>
    “当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。”
</div>
```
> 5.column-width:指定列的宽度；
> 6.columns:设置column-width和column-count的简写（用来设置列数）；
> 1. 语法：columns: column-width column-count;
```
columns:50px;
column-width:50px;   //作用等价
```

31、CSS3弹性盒模型
> 1.组成：弹性容器和弹性子元素组成；
> 2.设置方法：将容器的display属性设置为flex或inline-flex；
```
.flex-container{
    display:flex;
    width:300px;
    height:200px;
    background-color:#0ff;
}
.flex{
    width:100px;
    height:100px;
    background-color:#ff0;
    margin:10px;
}
<div class="flex-container">     //弹性盒模型
    <div class="flex flex-first">flex-first</div>
    <div class="flex flex-second">flex-second</div>
    <div class="flex flex-third">flex-third</div>
</div>
```

32、弹性盒模型的属性
> 1.flex-direction:指定了弹性子元素在父容器中的位置；
> 1. row:横向从左到右排列(左对齐)，默认的排列方式；
> 2. row-reverse:反向横向排列(右对齐，从后往前排，最后一项排在最前面)；
> 3. column:纵向排列；
> 4. column-reverse:反向纵向排列，从后往前排，最后一项排在最上面；
> 5. 语法：flex-direction:row|row-reverse|column|column-reverse;
```
.flex-container{
    display:flex;
    width:400px;
    height:300px;
    background-color:#0ff;
    flex-direction:row;
}
```
> 2.justify-content:横向内容对齐；
> 1. flex-start:弹性项目向行头紧挨着填充；
> 2. flex-end:弹性项目向行尾紧挨着填充；
> 3. center:弹性项目居中紧挨着填充；
> 4. space-betwwen:弹性项目平均分布在该行上，两端开始填充；
> 5. space-around:弹性项目平均分布在该行上，两端留有一半的间隔空间；
```
.flex-container{
    display:flex;
    width:400px;
    height:300px;
    background-color:#0ff;
    justify-content:flex-end;
}
```
> 3.align-items:设置或检索弹性盒子元素在侧轴(纵轴)上的对齐方式；
> 1. flex-start:侧轴起始位置的边界紧靠住该行的侧轴起始边界；
> 2. flex-end:侧轴起始位置紧靠住该行的侧轴结束边界；
> 3. center:在纵轴上居中放置；
> 4. baseline:如弹性盒子元素的行内周与侧轴为同一条，则该值与"flex-start"等效。否则，该值将于基线对齐；
> 5. stretch:如果指定侧轴大小的属性值为"auto"，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸；
```
.flex-container{
    display:flex;
    width:400px;
    height:400px;
    background-color:#0ff;
    flex-direction:column;
    align-items: stretch;
}
.flex{
    width:auto;
    height:100px;
    background-color:#ff0;
    margin:10px;
}
```
> 4.flex-wrap:指定了弹性盒子的子元素换行方式；
> 1. nowrap:默认。弹性容器为单行；这种情况下，弹性盒子想可能会移除容器；
> 2. wrap:弹性容器为多行，溢出的部分会被放置到新行，子项内部会发生断行；
> 3. wrap-reverse:反转wrap排列；
> 5.align-content:用于修改flex-wrap属性的行为，设置各行的对齐；
> 1. stretch:默认。各行会伸展以占用剩余的空间；
> 2. flex-start:各行向弹性盒容器的起始位置堆叠；
> 3. flex-end:各行向弹性盒容器的结束位置堆叠；
> 4. center:各行向弹性盒容器的中间位置堆叠；
> 5. space-between:各行在弹性盒容器中平均分布；
> 6. space-around:各行在弹性容器中平均分布，两端保留子元素之间间距大小的一半；

33、弹性子元素属性
> 1.order:<integer>:用整数来定义排序顺序，数值小的排在前面(可以为负值)；
> 2.align-self:设置弹性元素自身在侧轴(纵轴)方向上的对齐方式；
```
auto/flex-start/flex-end/center/baseline/stretch
```
> 3.flex:指定弹性子元素如何分配空间；
> 1. auto: 计算值为 1 1 auto
> 2. initial: 计算值为 0 1 auto
> 3. none：计算值为 0 0 auto
> 4. inherit：从父元素继承
> 5. [ flex-grow ]：定义弹性盒子元素的扩展比率。
> 6. [ flex-shrink ]：定义弹性盒子元素的收缩比率。
> 7. [ flex-basis ]：定义弹性盒子元素的默认基准值。

34、多媒体查询
> 1.语法：
```
@media not|only mediatype and (expressions){
          //css代码
}
```
> 2.not: not是用来排除掉某些特定的设备的，比如 `@media not print`（非打印设备）；
> 3.only: 用来定某种特别的媒体类型。对于支持Media Queries的移动设备来说，如果存在only关键字，移动设备的Web浏览器会忽略only关键字并直接根据后面的表达式应用样式文件。对于不支持Media Queries的设备但能够读取Media Type类型的Web浏览器，遇到only关键字时会忽略这个样式文件；
> 4.all: 所有设备，这个应该经常看到。
> 5.css3多媒体类型：

|值|描述|
|---|---|
|all|所有多媒体类型设备|
|print|打印机|
|screen|电脑屏幕，平板，智能手机等|
|speech|屏幕阅读器|

```
@media screen and (min-width:480px) and (max-width:700px){
  body{font-size:14px;}
}
```

35、box-sizing属性
> 1.作用：允许以特定的方式定义匹配某个区域的特定元素；
> 2.语法：`box-sizing:content-box|border-box|inherit`
> 3.默认值为：content-box，宽高分别应用到元素的内容框，在宽高之外绘制元素的边框和内边距；
> 4.border-box：为元素设定的宽高决定了元素的边框盒。就是为元素指定的任何内边距和边框都在已设定的宽高之内绘制，通过已设定的宽高分别减去边框和内边距得到内容的宽高。
> 5.inherit：继承父元素的box-sizing值。
```
box-sizing: border-box;
-o-box-sizing: border-box;        //opera
-moz-box-sizing: border-box;      //firefox
-webkit-box-sizing: border-box;   //chrome和safari
```


1、CSS与HTML的作用
> 1.HTML是做数据的显示；
> 2.CSS是对页面进行修饰；

2、CSS引用的方法
> 1.内嵌在html标签中，通过`style`属性来设置
```
  <h2 style="color:blue;text-decoration:underline;font-size:14px">我的第一个CSS</h2>
```
> 2.在head标签中，通过`style`标签来定义
```
<head>
  <style type="text/css">
  h2{
    background: green;
  }
  </style>
</head>
```
> 3.引用外部css文件
```
<head>
  <link rel="stylesheet" type="text/css" href="01.css"/>
</head>
```

3、css样式的作用范围
> 1.CSS样式是按顺序，从上到下进行加载的；
> 2.不同的引入方法，都遵循这个规则。

4、css选择器
> 1.标签选择器（元素选择器）：对页面中的所有标签都有用；
```css
h2{
  background: green;     //页面中的所有的<h2>标签都会有效
}
```
> 2.id选择器，用"#"标记：对指定的标签进行修饰；
```css
p#p1{               //表示<p>标签的id="p1"
  color: yellow;
}
```
> 3.类选择器，用"."标记：对一组标签进行修饰；
```css
p.p2{               //表示<p>标签的class="p2"
  color: yellow;
}
```
> 4.属性选择器，根据元素的属性及属性值来选择元素。
> 1. 简单属性选择：选择某个属性的元素，不管属性值为什么；
```css
*[title] {                //包含title属性的所有元素，字体颜色变红
    color: red;
}

a[href] {                 //针对href属性的a元素，字体变蓝
    color: blue;
}
a[href][title] {          //同时有href和title属性的a元素，字体变黄
    color: yellow;
}
```
> 2. 特定属性值选择：只选择有特定属性值的元素（属性与属性值必须完全匹配，特别是空格分隔符）；
```css
a[href="#"][title="test"] {  //同时有href="#"和title="test"的a元素，字体变黄
    color: yellow;
}
li[class="test"] {          //这个与html中的不匹配，无效
     color: gray;
 }
li[class="test test1"] {    //这个与html中的完全匹配，有效
    color: gray;
}
```
```html
<li class="test test1">工艺美术</li>
```
> 3. 部分属性值选择：针对属性值中的某个词进行选择，使用`~`符号；
```html
<li class="test test1">工艺美术</li>
```
```css
li[class~="test"] {          //匹配属性值中的部分词
     color: orange;
 }
```
> 4. 子串匹配属性选择器

|选择器|描述|
|---|---|
|[abc^="def"]|选择abc属性，属性值以"def"开头的所有元素|
|[abc$="def"]|选择abc属性，属性值以"def"结尾的所有元素|
|[abc*="def"]|选择abc属性，属性值包含"def"子串的所有元素|
```html
<li class="test test1">工艺美术</li>
```
```css
li[class^="t"] {        //class属性值以"t"开头的所有li元素，字体变红
    color: red;
}
li[class$="1"] {        //class属性值以"1"结尾的所有li元素，字体变黄
    color: yellow;
}
li[class*="es"] {       //class属性值包含"es"子串的所有li元素，字体变蓝
    color: blue;
}
```
> 5. 特定属性选择器：选择属性值等于或以这个开头的所有元素，一般用于匹配语言值；
```html
<p lang="en">Hello!</p>            <!--英国-->
<p lang="en-us">Greetings!</p>     <!--英国-美国-->
<p lang="en-au">G'day!</p>         <!--英国-澳洲-->
```
```css
*[lang|=zh] {              //lang属性值为"en"或者以"en-"开头的所有元素，字体变红
    color: red;
}
```
> 5.包含选择器（后代选择器）：用" "标记：对一个大标签中的 **所有** 指定的标签(包括子标签中的)进行修饰；
> 1. 这里定义的样式，会在最后加载(优先级最低)；
```
div span{
  color: red;
}
//在<h3>标签中的<span>标签，也会被修饰
<div>
    我的第一个CSS我的第一<span>个CSS我的第一</span>个CSS我的第一<h3>个CS<span>S我的</span>第</h3>一个CSS我的第一个CSS我的第一<span>个CSS我的第一个CSS我的第</span>一个CSS，我的第一个CSS我的第一个CSS我的第一个CSS我的第一个CSS我的第一个CSS.
</div>
```
> 6.子对象选择器：用">"标记：只针对第一级标签进行修饰；
```
div>span{
  color: purple;
}
//只针对"个CSS我的第一"应用样式，在<h3>标签中的<span>标签不会应用
<div>
    <h3>我的<span>第一<span>个CS<h3>S我的第一<span>个CSS我的第一</span>个CSS
</div>
```
> 7.相邻兄弟选择器：选择紧接在一个元素后的元素，且二者有相同的父元素，用`+`符号；
```html
<h1>This is a heading.</h1>
<p>This is paragraph.</p>
<p>This is paragraph.</p>
```
```
h1 + p {              //表示h1元素后的第一个p元素，字体变红
    color: red;
}
```
> 8.伪类选择器：向某些元素添加特殊的效果；

|属性|描述|
|---|---|
|:active|向被激活的元素添加样式|
|:focus|向拥有键盘输入焦点的元素添加样式|
|:hover|当鼠标悬浮在元素上方时，向元素添加样式|
|:link|向未被访问的链接添加样式|
|:visited|向已被访问的链接添加样式|
|:first-child|向元素的第一个子元素添加样式，该元素的位置必须是第一个|
|:lang|向带有指定lang属性的元素添加样式|
```html
<body>
<p><i>test0</i>,00,<i>test00</i></p>    
<p><i>test1</i>,11,<i>test11</i></p>
</body>
```
```css
p:first-child{         //第一个p元素变红，是body的第一个子元素
    color: red;
}
```
> 1. first-child：表示是父元素的所有子元素中的第一个位置上的元素添加样式；
```html
<body>
<i>iiii00</i>                           <!--iiii00变红，i是body的第一个子元素-->
<p><i>test0</i>,00,<i>test00</i></p>    <!--test0变红，i是p的第一个子元素-->
<p><i>test1</i>,11,<i>test11</i></p>    <!--test1变红，i是p的第一个子元素-->
<i>iiii11</i>                           <!--iiii11无变化，不是body的第一个子元素，是第四个子元素-->
</body>
```
```html
<body>
<p><i>test0</i>,00,<i>test00</i></p>    <!--test0变红，i是p的第一个子元素-->
<p><i>test1</i>,11,<i>test11</i></p>    <!--test1变红，i是p的第一个子元素-->
<i>iiii11</i>                           <!--iiii11无变化，不是body的第一个子元素，是第三个子元素-->
</body>
```
```css
i:first-child{        
    color: red;
}
```
> 9.伪元素选择器：向某些选择器添加特殊效果；

|属性|描述|
|---|---|
|:first-letter|向文本的第一个字母添加特殊样式|
|:first-line|向文本的首行添加特殊样式|
|:before|在元素之前添加样式|
|:after|在元素之后添加样式|
```html
<span>00</span>
```
```css
span:before {               //倒三角
    content: "";
    border: 5px solid transparent;
    border-top-color: red;
    display: inline-block;
    margin-bottom:-2px;
    margin-left: 10px;
}
```
```css
span:before {              //插入一张图片
  content: url("../img/test.jpg");
}
```
> 10.分组选择符：用","隔开：同时设置对个标签的样式
```
#p1,#p2{
  font-size:20px;
}
```

5、盒子模型(box model)
> 1.padding属性：子标签距离自己的距离；
> 2.margin属性：自己距离父标签的距离；
```
//这两种样式写法的作用相同
#parent{
  border:1px solid red;
  height: 500px;
  width: 500px;
  padding:30px;
}
#child{
  border:1px solid blue;
  height: 150px;
  width: 150px;
  margin: 30px;
}
<div id="parent">
  <div id="child">
    hello
  </div>
</div>
```

6、清除标签的原来样式
> 1.一些标签有自己原来的margin和padding样式，例如`<h2>`标签；
> 2.<body>中也存在默认的margin；
> 3.清除所有的样式：
> 1. 用`*`表示所有的标签；
```
*{
  margin:0px;
  padding:0px;
}
```

7、特殊的文本标签兼容性(例如<span>和<a>)
> 1.只能设置文本的标签，在W3C标准中默认是不能用width等样式修饰的(直接对其赋值是无用的)；
> 2.要通过`display:block`之后才会有作用；
> 3.在IE中是直接使用width是有用的。

8、padding的兼容性
> 1.对于padding而言，如果一个标签设置了height或width，此时，再进行padding设置；
> 2.对于IE而言，padding值不会加到height和width中；
> 3.除了IE以外的浏览器，padding值会加到height和width中；例如，一个div高度是40，padding-top为20，此时，div的高度变成了60。
> 4.不要使用padding进行对齐操作。
```
#star span{
  border:1px solid purple;
  width:50px;
  height:30px;
  display: block;
  text-align: center;
  padding-top: 20px；
}
<div id="star">
  <span>111</span>
  <span>222</span>
  <span>333</span>
  <span>444</span>
</div>
```

9、定位：相对定位和绝对定位
> 1.absolute：绝对定位，不占据空间，会被其他元素占用；
> 1. 针对上一级的父元素中的position为absolute来进行定位；
> **2019/2/21：注：经代码检查，只要上级元素中有`position:relative;`，或者`position：absolute；`就会针对这一层的样式来进行定位。`position：relative;`有一个优点，会占据空间，不至于下面的元素顶上来，建议使用。（作用：针对某个指定的区域使用绝对定位）**
```html
<div class="container">
    <div class="list">        //绝对定位相对于container的位置开始定位

    </div>
</div>
```
```css
.container {
    position: relative;
    height: 100px;
    width: 100px;
    border: 1px solid red;
}
.list{
    position:absolute;
    left:20px;
    top:20px;
    height: 30px;
    width: 30px;
    background-color: #e227b1;
}
```
> 2. 如果父级中，没有这样的定位方式，会针对body来进行定位；
> 3. 使用方法：
```
position: absolute;
bottom: 0px;
left: 10px;
```
> 2.relative：相对定位，占据空间（哪怕这个元素已经移动到其他地方）
> 1. 针对父元素；
> 2. 使用方法：
```
position: relative;
bottom: 0px;
left: 10px;
```
> **使用：用来设置文本对齐方式**

10、给ul中的li标签添加一个自定义的小圆点
> 1.通过background属性来加载一张图片；
```
background: url("2.png") no-repeat;     //不重复填充该图片
background-position: 2px 4px;           //设置图片的位置
```

20、加载一张图片的方法
> 1.使用<img>标签：适用加载会变化的图片；
> 2.使用background属性；适用加载固定不变的图片；
> 3.区别：
> 1. 使用<img>加载图片，再次请求加载图片时，需要时间；
> 2. 使用background属性，再次请求图片，会在缓存器中读取，节约了时间；

30、float的使用
> 1.float:left
> 1. 元素会自动向左排齐；
> 2. 如果外层标签宽度不能满足float标签的宽度，会自动换行；
> 3. 对于IE而言，该标签会占据空间，其他浏览器不会占用空间；
> 4. 在使用了这个对齐方法以后，在下一个元素中药使用clear:both;来清除左右漂移；（解决浏览器兼容问题）
```
#nav ul li{
  float: left;
}
#content{
  clear:both;
}

<div id="nav">
  <ul>
    <li><span>返回首页</span></li>
    <li><span>联系我们</span></li>
  </ul>
</div>
<div id="content">内容管理</div>
```
> 2.float:right
> 1. 元素会自动向右排齐；

31、浏览器兼容的居中方法
```
position: absolute;
left:50%;
margin-left: -550px;
```

32、超链接的样式
> 1.a:link表示默认的样式；
> 2.a:visited表示访问之后的样式；
> 3.a:hover表示鼠标移到超链接上的样式
> 4.同一类的超链接可以用class来区分
> **注意：在IE中link不能自动继承visited，我们要手动配置才能够达到效果**
```
a.nav_href:link,a.nav_href:visited{
  text-decoration: none;
  font-size: 14px;
  color: blue;
}
a.nav_href:visited{
  color: red;
}
a.nav_href:hover{
  color: green;
  text-decoration: underline;
}
<a href="#" class="nav_href">超链接1</a>
<a href="#" class="nav_href">超链接2</a>
```

33、设置多个样式
> 1.添加多个类名，类名的顺序与加载样式的顺序无关，取决于样式表中的顺序；

```
li.nav_li{                            //取决于这里定义的顺序
  width:160px;
  height: 40px;
  float: left;
  text-align: center;
  border-right: 1px solid #339;
  border-bottom: 0px;
}
li.nav_last{                         //取决于这里定义的顺序
  border: none;
}

<li class="nav_li"><a href="#">工作动态</a></li>
<li class="nav_li"><a href="#">联系我们</a></li>
<li class="nav_li nav_last"><a href="#">网站帮助</a></li>     //两个效果相同
<li class="nav_last nav_li"><a href="#">网站帮助</a></li>     //两个效果相同
```

34、浏览器兼容性（CSS Hack）
> 1.Hack：不同的浏览器识别不同的css语言；
> 2.具体语法：百度css hack；

35、css选择器优先级
> 1.在不同的级别下：
```
!important > 行内样式 > ID选择器 >  类选择器|属性选择器|伪类选择器 > 标签|伪元素选择器 > 通配符 > 继承 > 浏览器默认属性
```
> 1. 子元素选择器|包含选择器，优先级相同；
> 2. 但，如果基于id或类名来写，则会比单纯的id或类选择器的优先级要高；
```html
<div class="class">
    <span class="span">你好</span>
</div>
```
```css
//这两个优先级相同，后写的有效
.class span:hover {
    color: black;
}

.class span[name="test"] {
    color: yellow;
}

//优先级较低，无效
.class span {               
    color: red;
    font-size: 16px;
}
```
> 2.在同一级别中：按书写的顺序执行；
```html
<div class="class">
    <span class="span">你好</span>
</div>
```
```css
//这两个优先级相同，则后写的有效，但，这个优先级比类选择器的优先级高
.class > span {
    color: blue;
    font-size: 10px;
}

.class span {
    color: red;
    font-size: 16px;
}

 //这个无效，优先级比较低
.span {                  
    color:yellow;
}
```
**总结：实际书写顺序**
> **1、`.class`**
> **2、`.class li`和`.class>li`和`.class+li`**
> **3、`.class li:hover`和`.class li[name="test"]`**


# ES6

1、let命令
> 1.声明变量，用法类似于var；
> 2.作用域：声明的变量仅在let命令所在的代码块有效；
```
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    }
}
a[6]();                //6
```
>**注意：可以解决js中的循环存在的问题——闭包**

2、不存在变量提升
> 1.var会出现变量提升，即变量可以在声明之前使用，值为undefined
```
// var 的情况
console.log(foo);        // 输出undefined
var foo = 2;
```
> 2.let命令，一定要声明后使用，否则报错。
```
// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```

3、暂时性死区(TDZ)
> 1.在代码块内，存在let命令和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前使用这些变量，就会报错。
> 2.在声明这些变量之前的区域称为死区。
```
var tmp = 123;    //全局变量

if (true) {
  tmp = 'abc';    // ReferenceError，报错（死区）
  let tmp;        //存在let命令
}
```
```
function bar(x = y, y = 2) {     //y还未声明
  return [x, y];
}

bar();                           // 报错   
```
```
function bar(x = 2, y = x) {     //x声明了
  return [x, y];
}
bar();                           // [2, 2]
```

4、不允许重复声明
> 1.let不允许在相同的作用域内，重复声明同一个变量；
```
// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
```

5、ES6块级作用域
> 1.外层作用域无法获取内层作用于的变量
> 2.块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了
```
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```

6、const命令
> 1.声明一个只读的常量。一旦声明，该值就不可以改变。
> 2.声明常量必须立即初始化，不能留到以后赋值；
```
const PI = 3.1415;
```

1、解构赋值
> 1.是对赋值运算符的扩展；
> 2.一种针对数组或对象进行模式匹配，然后对其中的变量进行赋值；
> 3.书写简洁易懂，语义更加清晰明了。

2、结构模型
> 1.解构的源：解构赋值表达式的右边部分；
> 2.解构的目标：解构赋值表达式的左边部分。

3、数组模型的解构（Array）
> 1.只要等号两边的模式相同，左边的变量就会被赋予对应的值
> 1. 可嵌套的
```
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3
```
> 2. 可忽略的
```
let [ , , third] = ["foo", "bar", "baz"];
third // "baz"
```
> 3. 剩余运算符
```
let [a, ...b] = [1, 2, 3];
//a = 1
//b = [2, 3]
```
> 2.解构不成功：左边的变量值为undefined；
```
let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```
> 3.不完全解构：左边的变量只匹配右边数组的一部分；
```
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```

4、解构默认值
> 1.解构赋值允许执行默认值。
```
let [foo = true] = [];    //foo=true
let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```
> 2.这里的`=`号，使用严格相等运算符`===`，判断一个位置是否有效。只有严格等于undefined时，默认值才会有效。
```
let [x = 1] = [undefined];    // x=1

let [x = 1] = [null];         // x=null
```

5、对象的解构赋值
> 1.数组的元素是按顺序排列的，变量的取值由位置来决定。
> 2.但是，对象的属性没有顺序，变量名必须与属性同名，才能取到对应的值。
> 3.基本
```
let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
// foo = 'aaa'
// bar = 'bbb'

let { baz : foo } = { baz : 'ddd' };
// foo = 'ddd'
```
> 4.可嵌套的
```
let obj = {p: ['hello', {y: 'world'}] };
let {p: [x, { y }] } = obj;
// x = 'hello'
// y = 'world'
```
> 5.可忽略的
```
let obj = {p: ['hello', {y: 'world'}] };
let {p: [x, {  }] } = obj;
// x = 'hello'
```
> 6.剩余运算符
```
let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40};
// a = 10
// b = 20
// rest = {c: 30, d: 40}
```

6、已声明的变量用于解构赋值
> 1.因为`{x}`会理解为一个代码块，从而发生语法错误。
```
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
```
> 2.解决方法：放在圆括号里面
```
// 正确的写法
let x;
({x} = {x: 1});
```
> 3.解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式
```
({} = [true, false]);
({} = 'abc');
({} = []);
```
> 4.由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构
```
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```

7、字符串的解构赋值
> 1.字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象
```
let [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

8、数值和布尔值的解构赋值
> 1.构赋值时，如果等号右边是数值和布尔值，则会先转为对象
```
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```

1、字符的 Unicode 表示法
> 1.允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点;
```
\u0061                  // "a"
```
> 2.但是，这种表示法只限于码点在`\u0000~\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示;
```
\uD842\uDFB7            // "𠮷"
```
```
\u20BB7                 // " 7"
```
> **注意：如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7**

> 3.ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。
> 4.大括号表示法与四字节的 UTF-16 编码是等价的
```
"\u{20BB7}"
// "𠮷"

"\u{41}\u{42}\u{43}"
// "ABC"

let hello = 123;
hell\u{6F} // 123

'\u{1F680}' === '\uD83D\uDE80'
// true
```

1、Symbol的作用
> 1.确保每个属性名都是独一无二的；

2、Symbol类型
> 1.本质：数据类型，表示独一无二的值；
> 2.其余数据类型：undefined，null，Boolean，String，Number，Object
> 3.Symbol值是通过`Symbol`函数生成的；
> 1. 意味着，对象的属性名现在有两种类型，一种是原来的字符串，另一种是新增的Symbol类型。
> 2. 凡是属性名属于Symbol类型，都是独一无二的值，可以保证与其他属性名不会冲突；
```
let s = Symbol();
console.log(typeof s);          //symbol
```

3、Symbol()函数
> 1.不能使用`new`命令，否则会报错；
> 2.因为函数生成的是一个数值，不是对象。
> 3.可以接受一个**字符串**作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转化为字符串时区分；
```
//如果不加参数，在控制台输出的都是Symbol()，不利于区分
let s1 = Symbol('s1');
let s2 = Symbol('s2');
console.log(s1);              //Symbol(s1)
console.log(s2);              //Symbol(s2)
```
> 4.如果Symbol的参数是一个对象，会先调用该对象的toString()方法，转化为字符串，然后生成一个Symbol值；
```
const obj={
    toString(){
        return 'abc';
    }
};
const sym = Symbol(obj);
console.log(sym);             //Symbol(abc)
```
5、Symbol函数生成的值都是独一无二的，因此相同参数的Symbol函数的返回值是不相等的；
```
let s3 = Symbol();
let s4 = Symbol();
console.log(s3===s4);             //false
```
> 6.Symbol值不能与其他类型的值进行计算，会报错；
```
let sym1 = Symbol('Niko');
console.log('my name is ' + sym1);
//Uncaught TypeError: Cannot convert a Symbol value to a string
```
> 7.symbol值可以显式转化为字符串，调用String()方法或者调用toString()方法；
```
let sym2 = Symbol('my symbol');
console.log(String(sym2));                  //'Symbol(my symbol)'
console.log(sym2.toString());               //'Symbol(my symbol)'
```
> 8.symbol值可以转化为布尔值；
```
let sym3 = Symbol('my boolean');
console.log(Boolean(sym3));                 //true
console.log(!sym2);                         //false
```

4、实例属性description：Symbol.prototype.description
> 1.作用：获取一个描述；
```
let sym3 = Symbol('my boolean');
console.log(sym3.description);            //'my boolean'
```

5、作为属性名的Symbol

# Html

1、HTML的全称是什么？作用?
>1. HyperText Markup Language(超文本标记语言)
>2. `HTML`的作用是告诉浏览器如何去显示页面。

2、超文本标记语言的标记什么意思？
>1. HTML提供一种方法使用`标签`去`标记`你的文本，来告诉浏览器你的文本的结构是什么。


1、html文件的创建
> 1.创建一个文本文件，后缀名修改为xxx.html或xxx.htm;

2、html标签
> 1.作用：指定相应显示的内容；
> 2.网页内容必须在<html>中；
> 3.每一个标签都有相应的开始和结束；
> 4.网页中的标签用小写（也可以用大写，但基于xhtml标准全是小写）；

3、html属性lang——规定网页或部分网页的语言
```
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">             //在xhtml中
...
</html>
```
> 1.html5官方文档：说明lang属性遵循BCP 47
The lang attribute (in no namespace) specifies the primary language for the element’s contents and for any of the element’s attributes that contain text. Its value must be a valid BCP 47 language tag, or the empty string. Setting the attribute to the empty string indicates that the primary language is unknown.  [BCP47]
> 2.现在只需要查看IANA就可以了。

IANA语言子标记注册表：https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry

BCP 47：https://tools.ietf.org/html/bcp47


知乎：https://www.zhihu.com/question/20797118

> 2.语言文字标签书写顺序
> 1. 常见的一般有 language、language-script 和 language-region 三种。
```
language-extlang-script-region-variant-extension-privateuse
语言文字种类-扩展语言文字种类-书写格式-国家和地区-变体-扩展-私有
```
```
language:
fr 法语
es 西班牙语

language-extlang:
zh-lzh 中文 (文言文)
sgn-csl 手语 (中国大陆)

language-script:
cmn-Hans 普通话 (简体)
yue-Hant 粤语 (繁体)

language-region:
zh-CN 中文 (简体, 中国大陆)
en-US 英语 (美国)

language-script-region：
cmn-Hans-CN 普通话 (简体, 中国大陆)
cmn-Hant-TW 普通话 (繁体, 台湾)
```
> 2.`Type: redundant`和`Deprecated`
> 1. “zh-Hant”、“zh-yue”和“zh-cmn-Hans”都是“Deprecated”
> 2. 而且，Type: redundant
> 3. 原因：“zh”和“Hant”已经被收录了，拼起来就是“zh-Hant”，再把这个当做单独条目收录，会重复，所以废弃了。而拼起来的“zh-Hant”正常使用。

3、两种写法不允许
> 1.标签不能只有开始，没有结束；
> 2.标签不能嵌套；
>```
><aaa>ggg<bbb>bbb</aaa></bbb>
>```

iso lang
www.iana.org

1、<head>标签：给搜索引擎和浏览器看的
> 1.<head>标签的内容不会在网页主体中显示，
> 2.一般用来设置标题`<title>`;
> 3.外部文件的引入；
> 4.设置`<meta>`中的信息；

2、`<meta>`标签：定义网页使用的语言
> 1.搜索引擎用关键字进行检索；
>```
><meta name="keywords" content=""/>
><meta name="description" content=""/>
>```
> 2.告诉浏览器和搜索引擎网页的信息；
> 3.`<meta charset="utf-8" />`：定义了字符编码；
> 1. 第一代语言90年：GB2313(包含6763个汉字)；
> 2. 第二代语言：GBK(包含21886个汉字，后发展到70244汉字)；
> 3. 第三代语言：UTF-8(包含200多个国家和地区的文字)

3、搜索引擎中的关键字搜索功能-爬虫
> 1.告诉搜索引擎和浏览器：网页的招牌
`<meta name="keywords" content="碰撞球，css3">`
> 2.网站的简介
`<meta name="description" content="这是最厉害的css3碰撞球特效">`

4、换行标签
> 1.<br>：标签里面没有内容，要使用自结束标签`<br/>`
> 2.<p>：前面和后面会有空行

5、body中的标题标签
> 1.`<h1>`
> 2.`<h2>`
> 3.`<h3>`
> 4.`<h4>`
> 5.`<h5>`
> 6.`<h6>`
> 7.应用：网页的某个标题部分

6、无序列表标签
> 1.`<ul>`
>```
><ul>
>    <li>唐曾</li>
>    <li>八戒</li>
></ul>
>```

7、有序列表标签
> 1.`<ol>`
>```
><ol>
>    <li>唐曾</li>
>    <li>八戒</li>
></ol>
>```

1、列表显示的方法
> 1.<ul>
>```
><ul>
>    <li>
>        <h2>网站首页</h2>
>        <ul>
>            <li>机构设置</li>
>        </ul>
>    </li>
></ul>
>```
> 2.<dl>
>```
><dl>
>    <dt>网站首页</dt>
>    <dd>机构设置</dd>
></dl>
>```

2、html中的注释标签
> 1.`<!--内容-->`

3、显示代码标签
> 1.<pre>
>```
><pre>
>for(int i = 0, i < 10; i++)
>{
>    printf(%d,i);
>}
></pre>
>```

4、转义字符，在末尾要加上分号
> 1.`&lt;`：表示小于号；
> 2.`&gt;`：表示大于号；

5、空格符
> 1.`&nbsp;`在页面中显示空格；

6、常用符号
> 1.`&copy;`：copy符号
> 2.`&amp;`：表示"&"符号

7、超链接标签<a>
> 1.<a>标签常用属性
> 1. href：链接地址
> 2. target：打开方式，默认是`_self`
>- 1.`_blank`：在一个新打开、未命名的窗口中载入目标文档。
>- 1.`_parent`：文档载入父窗口或者包含来超链接引用的框架的框架集
>- 1.`_self`：在同一个的框架或者窗口中打开
>- 1.`_top`：清除所有被包含的框架并将文档载入整个浏览器窗口。
>```
><a href="HTMLPage1.html" target="_blank" title="超链接标签">这是一个超链接</a>
>```
> 3.title：显示内容

8、插入滚动内容，已废弃
> 1.<marquee>
> 1. direction属性：设置滚动方向；
> 2. scrollamount属性：设置滚动的速度；
> 3. onmousemove属性：鼠标放在内容上，会停止；
> 4. onmouseout属性：鼠标移走，内容会继续滚动；
>```
><marquee direction="up" scrollamount="2" onmousemove="this.stop()" onmouseout="this.start()">
>    我会动
></marquee>
>```

9、图片标签<img>
> 1.alt属性：设置图片的名称，加载失败时会显示；
>```
>    <img src="1.jpg" width="300" height="300" alt="你好" title="搞笑图片"/>
>```

1、块级标签<div>
> 1.作用：设置一个容器，可以在容器中放置大量数据；

2、行内标签<span>
> 1.作用：放置文本数据，进行简单的控制；

3、表格布局：维护困难
> 1.组成部分：table，tr，td
> 2.控制样式：thead，tbody
> 1. border属性：表格有无边框
> 2. align属性：设置位置
> 3. colspan属性：合并单元格；参数即为合并的个数；
> 4. valign属性：上下的对齐
>```
><table width="900" align="left" border="1">
>    <tr>
>        <td>1.1</td>
>        <td>1.2</td>
>    </tr>
>    <tr>
>        <td>2.1</td>
>        <td>2.2</td>
>    </tr>
>    <tr>
>        <td colspan="2">3.1</td>
>    </tr>
></table>
>```

4、表格的嵌套
>```
><table width="900" align="left" border="1">      //3列的表格
>    <tr>
>        <td>1.1</td>   
>        <td>1.2</td>
>        <td>1.3</td>
>    </tr>
>    <tr>
>        <td>2.1</td>
>        <td>2.2</td>
>        <td>2.3</td>
>    </tr>
>    <tr>
>        <td colspan="3">      //先合并为一个单元格
>            <table width="900" align="left" border="1">   //    嵌套一个2列的表格
>                <tr>
>                    <td>3.1</td>
>                    <td>3.2</td>
>                </tr>
>            </table>
>        </td>
>    </tr>
></table>
>```

常用的表单

1、form表单
> 1.默认是get提交方式，提交给本页；

2、input标签
> 1.type属性：
> 1. text：文本框；
> 2. password：密码；
> 3. submit：提交按钮，会链接到form表单的action操作；
> 4. button：普通按钮；
> 5. radio：单选框（通过name属性来判断是否为同一组）；
> 6. checkbox：多选框；

3、select下拉框
> 1.通过<option>来设置下拉框中的item；

4、textarea多行文本框
> 1.cols属性：设置文本框的宽；
> 2.rows属性：设置文本框的长；

5、例子
>```
><form action="HTMLPage1.html">
>    用户名：<input type="text"/><br/>
>    密码：<input type="password"/><br/>
>    性别：<input type="radio" value="男" name="sex"/>男<input type="radio" value="女" name="sex"/>女<br/>
>    兴趣：<input type="checkbox"/>羽毛球<input type="checkbox" />蓝球<input type="checkbox" />足球<br/>
>    籍贯：<select>
>            <option>北京</option>
>            <option>上海</option>
>            <option>南京</option>
>          </select><br/>
>    个人简介：<textarea rows="10" cols="50"></textarea><br/>
>    <input type="submit" value="注册"/>
>    <input type="button" value="登陆"/><br/>
></form>
>```

框架页面

1、frameset框架页
> 1.cols属性：横向分成若干个块；
> 1. 130：表示第一部分的大小；
> 2. `*`：表示第二个部分是剩余的所有的大小；
> 3. 150：表示第三部分的大小；
>```
>cols="130,*,150"      //分成3列
>```
> 2.rows属性：纵向分成若干个块，（同上）
> 3.frameborder属性：设置有无边框；
> 4.border属性：设置边框的大小；
> 5.noresize：设置块不能拖动；
> 5.<frmae>标签：设置每一块的内容

2、<frame>标签
> 1.src属性：链接的URL；
> 2.name属性：设置标题
> 1. 可以与<a>标签中的target属性一起使用；
>```
><a href = "1.html" target = "content">超链接</a>
>//点击a标签，则会在<frame>中打开1.html
><frame src = "2.html" name = "content"></frame>
>```

3、<frameset>的嵌套
> 1.规定：cols和rows设置了几个块，就必须写几个<frame>;
> 2.注意点：frameset不能和<body>一起使用；
> 3.嵌套时不能够在<frame>中写<frameset>;
>```
><frameset rows="100,*,100" frameborder="0">
>    <frame src="HTMLPage1.html" noresize></frame>
>    <frameset cols="130,*">
>        <frame src="HTMLPage2.html"></frame>
>        <frame src="HTMLPage3.html"></frame>
>    </frameset>
>    <frame src="HTMLPage4.html" noresize></frame>
></frameset>
>```
> **注：不能够写成如下，无法正确显示**
>```
><frameset rows="100,*,100" frameborder="0">
>    <frame src="HTMLPage1.html" noresize></frame>
>    <frame>
>      <frameset cols="130,*">
>        <frame src="HTMLPage2.html"></frame>
>        <frame src="HTMLPage3.html"></frame>
>        </frameset>
>    </frame>
>    <frame src="HTMLPage4.html" noresize></frame>
></frameset>
>```

4、完整例子
>```
><!DOCTYPE html>
><html lang="en" xmlns="http://www.w3.org/1999/xhtml">
><head>
>    <meta charset="utf-8" />
>    <title>框架</title>
></head>
>
><frameset rows="100,*,100" frameborder="0">
>    <frame src="HTMLPage1.html" noresize></frame>
>    <frameset cols="130,*">
>        <frame src="HTMLPage2.html"></frame>
>        <frame src="HTMLPage3.html" name="content"></frame>
>    </frameset>
>    <frame src="HTMLPage4.html" noresize></frame>
></frameset>
></html>
>```

转载请注明链接：https://blog.csdn.net/feather_wch/article/details/79793596

1、html分为head和body标签

2、head标签存放标题以及meta数据,meta可以存放关键字、作者等数据

3、body存放网页主体内容

4、换行的几种方法？
>1. `<br/>`标签
>2. `<p>hello world<p/>`,`段落标签`-上下都会空一行。
>3. `<h1>hello<h1/>`等`标题标签`也会`换行`

5、标题标签(6级)
```html
<h1>hello<h1/>
  <h2>hello<h2/>
    <h3>hello<h3/>
      <h4>hello<h4/>
        <h5>hello<h5/>
          <h6>hello<h6/>
```

6、有序列表
```html
<ul>
    <li>剧集</li>
    <li>电影</li>
    <li>综艺</li>
    <li>动漫</li>
    <li>娱乐</li>
</ul>
```

7、无序列表
```html
<ol>
    <li>剧集</li>
    <li>电影</li>
    <li>综艺</li>
    <li>动漫</li>
    <li>娱乐</li>
</ol>
```

8、列表的子标签li可以作为布局(内部嵌套标题、列表等等)
```html
<ul>
    <li>
        <h1>剧集</h1>
        <ul>
            <li>动作片</li>
            <li>剧情片</li>
            <li>动画片</li>
        </ul>
    </li>
    <li>
        <h1>电影</h1>
        <ul>
            <li>战狼</li>
            <li>头号玩家</li>
        </ul>
    </li>
</ul>
```

9、xhtml中的列表
```xhtml
<dl>
    <dt>我是XHTML中dt的title</dt>
    <dd>纪实</dd>
    <dd>公益</dd>
    <dd>体育</dd>
</dl>
```
>html中用下列代码可以实现相同效果：
```html
<h1>
    我是HTML中的title
</h1>
<ul>
    <li>纪实</li>
    <li>公益</li>
    <li>体育</li>
</ul>
```

10、html中的注释
```html
<!-- 我是注释 -->
```

11、html中`<pre></pre>`标签显示代码段
```html
<pre>
    public class Person{
        String name;
        int age;
        boolean sex;
    }
</pre>
```

12、html中特殊的符号需要转义字符
|字符|转义字符|
|---|---|
|<   |`&lt; `  |
|>   |`&gt; `  |
|空格   | `&nbsp;`   |
|拷贝权限符号： © | `&copy`  |
| &   |`&amp;`   |

13、超链接`<a></a>`标签
```html
<a href="https://www.baidu.com/"
   target="_blank"
   title="鼠标悬浮在文字上时的提示语">这是“百度一下”的超链接</a>
```
>超链接标签也可以作为`父布局`去放置`img`等标签

14、跑马灯标签: `<marquee></marquee>`
```html
<marquee
        direction="right"
        scrollamount="5"
        onmouseover="this.stop()"
        onmouseout="this.start()">
    这是一个弹弹弹的垃圾控件
</marquee>
```
>`marquee`标签也可以作为`父布局`去放置`img`等标签

15、图片标签
```html
<img src="https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2510956726.webp"
     width="300"
     height="400"
     alt="图片没有加载时显示的内容"
     title="鼠标悬浮在图片上时显示的标题">
```

16、表格`table、tr、td标签`
```html
<table>
    <tr>
        <td>A</td>
        <td>B</td>
        <td>C</td>
    </tr>
    <tr>
        <td>D</td>
        <td>E</td>
        <td>F</td>
    </tr>
    <tr>
        <td>G</td>
        <td colspan="2">H</td>
    </tr>
</table>
```
>复杂页面用table扩展性太差，最好的办法是使用`div标签+css`

17、布局标签`div`的作用
>1. 容器, 类似于`Android中的父布局`
>2. `span标签`是作为文本的容器，可以对文本进行定位。
```html
<div>
    <ul>
        <li>
            <h1>剧集</h1>
            <ul>
                <li>动作片</li>
                <li>剧情片</li>
                <li>动画片</li>
            </ul>
        </li>
        <li>
            <h1>电影</h1>
            <ul>
                <li>战狼</li>
                <li>头号玩家</li>
            </ul>
        </li>
    </ul>
    <span>
          span标签
    </span>
</div>
```

18、html中表单是什么意思？
>1. `表单`的英文为`form`
>2. `html表单`是用于`收集`不同类型的用户输入。
```html
<form action="https://blog.csdn.net/feather_wch">
    用户名: <input type="text"><br/>
    <input type="submit"><br/>
    注册：<input type="button" value="Button">
</form>
```
>`提交`或者`回车`后会进入`action`指明的页面中。

19、表单中的单选框
>1. `name`属性进行分组。
```html
<form>
    性别:<input type="radio" value="男" name="sex">男
    <input type="radio" value="女" name="sex">女
</form>
```
20、表单的多选框
```html
<form>
    城市:<input type="checkbox" value="sh" name="city">上海
    <input type="checkbox" value="bj" name="city">北京
    <input type="checkbox" value="nj" name="city">南京
    <input type="checkbox" value="sz" name="city">深圳
</form>
```

21、下拉框
```html
<form>
    月份:<select>
      <option value="1">Ja</option>
      <option value="2">Fe</option>
      <option value="3">Ma</option>
      <option value="4">Ap</option>
    </select>
</form>
```

22、多文本输入
```html
<textarea cols="50" rows="10"></textarea>
```

# JavaScript

## 博客前端项目

1、连缀是什么
> 1.一句话同时设置一个或多个节点，两个或两个以上的操作。
> 2.例如：同时设置CSS，设置click事件等等；
```
Base.getId('box').css('color','red').html('标题').click(function(){alert('aaa')});
```
> 3.但是，Base.getId('box')返回的是一个元素节点，这个对象没有css方法
> 4.解决方法：将Base.getId('box')返回值改为Base，在Base对象中添加css方法，html方法，click事件；
> **注意：1、Base.getId('box')返回Base对象，2、Base.getId('box').css('color','red')返回Base对象，3、Base.getId('box').css('color','red').html('标题')返回Base对象，4、Base.getId('box').css('color','red').html('标题').click(function(){alert('aaa')})返回Base对象**
```js
$().getId('box').css('color', 'red').css('background', 'green').html('box').click(function () {
    alert('a')
});
$().getTagName('p').css('color', 'red').css('background', 'pink');


var $ = function () {      //创建不同的对象
    return new Base();
};

function Base() {
    //创建一个数组，来保存获取的节点和节点数组
    this.elements = [];
    //获取ID节点
    this.getId = function (id) {
        this.elements.push(document.getElementById(id));
        return this;             //返回Base对象
    };
    //获取元素节点
    this.getTagName = function (tagName) {
        var tags = document.getElementsByTagName(tagName);
        console.log(tags.length);
        for (var i = 0; i < tags.length; i++) {
            this.elements.push(tags[i]);
        }
        return this;           //返回Base对象
    };
}

Base.prototype.css = function (attr, value) {
    for (var i = 0; i < this.elements.length; i++) {
        this.elements[i].style[attr] = value;
    }
    return this;                 //返回Base对象
};
Base.prototype.html = function (str) {
    for (var i = 0; i < this.elements.length; i++) {
        this.elements[i].innerHTML = str;
    }
    return this;                //返回Base对象
};
Base.prototype.click = function (fn) {
    for (var i = 0; i < this.elements.length; i++) {
        this.elements[i].onclick = fn;
    }
    return this;               //返回Base对象
};
```
```html
<div id="box">box111</div>
<p>你好</p>
<p>你好</p>
```

1、获取内容
> 1.之前的连缀，写的方法，可以设置标题内容和CSS样式，
> 2.获取的方法：
> 1. 获取css，传一个属性值；
> 2. 获取标题，不传值；
```
console.log($().getId('box').html());
console.log($().getTagName('p').css('background'));
```

```js
//连缀
var $ = function () {      //创建不同的对象
    return new Base();
};

function Base() {
//创建一个数组，来保存获取的节点和节点数组
    this.elements = [];
}


//获取ID节点
Base.prototype.getId = function (id) {
    this.elements.push(document.getElementById(id));
    return this;             //返回Base对象
};
//获取元素节点
Base.prototype.getTagName = function (tagName) {
    let tags = document.getElementsByTagName(tagName);
    for (let i = 0; i < tags.length; i++) {
        this.elements.push(tags[i]);
    }
    return this;
};
//获取相同的节点(区域化)
Base.prototype.getClass = function (className, idName) {
    let node = null;
    if (arguments.length === 2) {
        node = document.getElementById(idName);
    } else {
        node = document;
    }
    let all = node.getElementsByTagName('*');        //获取所有的节点
    for (let i = 0; i < all.length; i++) {
        if (all[i].className === className) {        //判断是否为需要的节点
            this.elements.push(all[i]);
        }
    }
    return this;
};
//获取节点数组的某一个
Base.prototype.getElement = function (num) {
    let element = this.elements[num];
    this.elements = [];
    this.elements[0] = element;
    return this;
};
//设置css样式
Base.prototype.css = function (attr, value) {
    for (let i = 0; i < this.elements.length; i++) {
        if (arguments.length === 1) {         //获取内容，只传入一个参数为属性名
            if (typeof window.getComputedStyle !== 'undefined') {     //w3c标准，获取计算后的样式(包括外联样式表中的样式)
                return window.getComputedStyle(this.elements[i], null)[attr];
            }
            return this.elements[i].style[attr];   //直接返回这个属性值
        }
        this.elements[i].style[attr] = value;
    }
    return this;                 //返回Base对象
};
//设置link或style中的CSS规则
Base.prototype.addRule = function (num, selector, cssText, position) {
    let sheet = document.styleSheets[num];        //获取第num个样式
    if (typeof sheet.insertRule !== 'undefined') {
        sheet.insertRule(selector + "{" + cssText + "}", position);
    } else if (typeof sheet.addRule !== 'undefined') {     //低版本IE兼容
        sheet.addRule(selector, cssText, position);
    }
    return this;
};
//移除link或style中的CSS规则
Base.prototype.removeRule = function (num, index) {
    let sheet = document.styleSheets[num];
    if (typeof sheet.deleteRule !== 'undefined') {
        sheet.deleteRule(index);
    } else if (typeof sheet.removeRule !== 'undefined') {    //低版本IE兼容
        sheet.removeRule(index);
    }
    return this;
};
//添加class
Base.prototype.addClass = function (className) {
    for (let i = 0; i < this.elements.length; i++) {
        if (!this.elements[i].className.match(new RegExp('(^|\\s)' + className + '(\\s|$)'))) {    //判断className是否存在
            this.elements[i].className += ' ' + className;   //连续添加多个className，并且在两个之间留一个空格
        }
    }
    return this;
};
//移除class
Base.prototype.removeClass = function (className) {
    for (let i = 0; i < this.elements.length; i++) {
        if (this.elements[i].className.match(new RegExp('(^|\\s)' + className + '(\\s|$)'))) {    //判断className是否存在
            this.elements[i].className = this.elements[i].className.replace(new RegExp('(^|\\s)' + className + '(\\s|$)'), ' ');
        }
    }
    return this;
};
//设置内容
Base.prototype.html = function (str) {
    for (let i = 0; i < this.elements.length; i++) {
        if (arguments.length === 0) {     //获取内容，不传入参数
            return this.elements[i].innerHTML;
        }
        this.elements[i].innerHTML = str;
    }
    return this;
};
//触发点击事件
Base.prototype.click = function (fn) {
    for (let i = 0; i < this.elements.length; i++) {
        this.elements[i].onclick = fn;
    }
    return this;
};
```


1、鼠标的几个方法
> 1.hover()方法：鼠标移入移出的方法；
> 2.hide()方法：隐藏方法；
> 3.show()方法：显示方法；

2、设置下拉框的步骤
> 1.搭建页面及样式；
> 2.考虑隐藏的部分；
> 3.通过鼠标移入隐藏部分，然后移出继续隐藏；

## jQuery

1、jquery对象与DOM对象
> 1.通过jquery包装后的对象，是一个类数组对象
> 2.这个对象包含了DOM对象的信息，也封装了很多操作方法；
```
<div class="text" id="div"></div>

$(function(){
    var $div = $('#div');            //封装成类数组对象
    $div.html('jquery');             //调用其中的方法
});
```

2、DOM对象转化为jquery对象
> 1.通过`$(dom)`方法——将普通dom对象转化为jquery对象；
> 2.通过ID获得jquery对象——两种方法
> 1. 直接获取对象
>```
><div class="text" id="div"></div>
>
>$(function(){
>    var $div = $('#div');            //封装成类数组对象，直接获取ID
>    $div.html('jquery');             //调用其中的方法
>});
>```
> 2. 通过`$(dom)`方法获取js对象
>```
>$(function(){
>    var div = document.getElementById('div');     //原生js获取dom对象
>    var $div = $(div);                            //dom对象转化为jquery对象
>    $div.html('普通dom转jquery对象');
>});
>```
> 3.通过标签名获取jquery对象——`$(dom)`方法
> 1. 在原生js对象中配置是第几个标签；
>```
><div class="text" id="div"></div><br/>
><div class="text"></div><br/>
>
>var div = document.getElementsByTagName('div')[1];    //设置为第二个div
>var $div = $(div);
>$div.html('在原生js中设置第二个div中的内容');
>```
> 2. 在jquery对象中配置是第几个标签；
>```
>var div = document.getElementsByTagName('div');
>var $first = $(div).first();                          //获取第一个div
>$first.html('在jquery中设置第一个div中的内容');
>```

3、jquery对象转化为DOM对象
> 1.jquery对象本身类似于数组对象，通过`[index]`方式来获取对应的DOM对象；
```
<div class="text" id="div"></div>

var $div = $('#div');      //获取id为div的对象
var div = $div[0];
div.style.width = '50px';
```
> 2.通过`get(index)`方法来得到相应的DOM对象；
```
<div class="text" id="div"></div>
<br/>
<div class="text"></div>
<br/>

var $div = $('div');         //获取元素名为div的所有对象
var div = $div.get(1);       //得到第二个元素名为div的DOM对象
div.style.height = '50px';
```

1、简单选择器
|选择器|css模式|jquery模式|描述|
|---|---|---|---|
|元素名|div{}|$('div')|获取所有div元素的DOM对象|
|ID|#box{}|$('#box')|获取一个ID为box的DOM对象|
|类(class)|.box{}|$('.box')|获取所有class为box的DOM对象|

2、基本选择器
|选择器|css模式|jquery模式|描述|
|---|---|---|---|
|群组选择器|span,em,box{}|$('span,em,box')|获取多个选择器的DOM对象|
|后代选择器|ul li a{}|$('ul li a')|获取追溯到多个DOM对象，包括a标签之内的标签|
|通配选择器|*{}|$('*')|获取所元素标签的DOM对象|
```
<ul>
    <li><a href="#"><span>链接1</span></a></li>
    <li><a href="#"></a></li>
    <li><a href="#"><p>这是一个段落</p></a></li>
</ul>

$('ul li a').css('color','green');            //包括span标签和p标签，全部被设置为绿色
```

3、层次选择器
|选择器|描述|
|---|---|
|$('parent > child')|子选择器：选定所有指定‘parent’元素中指定的‘child’的直接子元素以及子元素中的内容（下一层及）|
|$('ancestor descendant')|后代选择器：选择给定的祖先元素的所有后代元素，一个元素的后代可能是该元素的一个孩子，孙子，曾孙等（所有层级的）|
|$('prev + next')|相邻兄弟选择器：选择所有紧接在‘prev’元素后的‘next’元素|
|$('prev ~ siblings')|一般兄弟选择器：匹配‘prev’元素之后的所有兄弟元素。具有相同的父元素，并且过滤‘siblings’选择器|
```子选择器
<div>
    <a href="#">选择器<span>测试1</span></a>
</div>

$('div>a').css('color','blue');      //“选择器”和“测试1”全部变蓝
```
```子选择器与后代选择器的区别
$('div span');           //div标签下的所有的span标签，不管什么层级的（后代选择器）
$('div>span');           //div标签的下一层级的span标签，不是所有的（子选择器）
```
```相邻兄弟选择器
<p>jquery</p>
<p id="p">jquery</p>
<p>jquery</p>

$('#p + p').css('color', 'yellow');      //只有第三个变黄
```
```一般兄弟选择器
<p>jquery</p>
<p>jquery</p>
<p id="p">jquery</p>
<p>jquery</p>
<p>jquery</p>

$('#p ~ p').css('color', 'orange');     //第四个和第五个变橙（过滤到第三个p）
```

4、层次选择器的相同点与不同点
> 1.相同点：都有一个参考节点；
> 2.不同点：
> 1. 后代选择器包含子选择器的内容；
> 2. 一般兄弟选择器包含相邻兄弟选择的内容（一般兄弟选择器和相邻兄弟选择器所选择的的元素，必须在同一个父元素下）；

5、过滤选择器
|选择器|返回|实例|
|---|---|---|
|:first|单个元素|$('div:first')：选取所有div元素中的第一个div元素|
|:last|单个元素|$('div:last')：选取所有div元素中的最后一个div元素|
|:not(selector)|集合元素|$('input:not(.myClass)')：选取类名不是myClass的input元素|
|:even|集合元素|$('input:even')：选取索引是偶数的input元素（从0开始计数）|
|:odd|集合元素|$('input:odd')：选取索引是基数的input元素|
|:eq(index)|单个元素|$('input:eq(1)')：选取索引为1的input元素|
|:gt(index)|集合元素|$('input:gt(1)')：选取索引大于1的input元素|
|:lt(index)|集合元素|$('input:lt(1)')：选取索引小于1的input元素，不包括1|
|:header|集合元素|$(':header')：选取网页中所有别的h1,h2,h3...|
|:animated|集合元素|$('div:animated')：选取正在执行动画的div元素|
```
<p>jquery</p>
<h1>你好1</h1>
<p>jquery</p>
<p id="p">jquery</p>
<p class="pp">jquery</p>
<p>jquery</p>
<h1>你好1</h1>
<h6>你好1</h6>

$('p:first').css('background','red');
$('p:last').css('background','blue');
$('p:not(.pp)').css('background','orange');
$('p:even').css('background','green');
$(':header').css('background','yellow');
```

6、属性选择器
> 1.使用XPath表达式来选择带有给定属性的元素；

|选择器|jquery模式|描述|
|---|---|---|
|[attribute]|`$('[href]')`|获取带有herf属性的元素|
|[attribute=value]|`$('[href='#']')`|获取href值为'#'的元素|
|[attribute!=value]|`$('[href!='#']')`|获取href值不为'#'的元素|
|[attribute$=value]|`$('[href$='.jpg']')`|获取herf属性值包含以'.jpg'结尾的元素|


1、jquery元素的属性
> 1.每个元素都有一个或多个特性，用来展示元素的附加信息。
> 2.attr()和removeAttr()方法

2、attr()方法
> 1.作用：获取和设置元素属性；
> 2.attr(传入属性名)：获取属性的值；
> 3.attr(属性名，属性值)：设置属性值；
> 4.attr(属性名.函数值)：设置属性的函数值；
> 5.attr(attributes)：给定元素设置多个属性值（例如：{属性名一:"属性值",属性名二:"属性值",...}）
```
<input type="text" value="php 中文网" id="ipt">

alert($("#ipt").attr('value'));
$("#ipt").attr('value','你好')
```

3、removeAttr()方法
> 1.作用：删除
> 2.removeAttr(attributeName)：为匹配的元素集合中的每个元素移除一项属性；

4、这两个方法的优点
> 1.都是封装的方法;；
> 2.直接调用方法即可；

5、html()方法
> 1.html()方法：获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容；
> 1. html()：不传入值，就是获取集合中第一个匹配元素的HTML内容；
> 2. html(htmlString)：设置每一个匹配元素的HTML内容；
> 3. html(function(index,oldhtml))：用来返回设置HTML内容的一个函数；
```
<div id="dv">php 中文网</div>

$('#dv').html();
$('#dv').html("www.php.cn");
```

6、追加内容——append(htmlString)
> 1.作用：在指定的位置加入内容(可以加入新的元素节点)
> 2.注意：与指定的元素是父子关系；
```
<div id="append">追加内容</div>

$('#append').append('<em>新内容</em>')                  //追加内容新内容(斜体)
```

7、after和before方法
> 1.after：在所有匹配的元素之后加入新的HTML内容；
> 2.before：在所有匹配元素之前加入新的HTML内容；
> 3.共同点：与指定的元素是兄弟关系
```
<div id="append">追加内容</div>

$('#append').before('<em>之前插入</em>');
$('#append').after('<em>之后插入</em>');
//之前插入(斜体)
//追加内容
//之后插入(斜体)
```

8、text()方法
> 1.作用：
> 1. 得到匹配元素集合中每个元素的文本内容结合，包括他们的后代；
> 2. 设置匹配元素集合中每个元素的文本内容为指定的文本内容；
```
```
> 2.用法
> 1. text()：得到匹配元素集合中每个元素的合并文本，包括他们的后代；
> 2. text(textString)：设置匹配元素内容的文本；
> 3. text(function(index,text))：返回设置文本内容的一个函数；
```
<div id="text">匹配集合</div>

console.log($('#text').text());               //匹配集合

$('#text').text('匹配集合22');
console.log($('#text').text());               //匹配集合22
```

9、val()方法
> 1.作用：用于处理表单元素的值，比如input，select和textarea。
> 2.val()：无参数，获取匹配的元素集合中第一个元素的值（多用来设置表单的字段的值）；
> 3.val(value)：设置匹配集合中每个元素的值；
> 4.val(function)：用来返回设置值得函数；
> **注意：val()在处理select元素时，当没有选项被选中时，它返回null**
```
<select id="see">
    <option>php 中文网</option>
    <option>php.cn</option>
    <option>小猪 CMS</option>
</select>
<p></p>

$("p").text($('#see').val());            //将p标签内的文本内容设置为‘php 中文网’
```

10、html(),text()和val()的差异
>1..html(),.text(),.val()三种方法都是用来读取选定元素的内容；
>2.只不过.html()是用来读取元素的html内容（包括html标签），
>3.text()用来读取元素的纯文本内容，包括其后代元素，
>4.val()是用来读取表单元素的"value"值。
>5.其中html()和text()方法不能使用在表单元素上,
>6.而val()只能使用在表单元素上；
>7.另外html()方法使用在多个元素上时，只读取第一个元素；
>8.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的"value"值，
>9.但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。
>10.html(htmlString),text(textString)和val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。
>11.html(),text(),val()都可以使用回调函数的返回值来动态的改变多个元素的内容。

11、addClass(className)方法
> 1.作用：动态增加类名，来增加样式；
```
<style type="text/css">
    div{
        width:200px;
        height:200px;
    }
    .bg{
        background:red;
    }
</style>

<div id="div">php 中文网</div>

$("#div").addClass('bg');       //增加"class='bg'"
```

12、removeClass(className)方法
> 1.作用：动态去除类名，来去除样式；
```
<style type="text/css">
    div{
        width:200px;
        height:200px;
    }
    .bg{
        background:red;
    }
</style>

<div id="div" class="bg">php 中文网</div>

$("#div").removeClass('bg');       //去除类名为bg的样式
```

13、toggleClass()方法
> 1.作用：addClass()与removeClass()方法的切换，动态增加和删除样式；
> 2.在匹配的元素集合中的每个元素上添加或删除一个或多个样式，取决于这个样式是否存在或值切换属性；
> 3.如果不存在，就添加类名，如果存在，就删除类名。
> 4.toggleClass(className)：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名；
> 5.toggleClass([switch])：一个用来判断样式类添加还是移除的布尔值；
> 6.toggleClass(className,switch)：一个布尔值，用于判断样式是否应该被添加或移除；
> 7.toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数
```
<style type="text/css">
body,table,td,{
    font-family: Arial, Helvetica, sans-serif;
    font-size: 12px;
}

.h {
    background: #f3f3f3;
    color: #000;
}

.c {
    background: #ebebeb;
    color: #000;
}
</style>

<table id="table" width="50%" border="0" cellpadding="3" cellspacing="1">
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
    <tr>
        <td>php中文网</td>
        <td>php.cn</td>
    </tr>
</table>

<script type="text/javascript">
//给所有的tr元素加一个class="c"的样式
$("#table tr").toggleClass("c");
</script>
<script type="text/javascript">
//给所有的偶数tr元素切换class="c"的样式
//所有基数的样式保留，偶数的被删除
$("#table tr:odd").toggleClass("c");
</script>
<script type="text/javascript">
//第二个参数判断样式类是否应该被添加或删除
//true，那么这个样式类将被添加;
//false，那么这个样式类将被移除
//所有的奇数tr元素，应该都保留class="c"样式
$("#table tr:even").toggleClass("c", true); //这个操作没有变化，因为样式已经是存在的
</script>
```

14、css()方法
> 1.作用：获取元素样式属性的计算值或者设置元素的CSS属性；
> 2.css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值;
> 3.css( propertyNames )：传递一组数组，返回一个对象结果;
> 4.css(propertyName, value )：设置CSS;
> 5.css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理;
> 6.css( properties )：可以传一个对象，同时设置多个样式;
> **注意：浏览器属性获取方式不同，在获取某些值的时候都jQuery采用统一的处理，比如颜色采用RBG，尺寸采用px**
```
<div>php 中文网</div>

$('div').css('color','red');

$("div").css({
    width:'200px',
    height:'200px',
    background:'#ccc'
});
```

1、节点的创建
> 1.创建节点(常见的：元素、属性和文本);
> 2.添加节点的一些属性;
> 3.加入到文档中
```
<ul></ul>

$(function(){
    var $li1 = $("<li>php中文网</li>");  //创建第一个li 标签
    var $li2 = $("<li>php.cn</li>");    //创建第二个li 标签

    $("ul").append($li1);              //添加到<ul>节点中，<ul>节点是<li>的父节点
    $($li1).before($li2);
})
```

2、文本节点
> 1.定义：标签中的文字内容;
```
<li>php中文网</li>                  //这里，‘php 中文网’就是文本节点
```

3、属性节点
> 1.定义：整个标签；
```
var $div = $('<div class="shuxing"></div>');     //这是一个属性节点
$('body').append($div);                          //添加到body中
```

4、节点的插入——父子关系的插入（在父元素的后面插入）
|选择器|描述|
|---|---|
|append(content)|向每个匹配的元素内部追加内容|
|appendTo(节点)|把所有匹配的元素追加到另一个、指定的元素集合中|
> **注意：与原生js方法的比较**
>**1、append操作，对应appendChild方法；**
>**2、appendTo操作，对应$(A).append(B)的操作，把A追加到B中；**
```
<div id="append">追加内容</div>

$('#append').append('<em>新内容</em>');         //添加到“追加内容”的后面
$('<em>新内容</em>').appendTo($('#append'));    
```
> 1、append()方法：前面是被插入的对象，后面是要插入的内容；
> 2.appendTo()方法：前面是要插入的内容，后面是被插入的对象；

5、节点的插入——兄弟关系的插入（after()和before()）
|选择器|描述|
|---|---|
|after(content)|在匹配元素集合中的每个元素**后面**插入参数所指定的内容，作为兄弟节点|
|before(content)|据参数设定，在匹配元素的**前面**插入内容|
> 1.两个方法都可以接收HTML字符串，DOM元素，元素数组或jQuery对象，用来插入到集合中每个匹配元素的前面或后面；
> 2.两个方法都支持多个参数传递（after(div1,div2...)）;
>**注意：**
>**1、after向元素的后面添加html代码，如果元素后面有元素了，将后面的元素后移，然后将html代码插入；**
>**2、before向元素的前面添加html代码，如果元素前面有元素了，将前面的元素前移，然后将html代码插入；**
```
<div id="append">追加内容</div>

$('#append').before('之前插入<br>','111');
$('#append').before('<em>之前插入</em>','<span>111</span>');    //顺序插入
$('#append').after('<em>之后插入</em>','<span>222</span>');
```

6、节点的插入——父子关系的插入（在父元素的前面插入）
|选择器|描述|
|---|---|
|prepend(content)|向每个匹配的元素内部前置内容|
|prependTo(节点)|把所有匹配的元素前置到另一个指定的元素集合中|
```
<div id="append">追加内容</div>
<div id="prepend">前置内容</div>

$('#prepend').prepend('<em>prepend内容</em>');    //在“前置内容”的前面插入
$('<em>prependTo内容</em>').prependTo($('#prepend'));   

$('#prepend').prependTo($('#append'));           //将整个'prepend'节点插入到'append'节点的最前面
```

7、append、appendTo、prepend、prependTo四个方法的区别
> 1.append()：向每个匹配的元素内部追加内容；
> 2.prepend()：向每个匹配的元素内部前置内容；
> 3.appendTo()：把所有匹配的元素追加到另一个指定元素的集合中；
> 4.prependTo()：把所有匹配的元素前置到另一个指定的元素集合中；

8、节点的插入——兄弟关系的插入（insertAfter()与insertBefore()）
|选择器|描述|
|---|---|
|insertAfter(节点)|内容在前，指定的元素放在后面，在匹配的元素**后面**插入内容|
|insertBefore(节点)|据参数设定，在匹配元素的**前面**插入内容|
>**注意：这两个方法不支持传递多参数；**
```
<div id="append">追加内容</div>

$('<em>insert之前插入</em>','<span>insert111</span>').insertBefore($('#append'));     //第二个参数无用，无法插入进去（不支持）
$('<em>insert之后插入</em>','<span>insert222</span>').insertAfter($('#append'));      //不支持第二个参数
```

1、empty()方法
> 1.作用：移除了指定元素中的所有子节点；
> 2.不仅移除子元素（包括其他后代元素），而且移除元素里的文本；
> **注意：指定的元素节点依然会保存，只会清空所有的子元素**
```
<div id="empty">
    <p>元素1<span>2级子元素</span></p>
    <p>元素2</p>
</div>

$('#empty').empty();                  //移除所有的子元素，但是父元素保存下来了
```

2、remove()方法
> 1.作用：移除自身及元素内的一切，包括绑定的事件及与该元素相关的jquery数据；
> 2.本质：因为删除了自身这个节点，所以该节点上的事件绑定都无效了；
```
<div id="remove">
    <p>remove方法</p>
</div>

$('#remove').on('click',function(){
    console.log('click事件');
});
$('#remove').remove();                   //整个节点全部都被删除掉了
```
> 3.**表达式参数：通过传递一个选择器表达式来过滤将被移除的匹配元素集合，可以删除指定的节点；**
```
<p>remove方法1</p>
<p>remove方法2</p>
<p>remove方法3</p>

$('p').remove(":contains('2')");     //只留下第一和第三个（移除所有p元素中包含2的元素）
```

3、empty()与remove()的区别
> 1.empty方法，是清空节点，清空元素中的所有后代节点；
> 2.empty方法，不能删除自己本身这个节点；
> 3.remove方法，删除自身及所有的后代节点；
> 4.remove方法，提供一个筛选表达式，删除指定集合中的元素；

4、detach()方法
> 1.作用：临时删除页面上的节点，但是节点上的数据和事件不会丢失，能够在下一个时间段让这个删除的节点显示出来；
> 2.detach()方法会移除对象，但在内存中还是存在的，通过append等方法，就会重新回到文档流中。
```
<p>detach方法</p>
<input type="button" value="删除p元素"/>
<input type="button" value="移动p元素"/>

var p;                    //定义一个全局变量，临时保存删除的节点
$('input:first').click(function(){
    if(!$('p').length) return;     //确保存在p节点，不存在，直接返回
    p = $('p').detach();           //存在节点，则删除，包含自身
});
$('input:last').click(function(){
    $('body').append(p);
});
```

5、detach()与remove()区别
|方法名|参数|事件及数据是否也被移除|元素自身是否被移除|
|---|---|---|---|
|remove|支持选择器表达|是|是|
|detach|支持选择器表达|否|是|

1、clone()方法——拷贝
> 1.浅拷贝：只克隆了节点结构；`.clone()`
> 2.深拷贝：不仅克隆了节点结构，而且克隆了事件和数据；`.clone(true)`
> 3.clone方法，在插入到文档前，可以修改克隆后的元素或元素内容；
```
<style>
    .clone {
        width: 300px;
        height: 200px;
    }

    .clone div {
        width: 100px;
        height: 70px;
        float: left;
        border: 1px solid #ccc;
    }
</style>

<div class="clone" id="left">
    <div id="aaron1">浅拷贝</div>
    <div id="aaron2">深拷贝</div>
</div>

$('#aaron1').on('click', function () {
    var $div1 = $('#aaron1').clone().css('color', 'red');
    $('#left').append($div);               //浅拷贝
});

$('#aaron2').on('click', function () {
    $('#left').append($(this).clone(true).css('color', 'blue'));     //深拷贝
});
```

2、replaceWith()和replaceAll()——替换
> 1.replaceWith(newContent)：
> 2.作用：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合；
```
<div id="replace">
    <p>第一段</p>
    <p>第二段</p>
    <p>第三段</p>
</div>

$('#replace>p:eq(1)').replaceWith('<span>替换新内容</span>')   //将“第二段”p节点替换为span节点
```
> 3.replaceAll(target):
> 4.作用：用集合的匹配元素替换每个目标元素；
```
<div id="replace">
    <p>第一段</p>
    <p>第二段</p>
    <p>第三段</p>
</div>

$('<a>replaceAll</a>').replaceAll('#replace>p:eq(0)')   //将“第一段”p节点替换为a节点
```
> 5.不同点：目标和源相反；
> 6.相同点：功能类似，会删除与节点相关的所有数据和事件处理程序；


3、wrap()方法——包裹单个元素
> 1.作用：给集合中匹配的每个元素周围包裹一个HTML结构(给它增加一个父元素)；
```
<p id="wrap">包裹父元素</p>

$('#wrap').wrap('<div></div>');     //给p节点外面添加一个div节点
```
> 2.wrap(function)：一个回调函数，返回用于包裹匹配元素的HTML内容或JQuery对象；
```
$('#wrap').wrap(function(){         //与上述方法效果相同
    return '<div>';
});
```
> 3.**注意：wrap()函数，可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套好几层，但只有一个核心元素**

4、unwrap()方法
> 1.作用：将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置上；
```
<div>
    <p id="unwrap">unwrap方法</p>
    <p>unwrap</p>
</div>

$('#unwrap').unwrap();     //删除父元素div节点，其余的保留
```

5、wrapAll()方法——包裹集合中的元素
> 1.wrapAll(wrappingElement):
> 2.作用：给集合中匹配的元素增加一个外面包裹HTML结构；
> 3.**注意：如果匹配的多个元素不在一个地方，则会将所有匹配的元素移动至第一个匹配元素的位置，再包裹一个父元素**
```
<a>wrapAll方法</a>
<a>wrapAll方法11</a>

$('a').wrapAll('<div></div>');
```

6、wrapInner()方法
> 1.作用：将集合中的元素内部所有子元素用其他元素包裹起来，并当做指定元素的子元素；
> 2.wrapInner(wrappingElement)：给集合中匹配的元素的内部，增加包裹的HTML结构；
```
<div id="wrapInner">
    <p>wrapInner方法11</p>
    <p>wrapInner方法00</p>
    <p>wrapInner方法33</p>
</div>

$('#wrapInner>p').wrapInner('<div class="111"></div>')    //在每个p元素的内部包裹div元素"例如：<p><div class="111">wrapInner方法33</div></p>"
```

1、children()方法——父子关系
> 1.作用：查找集合里的第一级子元素；
> 2.children()：返回匹配元素集合中每个元素的所有子元素(仅儿子辈)；
```
<div>
    <ul>
        <li>children方法11</li>
        <li>children方法22</li>
    </ul>
    <p>children段落</p>
</div>

$('div').children().css('color','red');    //所有的都变红（第一级子元素有效）
```
> 3.children(selector)：选择性的接受同一类型选择器表达式；
```
$('div').children(':first').css('color','blue');    //只有ul标签内的元素变蓝
```

2、find()方法——后代关系
> 1.作用：查找DOM树中的元素的所有后代元素；
> 2.find遍历当前元素集合中每个元素的后代，只要符合，不管是儿子，还是孙子等，都可以。
```
<div>
    <ul>
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
    </ul>
</div>

$('div').find('span').css('color','orange');
```

3、parent()方法——父子关系
> 1.作用：查找集合里面的每一个元素的父元素，有序的向上匹配元素，并根据匹配的元素创建一个新的jQuery对象；
> 2.选择性的接受同一类型选择器表达式;
```
<div><p>Hello</p></div>
<div class="selected"><p>Hello Again</p></div>

$('p').parent('.selected').css('color','gray');     //只有第二个变灰，选择类名符合的父元素，设置样式
```

4、parents()方法——祖先关系
> 1.作用：查找合集里面每个元素的所有祖先元素，有序的向上匹配，返回的元素顺序是从离他们最近的父级元素开始的；
>**注意：**
>**1.jQuery是一个合集对象，通过parents匹配的是合集中所有元素的祖先元素；**
>**2.parents()方法，选择性的接受同一类型选择器表达式，进行筛选。**
```
<body>
<div>div
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
    </ul>
    <p>children段落</p>
</div>
</body>

$('li').parents().css('color','pink');      //html中的所有字体颜色，均被设置；
```

5、parent()和parents()比较
> 1.前者只是进行了单级的DOM树查找；
> 2.`$('html').parent();`返回一个包含document的集合；
> 3.`$('html').parents();`返回空集合；


6、closest()方法
> 1.作用：从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素；
> 2.接受一个匹配元素的选择器字符串；


7、parents()和closest()比较
> 1.起始位置不同：parents开始于父元素，closest开始于当前元素；
> 2.遍历目标不同：closest要找到指定的目标，找到一个匹配的目标就停止查找；parents遍历到文档根元素，将匹配的元素加入集合中；
> 3.结果不同：closest返回包含零个或一个元素的jquery对象；parents返回包含零个或一个或多个的jquery对象；

8、next()方法——兄弟关系
> 1.作用：查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合；
> 2.选择性的接受同一类型选择器表达式；
```
<ul>ul
    <li>children<span>方法11</span></li>
    <li>children方法22</li>
    <li>children方法33</li>
</ul>

$('li').next().css('background','red');             //第二个变红
$('li').next(':last').css('background','green');    //第三个变绿
```

9、prev()方法——兄弟关系
> 1.作用：查找指定集合中每一个元素紧邻的前面同辈元素的元素集合；
> 2.选择性的接受同一类型选择器表达式；
```
<div>div
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li class="item">children方法33</li>
    </ul>
    <p>children段落</p>
</div>
<div>div2
    <ul>ul2
        <li>children<span>方法1111</span></li>
        <li>children方法2222</li>
        <li class="item">children方法3333</li>
    </ul>
    <p>children段落11</p>
</div>

$('.item').prev().css('color','red');              //两个全部变红
$('.item').prev(':first').css('color','blue');     //只有第一个变蓝
```

10、siblings()方法——兄弟关系
> 1.作用：查找指定元素集合中每一个元素的所有同辈元素
> 2.选择性的接受同一类型选择器表达式；
```
<div>div
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li class="item">children方法33</li>
        <li>children方法44</li>
    </ul>
</div>
<div>div2
    <ul>ul2
        <li>children<span>方法1111</span></li>
        <li>children方法2222</li>
        <li class="item">children方法3333</li>
        <li>children方法4444</li>
    </ul>
</div>

$('.item').siblings().css('color','red');             //所有的变红
$('.item').siblings(':first').css('color','blue');    //只有第一个变蓝
```

11、add()方法
> 1.作用：向合集中添加新的元素；
> 2.接受参数：jquery选择器表达式，DOM元素，或HTML片段；
```
<div>传递元素标签
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li class="item">children方法33</li>
        <li>children方法44</li>
    </ul>
    <p>children段落</p>
</div>

$('li').add('p').css('color','red');   //将p元素加入到li元素合集中，全部设置css样式（li元素和p元素的字体颜色都变红）
```
```
<div>传递html结构
    <ul>ul
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li class="item">children方法33</li>
        <li>children方法44</li>
    </ul>
    <p>children段落</p>
</div>
<div id="li2"></div>

$('li').add('<p>新元素</p>').appendTo($('#li2'));     //在id为li2中插入一个HTML结构（在li合集中插入了p元素，原来位置的会消失）
```

12、each()方法
> 1.作用：类似for循环迭代器，迭代jquery对象合集中的每一个DOM元素；
> 2.通过回调的方式处理，有两个固定的实参，索引与元素；
> 3.回调方法中的this指向当前迭代的dom元素。
> 4.如果提前退出，返回false在回调函数内终止循环；
```
$("li").each(function(index, element) {
    index 索引 0,1
    element是对应的li节点 li,li
    this 指向的是li
})
```
```
<div>
    <ul>
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li>children方法33</li>
        <li>children方法44</li>
    </ul>
</div>
<div>
    <ul>
        <li>children<span>方法11</span></li>
        <li>children方法22</li>
        <li>children方法33</li>
        <li>children方法44</li>
    </ul>
</div>

$('li').each(function(index,element){
   $(this).css('color','green');         //给所有的li元素设置样式
});

$('li').each(function (index, element) {
    if (index % 2) {
        $(this).css('color', 'blue');    //只有下标为基数的li元素设置样式
    }
});
```

1、鼠标事件——单双击事件
> 1.click方法：用于监听用户单击操作；
> 2.dbclick方法：用于监听用户双击操作；
```
<input type="button" value="单击事件"/>

$('input').click(function(){
    console.log('单击事件');
});
```

2、鼠标事件——鼠标按下和弹起事件
> 1.mousedown方法：用于监听用户鼠标按下时的操作；
> 2.mouseup方法：用于监听用户鼠标弹起的操作；
```
<input type="button" value="鼠标弹起按下事件"/>
<p>鼠标事件</p>

$('input:eq(1)').mousedown(function(){
    $('p').css('color','red');          //鼠标按下为红色
});
$('input:eq(1)').mouseup(function(){
    $('p').css('color','orange');       //鼠标弹起为橙色
});
```

3、鼠标事件——鼠标移入移出事件
> 1.mouseover方法：用于监听用户鼠标移入时的操作；
> 2.mouseout方法：用于监听用户鼠标移出时的操作；
```
<input type="button" value="鼠标移入移出事件"/>
<p>鼠标事件</p>

$('input:eq(2)').mouseover(function(){
    $('p').css('background','red');
});
$('input:eq(2)').mouseout(function(){
    $('p').css('background','pink');
});
```

4、鼠标事件——mousemove事件
> 1.定义：当鼠标指针在指定的元素中移动时，会触发该事件；
> 2.用户吧鼠标移动一个像素，就会触发该事件，会非常耗费系统资源，慎用；
```
<style>
    div{
        border:1px solid red;
        height:50px;
        width:50px;
    }
</style>

<p>鼠标事件</p>
<div></div>

$('div').mousemove(function(){
   $('p').css('color','green');          //鼠标移入这个div时，p元素变成绿色；
});
```

5、鼠标事件——mouseenter事件
> 1.定义：当元素指针穿过元素时，触发该事件；（一般与mouseleave事件一起使用）

6、mouseover和mouseenter的区别
> 1.mouseenter事件：只有鼠标穿过被选元素时才会触发；
> 2.mouseover事件：鼠标穿过任何子元素都会触发该方法；
```
div {
    height: 100px;
    width:300px;
}

<div id="over" style="background: gray;padding: 5px;"><h2 style="background:pink;">mouseover事件:<span></span></h2></div>
<br/>
<div id="enter" style="background: gray;padding: 5px;"><h2 style="background:pink;">mouseenter事件:<span></span></h2></div>

$(document).ready(function () {
    x = 0;
    y = 0;
    $('#over').mouseover(function () {
        $('#over span').text(x += 1);       //从上往下划过一次，值为3
    });
    $('#enter').mouseenter(function () {
        $('#enter span').text(y += 1);      //从上往下划过一次，值为1
    });
});
```

7、鼠标事件——mouseleave事件
> 1.定义：当元素指针离开元素时，触发该事件；

8、mouseout和mouseleave的区别
> 1.mouseleave事件：只有鼠标离开被选元素才会触发；
> 2.mouseout事件：鼠标离开任何子元素都会触发该方法，同理第六点；

9、表单事件——focus()和blur()事件
> 1.focus()事件：
> 1. 定义：当元素获得焦点时，触发该事件；
> 2. 当通过鼠标点击选中元素或通过tab键定位带元素时，该元素会获得焦点；
> 3. focus()方法会触发focus事件，或规定当发生focus事件时运行的函数；
```
<p>鼠标事件</p>
请输入：<input id="focus" type="text"/>

$('#focus').focus(function(){
    $('p').css('color','blue');       //获得焦点，p元素变蓝
});
```
> 2.blur()事件：
> 1. 定义：当元素失去焦点时，触发该事件；
> 2. blur()方法触发blur事件，或者设置了function参数，该函数也可规定当发生blur事件时执行的代码；
> 3. **早前，blur事件仅发生于表单元素，现在，可用于任何元素。**
```
<p>鼠标事件</p>
请输入：<input id="focus" type="text"/>

$('#focus').blur(function(){
    $('p').css('color','yellow');       //失去焦点，p元素变黄
});
```

10、表单事件——change()事件
> 1.定义：当元素的值发生改变时，会触发该事件；
> 2.该事件仅用于文本域(text field)，以及textarea和select元素。
> 3.**注意：当用于select元素时，change事件会在选择某个选项时发生；用于text field和textarea时，该事件会在元素失去焦点前发生；**
```
<p>鼠标事件</p>
<select>
    <option>选项1</option>
    <option>选项2</option>
    <option>选项3</option>
</select>

$('select').change(function(){
    $('p').css('color','pink');     //更换选项时，p元素会变粉
});
```

11、表单事件——select()事件
> 1.定义：当textarea或文本类型的input元素中文本被选中时，触发该事件；
> 2.select()方法触发select事件，或规定当发生select事件时运行的函数；
```
<p>鼠标事件</p>
<input id="select" type="text" value="select事件"/>

$('#select').select(function(){
    $('p').css('color','red');           //选中input里的value值时，p元素会变红
});
```

12、表单事件——submit()事件
> 1.当提交表单时，会触发该事件；
> 2.该事件只适用于表单元素；
```
<form action="#" method="post" name="form">
    用户名：<input type="text"/><br/>
    密码：<input type="text"/>
    <input type="submit" value="提交"/>
</form>

$('form').submit(function(){
   alert('error');              //点击提交按钮时，会弹出error
});
```

13、键盘事件——keydown()和keyup()事件
> 1.keydown事件：按钮被按下时触发该事件；
> **注意：如果在文档元素上进行设置，无论元素是否获取焦点，都会触发该事件。**
> 2.keyup事件：按钮被松开时触发该事件，发生在当前获得焦点的元素上。
```
$('body').keydown(function(){
    $('p').html('keydown事件');      //按下按键时触发
});

$('body').keyup(function(){
    $('p').html('keyup事件');       //松开按键时触发
});
```

14、键盘事件——keypress()事件
> 1.定义：当按钮被按下时触发，发生在当前获得焦点的元素上；
> 2.与keydown不同：每插入一个字符，就会发生keypress事件；
```
输入字符验证keypress：<input type="text"/>
<p>keypress：<span>0</span></p>

i = 0;
$('input').keypress(function () {
    $('p span').text(i += 1);            //每插入一个字符，i会加1
});
```

1、什么是AJAX
> 1.全名： Asynchronous JavaScript And XML，异步JavaScript和XML；
> 2.是一种创建交互式网页应用的网页开发技术。
> 3.是一种用于创建快速动态网页的技术；
> 4.是一种在无需加载整个页面的情况下，能够更新部分网页的技术；
> 5.实现了异步更新，即按需更新；

2、AJAX对象
> 1.基于XMLHTTPRequest对象，简称XHR对象；

3、ajax()函数实现AJAX操作
> 1.常用参数：
```
<input type="button" value="个人信息"/>
<div>
    <h3>姓名：<span id="name"></span></h3>
    <h3>工资：<span id="salary"></span></h3>
    <h3>课程：<span id="lesson"></span></h3>
    <h3>域名：<span id="siteName"></span></h3>
</div>

$('input').click(function () {
    $.ajax({                        //jquery函数
        type:"GET",                 //http请求方法
        url:"demo.json",            //要获取数据的url
        data:null,                  //不给url添加任何数据
        dataType:"json",            //获取到的数据当做json类型处理
        success:function(data){     //完成时调用这个回调函数
            $("#name").text(data.name);
            $("#salary").text(data.salary);
            $("#lesson").text(data.lesson[1]);
            $("#siteName").text(data.website.siteName);
        }
    });
});
```
```json
{
  "name": "顾文慧",
  "salary": "2222",
  "lesson": ["JQuery","javaScript"],
  "website":{
    "siteName":"百度一下",
    "domain":"www.baidu.com"
  },
  "version": "1.0.0",
  "dependencies": {

  }
}
```

4、load()方法
> 1.语法：`$(选择器).load(url,args.function(data){回调函数})`；
> 2.访问纯文本文件：
```txt文件
纯文本文件1111
```
```
<input id="txt" type="button" value="纯文本文件"/>
<div id="text"></div>

$('#txt').click(function(){
    $('#text').load("demo.txt");                  //纯文本文件
});
```
> 3.访问html文件（XML文件类似）：
```
$('#txt').click(function(){
    $('#text').load("demo.html");                    //html文件全部内容
    $('#text').load('demo.html li:first', '?' + (new Date()));          //获取html文件的第一个li标签
});
```
```html
<ul>
    <li>课程列表1</li>
    <li>课程列表1</li>
    <li>课程列表1</li>
    <li>课程列表1</li>
    <li>课程列表1</li>
</ul>
```
 > 4.访问json数据
 ```json
 {
  "name": "顾文慧",
  "salary": "2222",
  "lesson": ["JQuery","javaScript"],
  "website":{
    "siteName":"百度一下",
    "domain":"www.baidu.com"
  },
  "version": "1.0.0",
  "dependencies": {

  }
}
 ```
 ```
 $('#txt').click(function () {
     $('#text').load('demo.json',function(data){
         var jsonObj = JSON.parse(data);                             //将获取的json字符串解析为js对象
         $(this).empty()                                             //清空当前显示的json字符串内容
             .append('<p>姓名：<span>'+jsonObj.name+'</span>')
             .append('<p>工资：<span>'+jsonObj.salary+'</span>')
             .append('<p>课程：<span>'+jsonObj.lesson[0]+'</span>')
             .append('<p>域名：<span>'+jsonObj.website.siteName+'</span>')
     })
 });
 ```


 5、Ajax的核心技术——XMLHttpRequest对象
 > 1.简称为XHR对象。
 > 2.创建XHR对象，使用new方法；
 > 3.调用open()方法，启动一个请求以备发送。接受三个参数：请求类型(get,post)、请求的URL、是否异步（false同步);
 > 4.调用send()方法，发送请求。接受一个参数：作为请求主体发送的数据，如果不需要，必须填null。
 ```
 var xhr = new XMLHttpRequest();              //创建XHR对象
 xhr.open('get','demo.php',false);
 xhr.send(null);
 ```

 6、XHR对象的属性
 > 1.IE低版本浏览器，第一次向服务器端请求时，获取最新数据，而第二次就会获取缓存数据，不会获取最新的数据，解决方法，使用JS随机字符串。
 ```
 xhr.open('get', 'demo.php?rand=' + Math.random(), false);
 xhr.send(null);
 alert(xhr.responseText);
 ```

 |属性名|说明|
 |---|---|
 |responseText|作为响应主体被返回的文本|
 |responseXML|如果响应主体中的内容是'text/xml'或'application/xml'，则返回包含响应数据的XML DOM文档|
 |status|响应的HTTP状态|
 |statusText|HTTP状态的说明|

 7、HTTP状态码
 > 1.接受响应后，第一步检查status属性，以确定响应已经成功返回。
 > 2.HTTP状态码为200，表示成功。
 ```
 var xhr = new XMLHttpRequest();
 xhr.open('get', 'demo.php', false);
 xhr.send(null);
 if (xhr.status === 200) {
     console.log(xhr.responseText);
 } else {
     throw new Error('出错：状态码：' + xhr.status);
 }
 ```

 |HTTP码|状态字符串|说明|
 |---|---|---|
 |200|OK|服务器成功返回了页面|
 |400|Bad Request|语法错误导致服务器不识别|
 |401|Unauthorized|请求需要用户认证|
 |404|Not found|指定的URL在服务器上找不到|
 |500|Internal Server Error|服务器遇到意外错误，无法完成请求|
 |503|ServiceUnavailable|由于服务器过载或维护导致无法完成请求|

8、get()函数
> 1.作用：从服务器上获取数据；
> 2.用法与ajax()函数类似；

9、getJSON()函数
> 1.作用：专门处理json数据；
> 2.与get()函数的区别：不需要再解析json字符串；
```
var jsonObj = JSON.parse(data);            //不需要这个解析过程
```

10、post()函数
> 1.作用：向服务器发送数据；

1、淡入淡出方法：Fading方法——不断改变透明度(opacity)来实现
> 1.fadeIn():淡入已隐藏的元素；
> 2.fadeOut();淡出可见元素；
> 3.fadeToggle():在前两个方法之间切换；
> 4.fadeTo():允许渐变为给定的不透明度(值介于0-1之间)；

2、fadeIn()方法——显示隐藏元素
> 1.作用：淡入已隐藏的元素；
> 2.语法：`$(selector).fadeIn(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是fading完成之后所执行的函数名称；
```
.div1{
    width: 80px;
    height: 80px;
    background-color:#2e6da4;
    display: none;
}
.div2{
    width: 80px;
    height: 80px;
    background-color:#398439;
    display: none;
}
.div3{
    width: 80px;
    height: 80px;
    background-color:#761c19;
    display: none;
}

<script type="text/javascript">
    $(document).ready(function(){
        $("#fadeIn").click(function(){
            $("#div1").fadeIn("fast");
            $("#div2").fadeIn("slow");
            $("#div3").fadeIn(3000);
        });
    });
</script>

<button id="fadeIn">淡入已隐藏的元素</button><br><br>
<div class="div1" id="div1"></div><br>
<div class="div2" id="div2"></div><br>
<div class="div3" id="div3"></div><br>
```

3、fadeOut()方法——隐藏可见元素
> 1.作用：用于淡出可见元素；
> 2.语法：`$(selector).fadeOut(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是fading完成后所执行的函数名称；

4、fadeToggle()方法
> 1.作用：在fadeIn()和fadeOut()方法之间切换；
> 2.语法：`$(selector).fadeToggle(speed,callback)`

5、fadeTo()方法
> 1.作用：允许渐变为给定的不透明度(值介于0与1之间)；
> 2.语法：`$(selector).fadeTo(speed,opacity,callback)`
> 3.必须的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.必须的opacity参数将淡入淡出效果设置为给定的不透明度(值介于0与1之间)；
> 5.可选的callback参数是fading完成后所执行的函数名称；
```
$(document).ready(function(){
    $("#fadeTo").click(function(){
        $("#div111").fadeTo(3000,0.15);
        $("#div222").fadeTo("slow",0.4);
        $("#div333").fadeTo("fast",0.6);
    })
})
```

6、jQuery滑动方法——不断改变元素的高度来实现
> 1.slideDown():向下滑动元素；
> 2.slideUp():向上滑动元素；
> 3.slideToggle():在向上和向下滑动之间切换；

7、slideDown()方法
> 1.作用：向下滑动元素；
> 2.语法：`$(selector).slideDown(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；

8、slideUp()方法
> 1.作用：向上滑动元素；
> 2.语法：`$(selector).slideUp(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；

9、slideToggle()方法
> 1.作用：切换上下滑动；
> 2.语法：`$(selector).slideToggle(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；
```
$(document).ready(function(){
    $("#toggle").click(function(){
        $("#change").slideToggle();
    });
});

<button id="toggle">滑动切换</button>
<p id="change">你可以找到你所需要的所有网站建设教程</p>
```

10、显示和隐藏方法：hide()和show()——透明度，高度和宽度不断改变来实现
> 1.语法：`$(selector).hide(speed,callback)`和`$(selector).show(speed,callback)`
> 2.可选的speed参数规定隐藏/显示的速度，可以取值："slow"、"fast"或毫秒；
> 3.可选的callback参数是隐藏或显示完成后所执行的函数名称；
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#hide").click(function(){
            $("p").hide(1000);
        });
        $("#show").click(function(){
            $("p").show();
        });
    });
</script>

<p>如果点击"隐藏"，我就会消失</p>
<button id="hide">隐藏</button>
<button id="show">显示</button>
```

11、切换显示和隐藏：toggle()
> 1.语法：`$(selector).toggle(speed,callback)`
> 2.可选的speed参数规定隐藏/显示的速度，可以取值："slow"、"fast"或毫秒；
> 3.可选的callback参数是toggle()方法完成后执行的函数名称；
```
$(document).ready(function(){
    $("#toggle").click(function(){
        $("p").toggle();
    });
});

<p>如果点击"隐藏"，我就会消失</p>
<button id="toggle">切换显示和隐藏</button>
```

12、jQuery动画：animate()方法
> 1.作用：创建自定义动画；
> 2.语法：`$(selector).animate({params},speed,callback)`
> 3.必须的params参数定义形成动画的css属性；
> 4.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 5.可选的callback参数是动画完成后所执行的函数名称；
**注意：对位置进行操作，首先要把元素的CSS position属性设置为relative、fixed或absolute**
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#start").click(function(){
            $("#startAnimate").animate({left:'250px'});
        });
    });
</script>
<style>
    .start{
        height: 50px;
        width:50px;
        background-color:#f00;
        position:relative;       //设置属性
    }
</style>

<button id="start">开始动画</button>
<div class="start" id="startAnimate"></div>
```

13、animate操作多个属性
> 1.animate()方法几乎可以操作所有的css属性，
> 2.但是，在使用时，必须使用Camel标记法书写所有的属性名，例如，paddingLeft而不是padding-left；
> 3.色彩动画不包含在核心jQuery库中，需要下载 Color Animations插件；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
        left:'250px',
        opacity:'0.5',
        height:'150px'
        });
    });
});
```

14、animate()使用相对值
> 1.在值的前面加上`+=`或`-=`；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
        left:'250px',
        height:'+=150px',
        width:'-=50px'
        });
    });
});
```

15、animate()使用预定义值
> 1.show:显示；
> 2.hide:隐藏
> 3.toggle:切换显示和隐藏；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
          height:'toggle'
          });
    });
});
```

16、animate()队列功能
> 1.编写多个animate()调用，然后会逐一调用这些方法；
```
$(document).ready(function(){
    $("#start").click(function(){
         var temp = $("#startAnimate");
         temp.animate({height:'300px',opacity:'0.4'},"slow");
         temp.animate({width:'300px',opacity:'0.8'},"slow");
         temp.animate({height:'100px',opacity:'0.4'},"slow");
         temp.animate({width:'100px',opacity:'0.8'},"slow");
    });
});
```

17、stop()方法
> 1.作用：用于停止动画或效果(在他们完成之前)；
> 2.适用的效果：包括滑动，淡入淡出和自定义动画；
> 3.语法：`$(selector).stop(stopAll,goToEnd)`
> 4.可选的stopAll参数规定是否应该清楚动画队列。默认是false，仅停止活动的动画，允许任何排入队列的动画向后执行；
> 5.可选的goToEnd参数规定是否立即完成当前动画。默认是false。
**注意：默认的无参数方法：stop()会清除在被选元素上指定的当前动画**

18、stop()滑动效果，无参数
> 1.无参数：表示仅停止当前正在活动的动画，后面的动画依旧会继续执行；
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#down").click(function(){
            $("p").slideDown(5000);
        });
        $("#stop").click(function(){
            $("p").stop();
        });
    });
</script>
<style>
    p{
        display:none;
        background-color: #2e6da4;
    }
</style>

<button id="stop">停止滑动</button>
<button id="down">点击这里，向下滑动</button>
<p>Hello World!</p>
```

19、stop()动画效果，有参数
> 1.一个参数true：表示停止所有的动画，包括正在活动的动画和未活动的动画；
> 2.两个参数true：表示停止所有的动画效果，直接显示动画的结果。
```
$(document).ready(function(){
    $("#top1").click(function(){
        $("#animate").animate({left:'100px'},5000);
        $("#animate").animate({fontSize:'3em'},5000);
    });
    $("#top2").click(function(){
       $("#animate").stop();
    });
    $("#top3").click(function(){
        $("#animate").stop(true);
    });
    $("#top4").click(function(){
        $("#animate").stop(true,true);
    });
});
.animate{
    height:100px;
    width:100px;
    background-color: #1b6d85;
    position: relative;
}

<button id="top1">开始</button>
<button id="top2">停止</button>
<button id="top3">停止所有</button>
<button id="top4">停止但要完成</button>
<div class="animate" id="animate">Hello</div>
```

1、多库共存
> 1.存在两个库都使用了`$`符号，就存在冲突；
> 2.解决：jquery库可以释放`$`的使用，让另一个库正常使用，此时的jquery库只能使用jQuery了；
> 3.jquery库释放`$`符：`jQuery.noConflict();`

1、onload和ready的写法
```
window.onload = function(){

}

$(function(){

})
$(document).ready(function(){       //等同于第二种写法

})
```

2、onload和ready的执行顺序
> 1.window.onload
> 1. 包括页面的图片加载完成之后才会调用（晚）；
> 2. 只能有一个回调监听；
```
```
> 2.$(document).ready()
> 1. 等同于：`$(function(){})`；
> 2. 页面加载完成就回调，不管图片（早）；
> 3. 可以有多个监听回调；

1、自定义插件
> 1.扩展`$`的工具方法：`$.extend();`
> 2.扩展`$()`的功能方法；`$.fn.extend();`
```
(function () {              //立即执行函数
    /*
* 给 $ 添加4个工具方法
* min(a,b)：返回较小值；
* max(a,b)：返回较大值；
* leftTrim()：去掉字符串左边的空格；
* rightTrim()：去掉字符串右边的空格；
*
* 例如：$.min(3,8);
* */
    $.extend({
        min: function (a, b) {
            return a < b ? a : b;
        },
        max: function (a, b) {
            return a < b ? b : a;
        },
        leftTrim: function (str) {
            return str.replace(/^\s+/, '');
        },
        rightTrim: function (str) {
            return str.replace(/\s+$/, '');
        }
    });

    /*
* 给jquery对象 添加3个功能方法(针对checkbox的应用)
* checkAll()：全选；
* uncheckAll()：全不选；
* reverseCheck()：全反选；
*
* 例如：$('input').checkAll();
* */
    $.fn.extend({
        checkAll: function () {
            this.prop('checked', true);                   //this指jquery对象
        },
        uncheckAll: function () {
            this.prop('checked', 'false');
        },
        reverseCheck: function () {
            this.each(function () {                       //this指jquery对象
                this.checked = !this.checked;             //this指dom元素
            })
        }
    })
})();
```

1、jquery-validation
> 1.主要用于做表单验证；
> 2.验证规则：
```
messages: {
	required: "This field is required.",
	remote: "Please fix this field.",
	email: "Please enter a valid email address.",
	url: "Please enter a valid URL.",
	date: "Please enter a valid date.",
	dateISO: "Please enter a valid date ( ISO ).",
	number: "Please enter a valid number.",
	digits: "Please enter only digits.",
	creditcard: "Please enter a valid credit card number.",
	equalTo: "Please enter the same value again.",
	maxlength: $.validator.format( "Please enter no more than {0} characters." ),
	minlength: $.validator.format( "Please enter at least {0} characters." ),
	rangelength: $.validator.format( "Please enter a value between {0} and {1} characters long." ),
	range: $.validator.format( "Please enter a value between {0} and {1}." ),
	max: $.validator.format( "Please enter a value less than or equal to {0}." ),
	min: $.validator.format( "Please enter a value greater than or equal to {0}." )
}
```
```
$.extend($.validator.messages, {
	required: "这是必填字段",
	remote: "请修正此字段",
	email: "请输入有效的电子邮件地址",
	url: "请输入有效的网址",
	date: "请输入有效的日期",
	dateISO: "请输入有效的日期 (YYYY-MM-DD)",
	number: "请输入有效的数字",
	digits: "只能输入数字",
	creditcard: "请输入有效的信用卡号码",
	equalTo: "你的输入不相同",
	extension: "请输入有效的后缀",
	maxlength: $.validator.format("最多可以输入 {0} 个字符"),
	minlength: $.validator.format("最少要输入 {0} 个字符"),
	rangelength: $.validator.format("请输入长度在 {0} 到 {1} 之间的字符串"),
	range: $.validator.format("请输入范围在 {0} 到 {1} 之间的数值"),
	max: $.validator.format("请输入不大于 {0} 的数值"),
	min: $.validator.format("请输入不小于 {0} 的数值")
});
```
> 3.例子
```
<html>
<head>
<meta charset="utf-8">
<title>validation</title>
<script src="js/jquery.js"></script>
<script src="js/jquery.validate.min.js"></script>
<script src="js/messages_zh.js"></script>
<script>
$.validator.setDefaults({
    submitHandler: function() {
      alert("提交事件!");
    }
});
$().ready(function() {
// 在键盘按下并释放及提交后验证提交表单
  $("#signupForm").validate({
	    rules: {
	      firstname: "required",
	      lastname: "required",
	      username: {
	        required: true,
	        minlength: 2
	      },
	      password: {
	        required: true,
	        minlength: 5
	      },
	      confirm_password: {
	        required: true,
	        minlength: 5,
	        equalTo: "#password"
	      },
	      email: {
	        required: true,
	        email: true
	      },
	      "topic[]": {
	        required: "#newsletter:checked",
	        minlength: 2
	      },
	      agree: "required"
	    },
	    messages: {
	      firstname: "请输入您的名字",
	      lastname: "请输入您的姓氏",
	      username: {
	        required: "请输入用户名",
	        minlength: "用户名必需由两个字母组成"
	      },
	      password: {
	        required: "请输入密码",
	        minlength: "密码长度不能小于 5 个字母"
	      },
	      confirm_password: {
	        required: "请输入密码",
	        minlength: "密码长度不能小于 5 个字母",
	        equalTo: "两次密码输入不一致"
	      },
	      email: "请输入一个正确的邮箱",
	      agree: "请接受我们的声明",
	      topic: "请选择两个主题"
	    }
	});
});
</script>
<style>
.error{
	color:red;
}
</style>
</head>
<body>
<form class="cmxform" id="signupForm" method="get" action="">
  <fieldset>
    <legend>验证完整的表单</legend>
    <p>
      <label for="firstname">名字</label>
      <input id="firstname" name="firstname" type="text">
    </p>
    <p>
      <label for="lastname">姓氏</label>
      <input id="lastname" name="lastname" type="text">
    </p>
    <p>
      <label for="username">用户名</label>
      <input id="username" name="username" type="text">
    </p>
    <p>
      <label for="password">密码</label>
      <input id="password" name="password" type="password">
    </p>
    <p>
      <label for="confirm_password">验证密码</label>
      <input id="confirm_password" name="confirm_password" type="password">
    </p>
    <p>
      <label for="email">Email</label>
      <input id="email" name="email" type="email">
    </p>
    <p>
      <label for="agree">请同意我们的声明</label>
      <input type="checkbox" class="checkbox" id="agree" name="agree">
    </p>
    <p>
      <label for="newsletter">我乐意接收新信息</label>
      <input type="checkbox" class="checkbox" id="newsletter" name="newsletter">
    </p>
    <fieldset id="newsletter_topics">
      <legend>主题 (至少选择两个) - 注意：如果没有勾选“我乐意接收新信息”以下选项会隐藏，但我们这里作为演示让它可见</legend>
      <label for="topic_marketflash">
        <input type="checkbox" id="topic_marketflash" value="marketflash" name="topic[]">Marketflash
      </label>
      <label for="topic_fuzz">
        <input type="checkbox" id="topic_fuzz" value="fuzz" name="topic[]">Latest fuzz
      </label>
      <label for="topic_digester">
        <input type="checkbox" id="topic_digester" value="digester" name="topic[]">Mailing list digester
      </label>
      <label for="topic" class="error" style="display:none">至少选择两个</label>
    </fieldset>
    <p>
      <input class="submit" type="submit" value="提交">
    </p>
  </fieldset>
</form>
</body>
</html>
```

1.什么是jquery？
> 1.兼容多浏览器的javascriot库；
> 2.核心理念：写的更少，做的更多；

2.jquery的优点
> 1.免费、开源、使用MIT许可协议；
> 2.开发便捷：例如操作文档对象，选择DOM对象，制作动画效果，事件处理，使用ajax等；
> 3.提供API让开发者编写插件：文档说明很全；

3、jquery特点
> 1.动态特效；
> 2.AJAX；
> 3.通过插件来扩展；
> 4.方便的工具——例如浏览器版本的判断；
> 5.渐进增强；
> 6.链式调用；
> 7.多浏览器支持；


## jquery实例

https://www.cnblogs.com/huchaoheng/p/5711864.html
1、锚方法
> 1.一种简单的返回顶部的功能实现;
> 2.该实现主要在页面顶部放置一个指定名称的锚点链接，
> 3.然后我们在页面下方放置一个返回到该锚点的链接，
> 4.用户点击该链接即可返回到该锚点所在的顶部位置
```
<!-- 定义一个名称为top的锚点链接 -->
<a name="top"></a>

<!-- 返回页面顶部top锚点的链接 -->
<a href="#top">返回顶部</a>
```
**注意：在现代浏览器中，如果浏览器找不到指定的锚点(例如top)，浏览器将会尝试跳转到id为top的HTML元素的起始位置。因此，我们也可以在头部放置一个id为top的HTML元素，遗憾的是，并不是所有的浏览器——尤其是某些浏览器的旧版本，都兼容这种行为。**

2、js操作DOM样式
> 1.使用js将body或html等元素的scrollTop属性设置为0，即可滚动到页面的顶部。
```
// 以下三种方式均可实现返回页面顶部

$(window).scrollTop(0);
$('body').scrollTop(0);
$('html').scrollTop(0);
```
> 2.使用jQuery的动画效果函数animate()来实现平滑滚动到页面顶部的动画效果
```
// 在500毫秒内平滑滚动到页面顶部
$('body').animate( {scrollTop: 0}, 500);
```
```html
//完整例子
<div class="gotop">
    <a href="#top">回到顶部</a>
</div>
```
```css
.gotop {
    height: 50px;
    width: 50px;
    position: fixed;
    bottom: 20px;
    right: 40px;
}
```
```js
$('a[href="#top"]').on('click',function(){
  $('html, body').animate({scrollTop: 0}, 1000, "easeInOutQuint");
  return false;
});
```

3、js函数scrollTo()
> 1.利用JavaScript为我们提供的函数scrollTo(x, y)来实现返回到页面顶部的功能;
> 2.scrollTo函数可以滚动到指定坐标(x, y)处的内容。我们将坐标设定为(0, 0)即可起到返回顶部的作用;
```
<a href="javascript:scrollTo(0,0);">返回顶部</a>
```


## w3cschool

1、jQuery库的特性
> 1.HTML元素选取
> 2.HTML元素操作
> 3.CSS操作
> 4.HTML事件函数
> 5.JavaScript特效和动画
> 6.HTML DOM遍历和修改
> 7.AJAX
> 8.Utilities

2、jQuery语法
> 1.基本语法：`$(selector).action()`
> 1. 美元符号：定义jQuery；
> 2. selector：选择符，“查找和查询”HTML元素；
> 3. action：执行对元素的操作；
```
$(this).hide();                  //隐藏当前的HTML元素
$("p").hide();                   //隐藏所有的<p>元素
$(".class").hide();              //隐藏所有class="class"的元素
$("#id").hide();                 //隐藏所有id="id"的元素
```

3、jQuery选择器有哪些
> 1.元素选择器：使用CSS选择器来选取HTML元素；
```
$("p").hide();              //选取所有的<p>元素
$("p.class").hide();        //选取所有class="class"的<p>元素
$("p#id").hide();           //选取所有id="id"的<p>元素
```
> 2.属性选择器：使用XPath表达式来选择带有给定属性的元素；
```
$("[href]");               //选取所有带href属性的元素
$("[href='#']")            //选取所有带href值等于"#"的元素
$("[href!='#']")           //选取所有带href值不等于"#"的元素
$("[href$='.jpg']")        //选取所有href值以".jpg"结尾的元素
```
> 3.CSS选择器：用于改变HTML元素的CSS属性
```
$("p").css("background-color","red");       //将所有p元素的背景颜色改为红色
```

4、jQuery事件
> 1.事件处理程序指的是：当HTML中发生某些事件时所调用的方法，术语由事件"触发"(或"激发")经常被使用。

5、jQuery处理事件遵循的原则
> 1.把所有的jQuery代码置于事件处理函数中；
> 2.把所有事件处理函数置于文档就绪事件处理器中；
> 3.把jQuery代码置于单独的.js文件中；
> 4.如果存在命名冲突，则重命名jQuery库；

6、jQuery命名冲突
> 1.jQuery使用`$`符号作为jQuery的简介方式；
> 2.某些其他的JavaScript库中的函数(比如Prototype)同样使用`$`符号；
> 3.jQuery使用名为noConflict()方法来解决该问题；
> 4.`var jq = jQuery.noConflict()`，帮助使用自己的名称(使用jq来代替`$`符号)；

1、显示和隐藏方法：hide()和show()
> 1.语法：`$(selector).hide(speed,callback)`和`$(selector).show(speed,callback)`
> 2.可选的speed参数规定隐藏/显示的速度，可以取值："slow"、"fast"或毫秒；
> 3.可选的callback参数是隐藏或显示完成后所执行的函数名称；
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#hide").click(function(){
            $("p").hide(1000);
        });
        $("#show").click(function(){
            $("p").show();
        });
    });
</script>

<p>如果点击"隐藏"，我就会消失</p>
<button id="hide">隐藏</button>
<button id="show">显示</button>
```

2、切换显示和隐藏：toggle()
> 1.语法：`$(selector).toggle(speed,callback)`
> 2.可选的speed参数规定隐藏/显示的速度，可以取值："slow"、"fast"或毫秒；
> 3.可选的callback参数是toggle()方法完成后执行的函数名称；
```
$(document).ready(function(){
    $("#toggle").click(function(){
        $("p").toggle();
    });
});

<p>如果点击"隐藏"，我就会消失</p>
<button id="toggle">切换显示和隐藏</button>
```

3、淡入淡出方法：Fading方法
> 1.fadeIn():淡入已隐藏的元素；
> 2.fadeOut();淡出可见元素；
> 3.fadeToggle():在前两个方法之间切换；
> 4.fadeTo():允许渐变为给定的不透明度(值介于0-1之间)；

4、fadeIn()方法
> 1.作用：淡入已隐藏的元素；
> 2.语法：`$(selector).fadeIn(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是fading完成之后所执行的函数名称；
```
.div1{
    width: 80px;
    height: 80px;
    background-color:#2e6da4;
    display: none;
}
.div2{
    width: 80px;
    height: 80px;
    background-color:#398439;
    display: none;
}
.div3{
    width: 80px;
    height: 80px;
    background-color:#761c19;
    display: none;
}

<script type="text/javascript">
    $(document).ready(function(){
        $("#fadeIn").click(function(){
            $("#div1").fadeIn("fast");
            $("#div2").fadeIn("slow");
            $("#div3").fadeIn(3000);
        });
    });
</script>

<button id="fadeIn">淡入已隐藏的元素</button><br><br>
<div class="div1" id="div1"></div><br>
<div class="div2" id="div2"></div><br>
<div class="div3" id="div3"></div><br>
```

5、fadeOut()方法
> 1.作用：用于淡出可见元素；
> 2.语法：`$(selector).fadeOut(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是fading完成后所执行的函数名称；

6、fadeToggle()方法
> 1.作用：在fadeIn()和fadeOut()方法之间切换；
> 2.语法：`$(selector).fadeToggle(speed,callback)`

7、fadeTo()方法
> 1.作用：允许渐变为给定的不透明度(值介于0与1之间)；
> 2.语法：`$(selector).fadeTo(speed,opacity,callback)`
> 3.必须的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.必须的opacity参数将淡入淡出效果设置为给定的不透明度(值介于0与1之间)；
> 5.可选的callback参数是fading完成后所执行的函数名称；
```
$(document).ready(function(){
    $("#fadeTo").click(function(){
        $("#div111").fadeTo(3000,0.15);
        $("#div222").fadeTo("slow",0.4);
        $("#div333").fadeTo("fast",0.6);
    })
})
```

8、jQuery滑动方法
> 1.slideDown():向下滑动元素；
> 2.slideUp():向上滑动元素；
> 3.slideToggle():在向上和向下滑动之间切换；

9、slideDown()方法
> 1.作用：向下滑动元素；
> 2.语法：`$(selector).slideDown(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；

10、slideUp()方法
> 1.作用：向上滑动元素；
> 2.语法：`$(selector).slideUp(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；

11、slideToggle()方法
> 1.作用：切换上下滑动；
> 2.语法：`$(selector).slideToggle(speed,callback)`
> 3.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 4.可选的callback参数是滑动完成后所执行的函数名称；
```
$(document).ready(function(){
    $("#toggle").click(function(){
        $("#change").slideToggle();
    });
});

<button id="toggle">滑动切换</button>
<p id="change">你可以找到你所需要的所有网站建设教程</p>
```

12、jQuery动画：animate()方法
> 1.作用：创建自定义动画；
> 2.语法：`$(selector).animate({params},speed,callback)`
> 3.必须的params参数定义形成动画的css属性；
> 4.可选的speed参数规定效果的时长，可以取值："slow"、"fast"或毫秒；
> 5.可选的callback参数是动画完成后所执行的函数名称；
**注意：对位置进行操作，首先要把元素的CSS position属性设置为relative、fixed或absolute**
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#start").click(function(){
            $("#startAnimate").animate({left:'250px'});
        });
    });
</script>
<style>
    .start{
        height: 50px;
        width:50px;
        background-color:#f00;
        position:relative;       //设置属性
    }
</style>

<button id="start">开始动画</button>
<div class="start" id="startAnimate"></div>
```

13、animate操作多个属性
> 1.animate()方法几乎可以操作所有的css属性，
> 2.但是，在使用时，必须使用Camel标记法书写所有的属性名，例如，paddingLeft而不是padding-left；
> 3.色彩动画不包含在核心jQuery库中，需要下载 Color Animations插件；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
        left:'250px',
        opacity:'0.5',
        height:'150px'
        });
    });
});
```

14、animate()使用相对值
> 1.在值的前面加上`+=`或`-=`；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
        left:'250px',
        height:'+=150px',
        width:'-=50px'
        });
    });
});
```

15、animate()使用预定义值
> 1.show:显示；
> 2.hide:隐藏
> 3.toggle:切换显示和隐藏；
```
$(document).ready(function(){
    $("#start").click(function(){
        $("#startAnimate").animate({
          height:'toggle'
          });
    });
});
```

16、animate()队列功能
> 1.编写多个animate()调用，然后会逐一调用这些方法；
```
$(document).ready(function(){
    $("#start").click(function(){
         var temp = $("#startAnimate");
         temp.animate({height:'300px',opacity:'0.4'},"slow");
         temp.animate({width:'300px',opacity:'0.8'},"slow");
         temp.animate({height:'100px',opacity:'0.4'},"slow");
         temp.animate({width:'100px',opacity:'0.8'},"slow");
    });
});
```

17、stop()方法
> 1.作用：用于停止动画或效果(在他们完成之前)；
> 2.适用的效果：包括滑动，淡入淡出和自定义动画；
> 3.语法：`$(selector).stop(stopAll,goToEnd)`
> 4.可选的stopAll参数规定是否应该清楚动画队列。默认是false，仅停止活动的动画，允许任何排入队列的动画向后执行；
> 5.可选的goToEnd参数规定是否立即完成当前动画。默认是false。
**注意：默认的无参数方法：stop()会清除在被选元素上指定的当前动画**

18、stop()滑动效果，无参数
```
<script type="text/javascript">
    $(document).ready(function(){
        $("#down").click(function(){
            $("p").slideDown(5000);
        });
        $("#stop").click(function(){
            $("p").stop();
        });
    });
</script>
<style>
    p{
        display:none;
        background-color: #2e6da4;
    }
</style>

<button id="stop">停止滑动</button>
<button id="down">点击这里，向下滑动</button>
<p>Hello World!</p>
```

19、stop()动画效果，有参数
```
$(document).ready(function(){
    $("#top1").click(function(){
        $("#animate").animate({left:'100px'},5000);
        $("#animate").animate({fontSize:'3em'},5000);
    });
    $("#top2").click(function(){
       $("#animate").stop();
    });
    $("#top3").click(function(){
        $("#animate").stop(true);
    });
    $("#top4").click(function(){
        $("#animate").stop(true,true);
    });
});
.animate{
    height:100px;
    width:100px;
    background-color: #1b6d85;
    position: relative;
}

<button id="top1">开始</button>
<button id="top2">停止</button>
<button id="top3">停止所有</button>
<button id="top4">停止但要完成</button>
<div class="animate" id="animate">Hello</div>
```

20、callback函数

# Vue

## 起步

1、在html中配置
> 1.通过`<router-view></router-view>`来渲染路由匹配的组件；
```html
<template>
  <div id="app">
    <img src="./assets/logo.png">
    <router-view></router-view>
  </div>
</template>
```


2、JavaScript中配置路由
> 1.使用模块化编程，首先，在main.js中，要导入Vue和VueRouter，然后调用方法`Vue.use(VueRouter)`
```
//导入两个模块
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router);
```
> 2.在routes.js中导入需要的Vue组件
```
import Login from './views/Login.vue'
```
> 3.在main.js文件中创建router实例，然后，在routes.js文件中配置routes，并且导出routes配置
```routes.js
let routes = [
  {
    path: '/',
    name: 'HelloWorld',
    component: HelloWorld
  },
  {
    path: '/Login',
    name: '',
    component: Login
  }
];

export default routes;
```
```
import Router from 'vue-router'
import routes from './routes'      //导入在routes.js中配置的路由

Vue.use(Router);

//创建router实例
const router = new Router({
  routes
});
```
> 4.在main.js中，创建和挂载根实例。
> 1. 这里要通过router配置参数注入路由，从而让整个应用都有路由功能。
```
new Vue({
  router,
  //这个是vue2.0版本以上，渲染视图的函数，如果没有这个函数，页面的内容就无法加载出来
  render: h >= h(app)
}).$mount("#app");
```

3、注入路由器之后，我们可以在任何的组件中访问路由器
> 1.`$route`：表示当前路由信息对象；包含了当前URL解析得到的信息，还有URL匹配到的路由记录；
> 1. `$route.path`：字符串，对应当前路由的路径，解析为绝对路径。如`/login`
> 2. `$route.params`：key/value对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象；
> 2. `$route.query`：key/value对象，表示URL查询参数。例如，对于路径 /login?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。
> 2. `$route.hash`：字符串，当前路由的hash值(不带#)，如果没有hash值，则为空。
> 2. `$route.fullPath`：完成解析后的URL，包含查询参数和hash的完整路径。
> 2. `$route.matched`：数组，包含当前匹配的路径中所包含的所有片段对应的配置参数对象；
> 2. `$route.name`：当前路径名字
> 2. `$route.meta`：路由元信息
```
<div>
<h1>{{msg}}</h1>
<p>$route.path：{{$route.path}}</p>
<p>$route.params：{{$route.params}}</p>
<p>$route.query：{{$route.query}}</p>
<p>$route.hash：{{$route.hash}}</p>
<p>$route.fullPath：{{$route.fullPath}}</p>
</div>
```
> 2.`$router`：表示全局的路由实例，是router构造方法的实例
> 1. 常用的`$router.options.routes`：数组，获取所有的全局路由配置；

4、路由实例的方法-go()
> 1.作用：页面路由跳转；
> 2.参数：-1表示后退
```
this.$router.go(-1) // 后退
```

5、路由实例的方法-replace()
> 1.作用：替换当前的页面，不会向history栈添加新纪录，一旦替换了新页面，就不能返回老页面了；
```
this.$router.replace('home');
```

6、路由实例的方法-push()
> 1.作用：跳转页面，会向history栈添加新纪录，当我们点击浏览器的返回按钮时可以看到之前的页面；
```
// 字符串
      this.$router.push('home')
// 对象
      this.$router.push({ path: 'home' })
// 命名的路由
      this.$router.push({ name: 'user', params: { userId: 123 }})
// 带查询参数，变成 /register?plan=123
      this.$router.push({ path: 'register', query: { plan: '123' }})
```
```html
<button @click="replace1">replace</button>
<button @click="push1">push</button>
```
```js
export default {
  name: "Login",
  methods:{
    replace1(){
      this.$router.replace('home');   //路由从http://localhost:8080/#/替换为http://localhost:8080/#/home
    },
    push1(){
      this.$router.push('home');
    }
  }
}
```

## 动态路由匹配

1、动态路由
> 1.功能：需要把某种模式匹配到的所有路由，都映射到同一个组件中；
> 2.方法：在`vue-router`的路由路径中，使用"动态路径参数"，以**冒号**开头；
> 3.当匹配到一个路由时，冒号后的参数值会被设置到`$route.params`中，可以在每个组件中使用，
> 4.其他的一些值也会被设置到`$route`的各个参数中；
```
let routes = [
  {
    path: '/',
    name: 'Login',
    component: Login
  },
  {
    path: '/:id',            //这里，不管是http://localhost:8080/#/hello，还是http://localhost:8080/#/home，都会映射到HelloWorld组件的视图上
    name: 'HelloWorld',
    component: HelloWorld
  }
];
```
```
<p>$route.params.id：{{$route.params.id}}</p>    //在组件内会显示对应的参数，在/home路径下，会显示为"home"
```

|模式|匹配路径|$route.params|
|---|---|---|
|/login/:username|/login/evan|{username:"evan"}|
|/login/:username/post/:post_id|/login/evan/post/123|{username:"evan",post_id:"123"}|

2、响应路由参数的变化
> 1.动态路由模式，例如，从"/user/foo"导航到"/user/bar"，使得**原来的组件会被复用**；
> 2.这样，比起销毁再创建，复用显得更加高效；
> 3.**不过，这也意味着组件的生命周期钩子不会再被调用。**
> 4.复用组件时，想对路由参数的变化做出响应的话，可以对复用的组件进行简单的检测变化(watch)`$route`对象;
```
watch:{
  '$route'(to,from){
    console.log('to',to);
    console.log('from',from);
  }
}
```
> 5.也可以使用导航守卫`beforeRouteUpdate`
```
beforeRouteUpdate(to,from,next){
  console.log('beforeRouteUpdate-to',to);
  console.log('beforeRouteUpdate-from',from);
  console.log('beforeRouteUpdate-next',next);
}
```

3、捕获所有路由或404 Not Found路由
> 1.常规参数只会匹配被`/`分隔的URL片段中的字符；
> 2.想匹配仁义路径，可以使用通配符`*`；
```
{
  path: '*',           //会匹配所有路径
  name: '',
},
{
  path: 'user-*',      //会匹配"user-"开头的任意路径
  name: '',
}
```
> 3.使用通配符路由时，确保路由顺序是正确的，也就是说，含有通配符的路由应该放在最后；
> 4.路由`{path:'*',...}`通常用于客户端404错误。
> 5.当使用一个通配符时，`$route.params`内会自动添加一个名为`pathMatch`参数。它包含了URL通过通配符匹配的部分；
```
// 给出一个路由 { path: '/user-*' }
this.$router.push('/user-admin')
this.$route.params.pathMatch // 'admin'
// 给出一个路由 { path: '*' }
this.$router.push('/non-existing')
this.$route.params.pathMatch // '/non-existing'
```

4、匹配路由优先级
> 1.当同一个路径可以匹配多个路由时，匹配的优先级按照路由定义的顺序：谁先定义的，谁的优先级就高；

## 嵌套路由

1、嵌套路由
> 1.在实际中，一个应用界面，通常是由多层嵌套的组件组合而成的；
> 2.同样，URL中的各段动态路径也按某种结构对应嵌套的各个组件；
> 3.实际步骤：
> 1. 在应用界面中使用`<router-view/>`，表示在此处渲染组件模板；
```html
//Login.vue文件
<template>
  <div>
    <h1>{{msg}}</h1>
    <button @click="push2">Home</button>
    //这个地方会渲染其他的组件模板
    <router-view/>
  </div>
</template>
```
```js
export default {
  name: "Login",
  data() {
    return {
      msg: '你好'
    }
  },
  methods: {
    push2() {
      this.$router.push('home');
    }
  }
}
```
> 2. 在路径中使用`children`配置路径；
```js
{
  path: '/',
  name: 'Login',
  component: Login,
  children:[
    {
      //'/home'路径下渲染Home组件
      path:'home',
      component:Home,
    }
  ]
}
```
> **注意：以`/`开头的嵌套路径会被当做根路径，这让你充分的使用嵌套组件而无需设置嵌套的路径**


2、嵌套路由的主路由与子路由
> 1.例如，上面的主路由是`/`，子路由为`/home`，在访问主路由时，子组件不会渲染，只有访问子路由时，子组件才会渲染出来；
> 2.设置主路由下的默认页面的方法，是在`children`中设置一个空的路径，渲染一个默认的页面；
```js
let routes = [
  {
    path: '/',
    name: 'Login',
    component: Login,
    children:[
      {
        //'/home'路径，渲染Home子组件
        path:'home',
        component:Home,
      },
      //'/'路径，默认主路由渲染的页面
      {
        path:'',
        component:HelloWorld
      }
    ]
  }
```


## 编程式的导航

1、编程式导航
> 1.除了通过`<router-link>`，创建a标签来定义导航链接，还可以使用`router`的实例方法，编码实现。

2、`router-link`导航
> 1.支持用户在具有路由功能的应用中点击导航；
> 2.通过to属性指定目标地址，默认渲染为带有正确连接的`<a>`标签，可以通过tag属性生成别的标签。
> 3.另外，当路由成功激活时，链接元素自动设置一个表示激活的css类名。
> 4.to属性：
> 1. to属性，字符串形式
```
<router-link to="home">homeLink</router-link>
```
> 2. to属性，动态绑定
```
//v-bind绑定
<router-link :to="home">homeLinkBind</router-link>
```
```
export default {
  name: "Login",
  data() {
    return {
      home:'home'
    }
}
```
> 3. to属性，动态绑定
```
<router-link :to="{path:'home'}">homeLinkPath</router-link>
```
> 4. to属性，动态绑定，在路由中配置name
```
<router-link :to="{name:'home'}">homeLinkName</router-link>
```
```
{
  path:'home',
  name:'home',       //配置name值
  component:Home,
},
```
> 5.tag属性
> 1. 将`<router-link>`渲染成`<li>`标签
```
<router-link :to="{name:'home'}" tag="li">homeLinkName</router-link>
```
> 2. 在渲染的`<li>`标签中添加`<a>`标签，可以不为a标签添加href属性；此时，a标签将作为真实的链接(会获得正确的href属性)，而激活的css类名(router-link-active)，设置到li标签上；
```
<router-link to="home" tag="li">
  <a>homeLinkLiName</a>
</router-link>
```

3、push()方法
> 1.会向history栈添加一个新的记录；
> 2.所以，当用户点击浏览器后退按钮时，会回到之前的URL。
```
//语法
router.push(location, onComplete?, onAbort?);
```

|声明式|编程式|
|---|---|
|`router-link :to="..."`|`router.push(...)`|
> 3.push方法的参数可以是一个祖父穿路径，或者描述地址的对象；
```
router.push('home');                                         //字符串
router.push({path:'home'})                                   //对象
router.push({name:'user',params:{userId:'123'}});            //命名的路由
router.push({path:'register',query:{plan:'private'}});       //带查询参数"/register?plan=private"
```
> 4.**注意：如果提供了`path`，则`params`会被忽略；此时，可以提供路由的name或者手写完整的带参数的path**
```
const userId = 123;
router.push({name:'user',params:{userId}})              //--'/user/123'
router.push({path:'/user/${userId}'});                  //--'/user/123'
router.push({path:'/user',params:{userId}});             //--'/user'，这里的params不生效
```
> 5.在2.2.0+，可选的`router.push`和`router.replace`中提供`onComplete`和`onAbort`回调作为第二个和第三个参数。
> 1. 这些回调会在导航成功完成(在所有异步钩子被解析之后)或终止(导航到相同的路由，或在当前导航完成之后导航到另一个不同的路由)的时候进行相应的调用；
> 2. **注意：如果目的地和当前路由相同，只有参数发生了变化(比如一个用户跳到另一个，从`/user/1`到`/user/2`，需要`beforeRouteUpdate来响应这个变化`**


4、replace()方法
> 1.用法与push()方法相同；
> 2.唯一不同，就是不会向history添加新的记录，而是直接替换掉当前的history记录；

5、go()方法
> 1.参数：是一个整数，
> 2.参数的意义：在history记录中向前或向后多少步，类似`window.history.go(n)`;
```
router.go(1);             //在浏览器记录中前进一步，类似于'history.forward()'方法
router.go(-1);            //在浏览器记录中后退一步，类似于'history.back()'方法
router.go(3);             //在浏览器记录中前进三步
```

## 命名路由

1、命名路由
> 1.定义：通过一个名称标识一个路由；
> 2.在`routes.js`中配置路由时们可以给路由设置名称`name`;
```
{
  path: '/user/:userId',
  name: 'user',               //命名的标识
  component: User
}
```
> 3.在`router-link`中的to属性直接传一个对象
```
<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
```
> 4.在`router.push()`中使用
```
router.push({ name: 'user', params: { userId: 123 }})
```


## 命名视图

1、同级命名视图
> 1.同级展示多个视图，例如创建一个布局，有sidebar(侧导航)和main(主内容)；
> 2.在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。
> 3.如果`router-view`没有设置名字，那么默认为`default`。
> 4.多个视图，正确使用`components`配置，加上`s`；
```html
//在App.vue中
<template>
  <div id="app">
    <img src="./assets/logo.png">
    <router-view/>
    <router-view name="a"/>
    <router-view name="b"/>
  </div>
</template>
```
```js
{
  path: '/',
  name: '',
  components: {
    default: Login,     //匹配的组件
    a: HelloWorld,
    b: Home
  },
}
```

2、嵌套命名视图
> 1.创建嵌套视图的复杂布局，使用`router-view`；
```html
//在Login.vue中配置嵌套路由
<template>
  <div>
    <h1>{{msg}}</h1>

    <button @click="push1">helloWorld</button>

    <router-link to="home" tag="li">
      <a>homeLinkLiName</a>
    </router-link>

    <router-view class="default"/>
    <router-view name="helper" class="helper"/>
  </div>
</template>
```
```js
{
  path: '/',
  name: 'Login',
  component: Login,
  children: [
    {
      //'/home'路径下渲染Home组件
      path: 'home',
      name: 'home',
      component: Home,
    },
    {
      path:'hello',
      name:'',
      components:{
        default: Home,
        helper: HelloWorld
      }
    }
  ]
}
```
```
export default {
  name: "Login",
  data() {
    return {
      msg: '你好',
    }
  },
  methods: {
    push1() {
      this.$router.push('hello');
    }
  }
}
```

## 重定向和别名
1、重定向
> 1.把一个路径重定向为另一个路径，例如：`/a`重定向为`/b`;
```
{
  path: '/a',
  redirect: '/b'
}
```
> 2.重定向的目标也可以是一个命名的路由
```
{
  path:'/a',
  redirect: {name:'b'}
}
```
> 3.重定向的目标还可以是一个方法(不会)
```
{
  path:'/home',
  redirect: to=>{
    //方法接受 目标路由 作为参数
    //return 重定向的 字符串路径/路径对象
  }
}
```

2、别名——alias
> 1.作用：自由的将UI结构映射到任意的URL，而不受限于配置的嵌套路由结构；
> 2.举例：`/a`的别名是`/b`，意味着，用户访问`/b`时，URL会保持为`/b`，但是，路由匹配则为`/a`，就像用户访问`/a`一样；
```
//"/home"的别名是"/h"，则我们可以直接访问"/h"
{
  path: '/home',
  component: Home,
  alias:'/h'
}
```
```
<router-link to="h"></router-link>         //直接把to属性的值，设置为别名，同样可以访问'/home'路径下的组件，但是，URL还是'/h'
```
> 3.在嵌套路由中使用
```html
<button @click="push4">aliasHello</button>
```
```js
export default {
  name: "Login",
  methods: {
    push4(){
      this.$router.push('/b');     //这里可以直接访问URL为'/login/hello'中的内容
    }
  }
}
```
```js
{
  path: '/login',
  name: '',
  component: Login,
  children: [
    {
      //'/home'路径下渲染Home组件
      path: 'home',
      name: 'home',
      component: Home,
    },
    {
      path: 'hello',
      name: '',
      components: {
        default: Home,
        helper: HelloWorld
      },
      //原来的访问URL是'/login/hello'，现在的访问路径可以使用别名'/b'直接访问
      alias:'/b',
    }
  ]
}
```


## 路由组件传参

1、路由组件传参-布尔模式
> 1.在组件中使用`$route`会使之与其对应路由形成高度耦合，从而使得组件只能在某些特定的URL上使用，限制了其灵活性。
> 2.使用`props`，将组件和路由解耦。
```
{
  path: '/:id',
  component: Home,
  props: true,      //设置为 true，route.params 将会被设置为组件属性
}
```
```
export default {
  name: "Home",
  props:['id'],
}
```
```
<p>home:id:{{id}}</p>
```
> 2.对于包含命名视图的路由，必须分别为每个命名视图添加`props`属性；
```
{
  path: '/user/:id',
  components: { default: User, sidebar: Sidebar },
  props: { default: true, sidebar: false }
}
```

2、路由组件传参-对象模式
> 1.如果`props`是一个对象，它会被按原样设置为组件属性。当`props`是静态的时候有用。
```
{ path: '/promotion/from-newsletter', component: Promotion, props: { newsletterPopup: false } }
```

3、路由组件传参-函数模式
> 1. 创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等
```
//URL '/search?q=vue' 会将 {query: 'vue'} 作为属性传递给 SearchUser 组件
{ path: '/search', component: SearchUser, props: (route) => ({ query: route.query.q }) }
```


## History模式

1、hash模式
> 1.`vue-router`默认模式是hash模式；
> 2.hash模式，使用URL的hash来模拟一个完整的URL，当URL改变时，页面不会重新加载；
```
hash模式下的URL——"http://localhost:8080/#/"
```

2、History模式
> 1.URL比较正常，也好看
```
history模式下的URL——"http://localhost:8080/"
```
> 2.方法：
```
//创建router实例
const router = new Router({
  mode: 'history',               //定义history模式
  routes
});
```


## 导航守卫

1、导航守卫
> 1.作用：用来通过跳转或取消的方式守卫导航；

2、全局前置守卫
> 1.使用`router.beforeEach(to,from,next)`注册一个全局前置守卫；
> 2.当一个导航被触发时，全局前置守卫按照创建的顺序调用。守卫是异步执行的是，此时，导航在所有守卫resolve完之前一直处于**等待中**。
> 3.每个守卫方法接受三个参数：
> 1. `to:route`：即将要进入的目标
> 2. `from:route`：当前导航正要离开的路由
> 3. `next:function`：一定要调用该方法来resolve这个钩子。执行效果依赖`next`方法的调用参数
```
next()：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed(确认的)；
next(false)：中断当前的导航。如果浏览器的URL改变了(可能是用户手动或浏览器后退按钮)，那么URL地址会重置到from路由对应的地址；
next('/')或next({path:'/'})：跳转带一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向next传递任意位置对象，且允许设置诸如replace:true,name:'home'之类的选项以及任何用在router-link的to属性和router.push中的选项；
next(error)：如果传入的参数是一个Error实例，则导航会被终止且该错误会被传递给router.onError()注册过得回调；
```
> **注意：一定要调用next方法，否则钩子就不会被resolved**

2、全局解析守卫
> 1.`2.5.0版本`新增；
> 2.使用`router.beforeResolve`注册一个全局解析守卫，
> 3.与`router.beforeEach`类似，区别是，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。

3、全局后置钩子
> 1.全局后置钩子，与守卫不同的是，这些钩子不会接受`next`函数，也不会改变导航本身。
> 2.使用`router.afterEach(to,from)`注册全局后置钩子；

4、路由独享守卫
> 1.在路由配置上直接定义`beforeEnter`守卫；
> 2.参数与全局前置守卫的方法参数一致；
```
let routes = [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
```

5、组件内守卫
> 1.在组件内直接定义路由导航守卫；
```
beforeRouteEnter
beforeRouteUpdate(2.2新增)
beforeRouteLeave
```
> 2.beforeRouteEnter (to, from, next)
> 1. 在渲染该组件的对应路由被 confirm 前调用;
> 2. 不！能！获取组件实例 `this`，因为当守卫执行前，组件实例还没被创建;
> 3. 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
```
beforeRouteEnter (to, from, next) {
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
}
```
> **beforeRouteEnter是支持给 next 传递回调的唯一守卫，其他两个的`this`可用了，不支持传递回调，因为没有必要了。**
> 3.beforeRouteUpdate (to, from, next)
> 1. 在当前路由改变，但是该组件被复用时调用;
> 2. 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候;
> 3. 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
> 4. 可以访问组件实例 `this`
```HelloWorld.vue
export default {
  name: 'HelloWorld',
  watch:{
    '$route'(to,from){
      console.log('watch-to',to);
      console.log('watch-from',from);
    }
  },
  beforeRouteUpdate(to,from,next){
     // just use `this`
    this.name = to.params.name;
    next();

    console.log('beforeRouteUpdate-to',to);
    console.log('beforeRouteUpdate-from',from);
    console.log('beforeRouteUpdate-next',next);
  }
}
```
> 4.beforeRouteLeave (to, from , next)
> 1. 导航离开该组件的对应路由时调用;
> 2. 可以访问组件实例 `this`
> 3. 通常用来禁止用户在还未保存修改前突然离开，该导航可以通过 next(false) 来取消
```
beforeRouteLeave (to, from , next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
```

6、完整导航解析流程
> 1.导航被触发；
> 2.在失活的组件里调用离开守卫；
> 3.调用全局的`beforeEach`守卫；
> 4.在重用的组件里调用`beforeRouteUpdate`守卫；
> 5.在路由配置里调用`beforeEnter`守卫；
> 6.解析异步路由组件；
> 7.在被激活的组件里调用`beforeRouteEnter`守卫；
> 8.调用全局的`beforeResolve`守卫；
> 9.导航被确认；
> 10.调用全局后置钩子`afterEach`；
> 11.触发DOM更新；
> 12.用创建好的实例，调用`beforeRouteEnter`守卫传给next的回调函数。


## 路由元信息

1、路由元信息
> 1.定义路由的时候，配置`meta`字段；
```
{
    path: '/foo',
    component: Foo,
    children: [
      {
        path: 'bar',
        component: Bar,
        // a meta field
        meta: { requiresAuth: true }
      }
    ]
}
```
> 2.路由记录：在rotues中配置的每一个路由对象。路由记录是可以嵌套的，当一个路由匹配成功后，它可能会匹配多个路由记录；
> 3.例如，上面的配置，`/foo/bar`，这个URL将会匹配到父路由记录和子路由记录；
> 4.一个路由匹配到的所有路由记录会暴露为` $route` 对象 (还有在导航守卫中的路由对象) 的 `$route.matched` 数组；
> 5.因此，我们需要遍历 `$route.matched` 来检查路由记录中的 `meta` 字段。
```
//在全局导航守卫中检查元字段
router.beforeEach((to, from, next) => {
  if (to.matched.some(record => record.meta.requiresAuth)) {
    // this route requires auth, check if logged in
    // if not, redirect to login page.
    if (!auth.loggedIn()) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
  } else {
    next() // 确保一定要调用 next()
  }
})
```


## 过渡动效

1、过渡动效
> 1.用 `<transition>` 组件给它添加一些过渡效果;
```
<transition>
  <router-view/>
</transition>
```

2、单个路由的过渡
> 1.在各路由组件内使用 <transition> 并设置不同的 name;
```
<transition name="slide">
  <div class="foo">...</div>
</transition>

<transition name="fade">
  <div class="bar">...</div>
</transition>
```


3、基于路由的动态过渡
> 1.基于当前路由与目标路由的变化关系，动态设置过渡效果;
```html
<!-- 使用动态的 transition name -->
<transition :name="transitionName">
  <router-view></router-view>
</transition>
```
```js
// 接着在父组件内
// watch $route 决定使用哪种过渡
watch: {
  '$route' (to, from) {
    const toDepth = to.path.split('/').length
    const fromDepth = from.path.split('/').length
    this.transitionName = toDepth < fromDepth ? 'slide-right' : 'slide-left'
  }
}
```


## 数据获取

1、数据获取的方法
> 1.导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示；
> 2.导航完成之前获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航；

2、导航完成后获取数据
> 1.当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据;
> 2.让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态；
```html
//假设我们有一个 Post 组件，需要基于 $route.params.id 获取文章数据：
<template>
  <div class="post">
    <div class="loading" v-if="loading">
      Loading...
    </div>

    <div v-if="error" class="error">
      {{ error }}
    </div>

    <div v-if="post" class="content">
      <h2>{{ post.title }}</h2>
      <p>{{ post.body }}</p>
    </div>
  </div>
</template>
```
```js
export default {
  data () {
    return {
      loading: false,
      post: null,
      error: null
    }
  },
  created () {
    // 组件创建完后获取数据，
    // 此时 data 已经被 observed 了
    this.fetchData()
  },
  watch: {
    // 如果路由有变化，会再次执行该方法
    '$route': 'fetchData'
  },
  methods: {
    fetchData () {
      this.error = this.post = null
      this.loading = true
      // replace getPost with your data fetching util / API wrapper
      getPost(this.$route.params.id, (err, post) => {
        this.loading = false
        if (err) {
          this.error = err.toString()
        } else {
          this.post = post
        }
      })
    }
  }
}
```

3、在导航完成前获取数据
> 1.在导航转入新的路由前获取数据;
> 2.在接下来的组件的 beforeRouteEnter 守卫中获取数据，当数据获取成功后只调用 next 方法;
```js
export default {
  data () {
    return {
      post: null,
      error: null
    }
  },
  beforeRouteEnter (to, from, next) {
    getPost(to.params.id, (err, post) => {
      next(vm => vm.setData(err, post))
    })
  },
  // 路由改变前，组件就已经渲染完了
  // 逻辑稍稍不同
  beforeRouteUpdate (to, from, next) {
    this.post = null
    getPost(to.params.id, (err, post) => {
      this.setData(err, post)
      next()
    })
  },
  methods: {
    setData (err, post) {
      if (err) {
        this.error = err.toString()
      } else {
        this.post = post
      }
    }
  }
}
```


## 滚动行为

1、滚动行为
> 1.当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样;
> 2.vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动;
**注意: 这个功能只在支持 history.pushState 的浏览器中可用。**
```
const router = new Router({
  routes,
  scrollBehavior (to, from, savedPosition) {
    // return 期望滚动到哪个的位置
  }
})
```
> 3.scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用;
> 4.这个方法返回滚动位置的对象信息：
```
{ x: number, y: number }
{ selector: string, offset? : { x: number, y: number }} (offset 只在 2.6.0+ 支持)
```
> 5.如果返回一个 falsy (注：falsy 不是 false)，或者是一个空对象，那么不会发生滚动。
```
//不会发生滚动，页面在顶部
scrollBehavior (to, from, savedPosition) {
  return { x: 0, y: 0 }
}
```
> 6.模拟“滚动到锚点”的行为：
```
scrollBehavior (to, from, savedPosition) {
  if (to.hash) {
    return {
      selector: to.hash
    }
  }
}
```

2、异步滚动(2.8.0+)
> 1.可以返回一个 Promise 来得出预期的位置描述；
```
scrollBehavior (to, from, savedPosition) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({ x: 0, y: 0 })
    }, 500)
  })
}
```

## 路由懒加载

1、路由懒加载
> 1.当打包构建应用时，JavaScript 包会变得非常大，影响页面加载；
> 2.如果把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了；
> 3.首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：
```
const Foo = () => Promise.resolve({ /* 组件定义对象 */ })
```
> 4.然后，使用动态 import语法来定义代码分块点 (split point)：
```
import('./Foo.vue') // 返回 Promise
```
> 5.结合这两点：定义一个能够被 Webpack 自动代码分割的异步组件
```
const Foo = () => import('./Foo.vue')
```
```
routes: [
  {
    path: '/',
    component: resolve => require(['components/Hello.vue'], resolve)
  },
  {
      path: '/about',
      component: resolve => require(['components/About.vue'], resolve)
  }
]
---------------------
链接：https://www.cnblogs.com/lijuntao/p/7777581.html
```

2、把组件按组分块
> 1.把某个路由下的所有组件都打包在同个异步块 (chunk) 中；
> 2.只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)；
> 3.Webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中
```
const Foo = () => import(/* webpackChunkName: "group-foo" */ './Foo.vue')
const Bar = () => import(/* webpackChunkName: "group-foo" */ './Bar.vue')
const Baz = () => import(/* webpackChunkName: "group-foo" */ './Baz.vue')
```
```
//实际应用，还需要在webpack output加个chunkFilename
//添加：chunkFilename: '[name].js'
//在build文件下面的webpack.prod.conf.js中
routes: [
    {
        path: '/',
        name: 'Navigator',
        component: () => import(/* webpackChunkName: "navigator" */ './../components/Navigator')
    },
    {
        path: '/tucao',
        name: 'Tucao',
        component: () => import(/* webpackChunkName: "tucao" */ './../components/Tucao')
    }
]
链接：https://segmentfault.com/a/1190000012705647
```


## Vue 基础

1、Vue项目的目录结构
> 1.build:项目构建(webpack)相关代码；
> 2.config:配置目录，包括端口号等；
> 3.node_modules：npm加载的项目依赖模块；
> 4.src：主要开发的目录
> 1. assets：放置一些图片。如logo等
> 2. components：目录里面放了一个组件文件，可以不用；
> 3. App.vue：项目入口文件
> 4. main.js：项目核心文件；
```
```
> 5.static：静态资源文件，如字体，图标等
> 6.test：初始测试目录，可删除；
> 7..xxx文件：配置文件，包括语法配置，git配置等
> 8.index.html：首页入口文件，可以添加一些meta信息或统计代码的
> 9.package.json：项目配置文件
> 10.README.md：项目说明文档


1、Vue实例化
> 1.每个vue应用，都需要实例化Vue来实现
> 2.语法格式：
```
var vm = new Vue({
    //选项
})
```

2、Vue构造器中的参数
> 1.el参数：它是DOM元素中的id值；意味着只有id内部的元素会受影响；
```
<div id="vue-det"></div>
```
```
var vm = new Vue({
    el:'#vue-det'
})
```
> 2.data参数：用于定义属性；
> 3.methods参数：用于定义函数，可以通过return来返回函数值；
> 4.`{{ }}`：用于输出对象属性和函数返回值；
```html
<div id="vue-det">
	<h1>site:{{site}}</h1>
	<h1>url:{{url}}</h1>
	<h1>{{details}}</h1>
</div>
```
```js
var data = {site:"菜鸟教程",url:'www.baidu.com'};
	var vm = new Vue({
		el:'#vue-det',
		data:data
	})
```

3、Vue的数据属性
> 1.Vue实例和data属性石互相影响的；
```js
// 它们引用相同的对象！
document.write(vm.site === data.site) // true
document.write("<br>")
// 设置属性也会影响到原始数据
vm.site = "Runoob"
document.write(data.site + "<br>") // Runoob

// ……反之亦然
data.url = '1234'
document.write(vm.url) // '1234'
```

4、Vue的实例属性和方法
> 1.他们有前缀`$`，便于与用于定义的属性区分开来；
```js
document.write(vm.$data === data) // true
document.write("<br>")
document.write(vm.$el === document.getElementById('vue_det')) // true
```


1、vue模板语法
> 1.基于HTML的模板语法，允许开发者声明式的将DOM绑定至底层Vue实例的数据；
> 2.核心：允许采用简洁的模板语法来声明式的将数据渲染进DOM系统；
> 3.结合响应式系统，在引用状态改变时，能够只能计算出重新渲染组件的最小代价并应用到DOM操作上。

2、文本值
> 1.常见形式：使用双大括号`{{...}}`；
```
<div id="app">
	<p>{{message}}</p>
</div>
```

3、HTML值
> 1.使用`v-html`指令：输出html代码；
```html
<div id="app">
	<p v-html="message"></p>
</div>
```
```js
var vm = new Vue({
  el:'#app',
  data:{
      message:'<h1>HTML插值</h1>'
  }
});
```

4、属性值
> 1.使用`v-bind`指令，绑定属性值；
```html
//如果use为true，则使用class1类的样式
<div id="app">
	<p v-bind:class="{'class1':use}"></p>
</div>
//如果use为true，则使用class1类的样式
```

5、表达式
> 1.Vue.js提供了完全的JavaScript表达式支持；
```html
<div id="app">
	<p v-bind:id="'list-'+id"></p>
	{{5+5}}}<br>
	{{ok?'YES':'NO'}}<br>
	{{message.split('').reverse().join('')}}
</div>
```
```js
var vm = new Vue({
  el:'#app',
  data:{
    id:1,
    ok:true,
    message:'RUNOOB',
  }
});
```

6、指令
> 1.定义：带有`v-`前缀的特殊属性；
> 2.作用：用于在表达式值改变时，某些行为应用到DOM上

7、参数
> 1.参数在指令后用冒号指明

8、修饰符
> 1.以半角句号`.`指明的特殊后缀，用于一个指令应该以特殊方式绑定；
```html
//.prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault()方法
<form v-on:submit.prevent="onSubmit"></form>
```

9、用户输入
> 1.在input框中使用`v-model`指令来实行双向数据绑定；
> 2.`v-model`用来在input，select，text，checkbox，radio等表单控件上创建双向数据。根据表单上的值，自动更新绑定的元素的值
```html
<div id="app">
    <p>{{ message }}</p>
    <input v-model="message">
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    message: 'Runoob!'
  }
})
```

10、过滤器
> 1.允许自动以过滤器，用于一些常见的文本格式化。
> 2.过滤器函数，接受表达式的第一个值作为第一个参数；
```html
<div id="app">
  {{ message | capitalize }}
</div>
```
```js
var vm = new Vue({
    el: '#app',
    data: {
        message: 'runoob',
    },
    filters: {
        capitalize: function (value) {
            if (!value) return '';
            value = value.toString();
            return value.charAt(0).toUpperCase() + value.slice(1);
        }
    }
});
```
> 3.格式（由管道符指示）：
> 1. 在两个大括号中：
```
{{message|capitalize}}
```
> 2. 在`v-bind`指令中
```
<div v-bind:id="rawId|formatId"></div>
```


1、条件判断`v-if`
> 1.指令：`v-if`；
> 2.作用：根据条件判断的真假，来决定是否插入元素；
```html
<div id="app">
    <p v-if="seen">现在你看到我了</p>
    <template v-if="ok">
      <h1>菜鸟教程</h1>
      <p>学的不仅是技术，更是梦想！</p>
      <p>哈哈哈，打字辛苦啊！！！</p>
    </template>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    seen: true,
    ok: true
  }
})
```

2、条件判断`v-else`
> 1.`v-if`指令的一个else模块；
```html
<div id="app">
    <div v-if="Math.random() > 0.5">
      Sorry
    </div>
    <div v-else>
      Not sorry
    </div>
</div>
```
```js
new Vue({
  el: '#app'
})
```

3、条件判断`v-else-if`
> 1.在2.1.0新增，用作`v-if`的`v-else`块，可以多次使用；
```html
<div id="app">
    <div v-if="type === 'A'">
      A
    </div>
    <div v-else-if="type === 'B'">
      B
    </div>
    <div v-else-if="type === 'C'">
      C
    </div>
    <div v-else>
      Not A/B/C
    </div>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    type: 'C'
  }
})
```

4、`v-show`指令
> 1.根据条件展示元素
```html
<div id="app">
    <h1 v-show="ok">Hello!</h1>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    ok: true
  }
})
```


1、循环指令`v-for`
> 1.`v-for`需要以site in sites形式的特殊语法；
> 2.site是数组元素迭代的别名；
> 3.sites是源数据数组。
> 4.`v-for`可以绑定数据来渲染一个列表；
```html
<div id="app">
  <ul>
    <template v-for="site in sites">
      <li>{{ site.name }}</li>
      <li>--------------</li>
    </template>
  </ul>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    sites: [
      { name: 'Runoob' },
      { name: 'Google' },
      { name: 'Taobao' }
    ]
  }
})
```


2、`v-for`迭代对象
> 1.通过对象的属性来迭代数据；
```html
<div id="app">
  <ul>
    <li v-for="value in object">
    {{ value }}
    </li>
  </ul>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    object: {
      name: '菜鸟教程',
      url: 'http://www.runoob.com',
      slogan: '学的不仅是技术，更是梦想！'
    }
  }
})
```
> 2.提供第二个参数为键名
```html
<div id="app">
  <ul>
    <li v-for="(value, key) in object">    //这个顺序要注意
    {{ key }} : {{ value }}
    </li>
  </ul>
</div>
```
> 3.提供第三个参数为索引
```html
<div id="app">
  <ul>
    <li v-for="(value, key, index) in object">
     {{ index }}. {{ key }} : {{ value }}
    </li>
  </ul>
</div>
```

3、`v-for`迭代整数
```html
<div id="app">
  <ul>
    <li v-for="n in 10">
     {{ n }}
    </li>
  </ul>
</div>
```
```js
new Vue({
  el: '#app'
})
```


1、vue计算属性`computed`
> 1.计算属性在处理一些复杂逻辑时很有用；
```html
<div id="app">
  <p>原始字符串: {{ message }}</p>
  <p>计算后反转字符串: {{ reversedMessage }}</p>
</div>`
```
```
var vm = new Vue({
  el: '#app',
  data: {
    message: 'Runoob!'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

2、`methods`与`computed`
> 1.我们可以使用methods来替代computed，效果是一样的
> 2.但是，computed是基于它的依赖缓存，只有相关缓存发生改变时才会重新获取值；
> 3.而，methods。在重新渲染时，函数总会执行调用。


3、`computed`的getter和setter
> 1.computed属性，默认只有getter，不过可以自己提供一个setter；
```html
<div id="app">
  <p>{{ site }}</p>
</div>
```
```js
var vm = new Vue({
  el: '#app',
  data: {
	name: 'Google',
	url: 'http://www.google.com'
  },
  computed: {
    site: {
      // getter
      get: function () {
        return this.name + ' ' + this.url
      },
      // setter
      set: function (newValue) {
        var names = newValue.split(' ')
        this.name = names[0]
        this.url = names[names.length - 1]
      }
    }
  }
})
// 调用 setter， vm.name 和 vm.url 也会被对应更新
vm.site = '菜鸟教程 http://www.runoob.com';
document.write('name: ' + vm.name);
document.write('<br>');
document.write('url: ' + vm.url);
```

1、vue监听属性——watch
> 1.通过watch来响应数据的变化；
```html
<div id = "app">
 <p style = "font-size:25px;">计数器: {{ counter }}</p>
 <button @click = "counter++" style = "font-size:25px;">点我</button>
</div>
```
```js
var vm = new Vue({
   el: '#app',
   data: {
      counter: 1
   }
});
vm.$watch('counter', function(nval, oval) {
   alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');
});
```


1、样式绑定
> 1.使用`v-bind`来设置样式属性；
> 2.Vue在使用`v-bind`处理class和style时，增强了它。
> 3.表达式的结果类型除了字符串之外，还可以是对象或数组；
```html
<div id="app">
  <div v-bind:class="{ active: isActive }"></div>
</div>
```
```css
.active {
	width: 100px;
	height: 100px;
	background: green;
}
```
```js
new Vue({
  el: '#app',
  data: {
    isActive: true
  }
})
```
> 4.传入更过属性用来动态切换多个class
```html
<div id="app">
  <div v-bind:class="{ 'active': isActive, 'text-danger': hasError }">
  </div>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    isActive: true,
	  hasError: true
  }
})
```

2、数组绑定
> 1.给`v-bind:class`传入一个数组；
```html
<div id="app">
	<div v-bind:class="[activeClass, errorClass]"></div>
</div>
```
```css
.active {
	width: 100px;
	height: 100px;
	background: green;
}
.text-danger {
	background: red;
}
```
```js
new Vue({
  el: '#app',
  data: {
    activeClass: 'active',
    errorClass: 'text-danger'
  }
})
```

3、内联样式绑定
> 1.使用`v-bind:style`，直接设置样式；
```html
<div id="app">
	<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }">菜鸟教程</div>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    activeColor: 'green',
	  fontSize: 30
  }
})
```


1、事件监听——直接绑定事件
> 1.使用`v-on`指令；
> 2.接受一个定义的方法来调用，直接绑定；
```html
<div id="app">
   <!-- `greet` 是在下面定义的方法名 -->
  <button v-on:click="greet">Greet</button>
</div>
```
```js
var app = new Vue({
  el: '#app',
  data: {
    name: 'Vue.js'
  },
  // 在 `methods` 对象中定义方法
  methods: {
    greet: function (event) {
      // `this` 在方法里指当前 Vue 实例
      alert('Hello ' + this.name + '!')
      // `event` 是原生 DOM 事件
	  if (event) {
		  alert(event.target.tagName)
	  }
    }
  }
})
```

2、内联javascript语句绑定方法
```html
<div id="app">
  <button v-on:click="say('hi')">Say hi</button>
  <button v-on:click="say('what')">Say what</button>
</div>
```
```js
new Vue({
  el: '#app',
  methods: {
    say: function (message) {
      alert(message)
    }
  }
})
```

3、事件修饰符
> 1.描述：由(.)表示的指令后缀来调用修饰符

|值|描述|
|---|---|
|.stop|阻止单击事件冒泡|
|.prevent|提交事件不再重载页面|
|.capture|添加事件监听器时使用捕获模式|
|.self|只当事件在该元素本身(而不是子元素)触发时回调|
|.once|click事件只能点击一次|

4、按键修饰符
> 1.允许为 v-on 在监听键盘事件时添加按键修饰符
```
<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
<input v-on:keyup.13="submit">
```
> 2.记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：
```
<!-- 同上 -->
<input v-on:keyup.enter="submit">
<!-- 缩写语法 -->
<input @keyup.enter="submit">
```

|值|描述|
|---|---|
|.enter||
|.tab||
|.delete||
|.esc||
|.space||
|.up||
|.down||
|.left||
|.right||
|.ctrl||
|.alt||
|.shift||
|.meta||


1、表单应用
> 1.使用`v-model`实现双向数据绑定；

2、输入框
```html
<div id="app">
  <p>input 元素：</p>
  <input v-model="message" placeholder="编辑我……">
  <p>消息是: {{ message }}</p>

  <p>textarea 元素：</p>
  <p style="white-space: pre">{{ message2 }}</p>
  <textarea v-model="message2" placeholder="多行文本输入……"></textarea>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
    message: 'Runoob',
	  message2: '菜鸟教程\r\nhttp://www.runoob.com'
  }
})
```

3、复选框
```html
<div id="app">
  <p>单个复选框：</p>
  <input type="checkbox" id="checkbox" v-model="checked">
  <label for="checkbox">{{ checked }}</label>

  <p>多个复选框：</p>
  <input type="checkbox" id="runoob" value="Runoob" v-model="checkedNames">
  <label for="runoob">Runoob</label>
  <input type="checkbox" id="google" value="Google" v-model="checkedNames">
  <label for="google">Google</label>
  <input type="checkbox" id="taobao" value="Taobao" v-model="checkedNames">
  <label for="taobao">taobao</label>
  <br>
  <span>选择的值为: {{ checkedNames }}</span>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
	checked : false,
    checkedNames: []
  }
})
```

4、单选按钮
```html
<div id="app">
  <input type="radio" id="runoob" value="Runoob" v-model="picked">
  <label for="runoob">Runoob</label>
  <br>
  <input type="radio" id="google" value="Google" v-model="picked">
  <label for="google">Google</label>
  <br>
  <span>选中值为: {{ picked }}</span>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
	picked : 'Runoob'
  }
})
```

5、select列表
```html
<div id="app">
  <select v-model="selected" name="fruit">
    <option value="">选择一个网站</option>
    <option value="www.runoob.com">Runoob</option>
    <option value="www.google.com">Google</option>
  </select>

  <div id="output">
      选择的网站是: {{selected}}
  </div>
</div>
```
```js
new Vue({
  el: '#app',
  data: {
	selected: ''
  }
})
```

6、`v-model`中的修饰符
> 1.`.lazy`：转变为在change事件中同步；
```html
<input v-model.lazy="msg" >
```
> 2.`.number`：将输入的值Number值（如果原值的转换结果为NaN，则返回原值）
```html
<input v-model.number="age" type="number">
```
> 3.`.trim`：自动过滤用户输入的首尾空格；
```html
<input v-model.trim="msg">
```


1、组件Component
> 1.作用：可以扩展HTML元素，封装可重用的代码；
> 2.组件系统让我们可以独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树；
> 3.注册全局组件的语法：
> 1. tagName为组件名；
> 2. options为配置选项；
```js
Vue.component(tagName,options)
```
> 3. 注册完成后调用组件的方法：
```html
<tagName><tagName>
```

2、全局组件实例
> 1.创建一个全局组件runoob；
```html
<div id="app">
	<runoob></runoob>
</div>
```
```js
// 注册
Vue.component('runoob', {
  template: '<h1>自定义组件!</h1>'
})
// 创建根实例
new Vue({
  el: '#app'
})
```

3、局部组件
> 1.组件只能在这个实例中使用
```html
<div id="app">
	<runoob></runoob>
</div>
```
```js
var Child = {
  template: '<h1>自定义组件!</h1>'
}

// 创建根实例
new Vue({
  el: '#app',
  components: {
    // <runoob> 将只在父模板可用
    'runoob': Child
  }
})
```

4、prop属性
> 1.prop是父组件用来传递数据的一个自定义属性；
> 2.父组件通过props把数据传递给子组件，子组件需要显式地用props选项声明"prop"；
```html
<div id="app">
	<child message="hello!"></child>
</div>
```
```js
// 注册
Vue.component('child', {
  // 声明 props
  props: ['message'],
  // 同样也可以在 vm 实例中像 “this.message” 这样使用
  template: '<span>{{ message }}</span>'
})
// 创建根实例
new Vue({
  el: '#app'
})
```

5、动态prop
> 1.类似用`v-bind`绑定HTML特性到一个表达式，
> 2.也可以用`v-bind`动态绑定props的值到父组件的数据中；
> 3.每当父组件的数据变化时，该变化也会传导给子组件；
```html
<div id="app">
	<div>
	  <input v-model="parentMsg">
	  <br>
	  <child v-bind:message="parentMsg"></child>
	</div>
</div>
```
```js
// 注册
Vue.component('child', {
  // 声明 props
  props: ['message'],
  // 同样也可以在 vm 实例中像 “this.message” 这样使用
  template: '<span>{{ message }}</span>'
})
// 创建根实例
new Vue({
  el: '#app',
  data: {
	parentMsg: '父组件内容'
  }
})
```

6、自定义事件
> 1.父组件是使用props传递数据给子组件；
> 2.但是，如果子组件要把数据传递回去，就需要使用自定义事件；
> 3.可以使用`v-on`绑定自定义事件，每个Vue实例都实现了事件接口(Events interface)，即：
> 1. 使用`$on(eventName)`监听事件；
> 2. 使用`$emit(eventName)`触发事件；
```html
<div id="app">
	<div id="counter-event-example">
	  <p>{{ total }}</p>
	  <button-counter v-on:increment="incrementTotal"></button-counter>
	  <button-counter v-on:increment="incrementTotal"></button-counter>
	</div>
</div>
```
```js
Vue.component('button-counter', {
  template: '<button v-on:click="incrementHandler">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    incrementHandler: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})


new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
```

7、`.native`修饰符
> 1.作用：在某个组件的根元素上监听原生事件；

1、注册全局指令
> 1.语法：
```js
Vue.directive(tagName,options)
```
```html
<div id="app">
	<p>页面载入时，input 元素自动获取焦点：</p>
	<input v-focus>
</div>
```
```js
// 注册一个全局自定义指令 v-focus
Vue.directive('focus', {
  // 当绑定元素插入到 DOM 中。
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
// 创建根实例
new Vue({
  el: '#app'
})
```

2、注册局部指令
> 1.语法：使用directives选项来注册；
```html
<div id="app">
  <p>页面载入时，input 元素自动获取焦点：</p>
  <input v-focus>
</div>
```
```js
// 创建根实例
new Vue({
  el: '#app',
  directives: {
    // 注册一个局部的自定义指令 v-focus
    focus: {
      // 指令的定义
      inserted: function (el) {
        // 聚焦元素
        el.focus()
      }
    }
  }
})
```

3、钩子函数
> 1.bind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作；
> 2.inserted：被绑定元素插入父节点时嗲用(父节点存在即可调用，不必存在于document中)
> 3.update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的值，可以忽略不必要的模板更新；
> 4.componentUpdated：被绑定元素所在模板完成一次更新周期时调用；
> 5.unbind：只调用一次，指令与元素解绑时调用；

4、钩子函数参数
> 1.el：指令所绑定的元素，可以用来直接操作DOM
> 2.binding：
```
name：指令名，不包括v-前缀；
value：指令的绑定值
oldValue：指令绑定的前一个值，仅在update和componentUpdated钩子中可用。无论值是否改变都可用；
expression：绑定值得表达式或变量名
arg：传给指令的参数
modifiers：一个包含修饰符的对象
```
> 3.vnode：Vue编译生成的虚拟节点；
> 4.oldVnode：上一个虚拟节点，仅在update和componentUpdated钩子中使用；
```html
<div id="app"  v-runoob:hello.a.b="message">
</div>
```
```js
Vue.directive('runoob', {
  bind: function (el, binding, vnode) {
    var s = JSON.stringify
    el.innerHTML =
      'name: '       + s(binding.name) + '<br>' +
      'value: '      + s(binding.value) + '<br>' +
      'expression: ' + s(binding.expression) + '<br>' +
      'argument: '   + s(binding.arg) + '<br>' +
      'modifiers: '  + s(binding.modifiers) + '<br>' +
      'vnode keys: ' + Object.keys(vnode).join(', ')
  }
})
new Vue({
  el: '#app',
  data: {
    message: '菜鸟教程!'
  }
})
```


1、路由
> 1.允许我们通过不同的URL访问不同的内容；
> 2.需要载入`vue-router`库；


1、过渡
> 1.Vue在插入、更新或者移除DOM时，提供多种不同方式的应用的过渡效果；
> 2.Vue提供了内置的过渡封装组件，该组件用于包裹要实现过渡效果的组件；
> 3.语法格式：
```
<transition name="fade">
  <div></div>
</transition>
```
> 4.过渡本质是一个淡入淡出的效果。Vue在元素显示与隐藏的过程中，提供了6个class来切换；
> 1. v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除；
> 2. v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡或动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。
> 3. v-enter-to：**2.1.8版本及以上**，定义进入过渡的结束状态。在元素被插入之后下一帧生效(与此同时，v-enter被移除)，在过渡或动画完成之后移除；
> 4. v-leave：定义离开果醋的开始状态。在离开过渡被触发时立即生效，下一帧被移除；
> 5. v-leave-active：定义离开过渡生效的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立即生效，在过渡或动画完成之后移除。这个类可以用来定义离开过渡的过程时间，延迟和曲线函数；
> 6. v-leave-to：**2.1.8版本及以上**，定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效(与此同时，v-leave被移除)，在过渡或动画完成之后移除；


2、css过渡
> 1.通常使用css过渡来实现效果；
```html
<div id = "databinding">
  <button v-on:click = "show = !show">点我</button>
  <transition name="slide-fade">
    <p v-if="show">菜鸟教程</p>
  </transition>
</div>
```
```js
new Vue({
    el: '#databinding',
    data: {
        show: true
    }
})
```
```css
/* 可以设置不同的进入和离开动画 */
/* 设置持续时间和动画函数 */
.slide-fade-enter-active {
  transition: all .9s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-to
/* .slide-fade-leave-active 用于 2.1.8 以下版本 */ {
  transform: translateX(10px);
  opacity: 0;
}
```

3、css动画
> 1.css动画类似css过渡，但是在动画中`v-enter`类名，在节点插入DOM之后不会立即删除，而是在animationend事件触发时删除；
```html
<div id = "databinding">
  <button v-on:click = "show = !show">点我</button>
  <transition name="slide-fade">
    <p v-if="show">菜鸟教程</p>
  </transition>
</div>
```
```js
new Vue({
    el: '#databinding',
    data: {
        show: true
    }
})
```
```css
.bounce-enter-active {
  animation: bounce-in .5s;
}
.bounce-leave-active {
  animation: bounce-in .5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.5);
  }
  100% {
    transform: scale(1);
  }
}
```

4、自定义过渡的类名
> 1.通过以下特性来自定义过渡类名
```
enter-class
enter-active-class
enter-to-class
leave-class
leave-active-class
leave-to-class
```
> 2.自定义过渡的类名优先级高于普通的类名；
```html
<div id = "databinding">
  <button v-on:click = "show = !show">点我</button>
  <transition
    enter-active-class="animated tada"
    leave-active-class="animated bounceOutRight"
  >
    <p v-if="show">菜鸟教程 -- 学的不仅是技术，更是梦想！！！</p>
  </transition>
</div>
```
```js
new Vue({
    el: '#databinding',
    data: {
        show: true
    }
})
```

5、同时使用过渡和动画
> 1.Vue为了知道过渡的完成，必须设置相应的事件监听器。它可以是transitionend和animationend，这取决于给元素应用的CSS规则。如果使用其中一种，Vue能够自动识别类型并设置监听；
> 2.但是，在某个场景中，给同一个元素同时设置了两种过渡效果，比如animation很快的被触发完成了，而transition效果还没有结束。
> 3.此时，需要使用type特性并设置animation或transition来明确声明你需要Vue监听的类型。


6、显性的过渡持续时间
> 1.在很多情况下，Vue可以自动得出过渡效果的完成时机。
> 2.默认情况下，Vue会等待其在过渡效果的根元素的第一个transitionend或animationend时间。
> 3.也可以不这样设定，可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡时间；
> 4.这时，可以用`<transition>`组件上的duration属性定制一个显性的过渡时间(以毫秒计)；
```
<transition :duration="1000">...</transition>
```
> 5.也可以定制进入和移除的持续时间
```
<transition :duration="{enter:500,leave:800}">...</transition>
```

7、初始渲染的过渡
> 1.通过`appear`特性设置节点在初始渲染的过渡；
```
<transiton appear>
//.....
</transiton>
```
> 2.自定义CSS类名
```html
<transition
  appear
  appear-class="custom-appear-class"
  appear-to-class="custom-appear-to-class" (2.1.8+)
  appear-active-class="custom-appear-active-class"
>
  <!-- ... -->
</transition>
```

8、多个元素的过渡
> 1.可以设置多个元素的过渡，一般列表与描述；
> 2.需要注意：当有相同标签名的元素切换时，需要通过key特性设置唯一的值来标记，以让Vue区分它们，否则Vue为了效率只会替换相同标签内部的内容；
```html
<transition>
  <button v-if="isEditing" key="save">
    Save
  </button>
  <button v-else key="edit">
    Edit
  </button>
</transition>
```
```html
<transition>
  <button v-bind:key="isEditing">
    {{ isEditing ? 'Save' : 'Edit' }}
  </button>
</transition>
```


## Vuex

1、什么是Vuex
> 1.Vuex是一个专门为Vue.js应用程序开发的状态管理模式。
> 2.它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

2、什么是"状态管理模式"
> 1.包括三个部分:
> 1. `state`：驱动应用的数据源；
> 2. `view`：以声明方式将state映射到视图；
> 3. `actions`：响应在view上的用户输入导致的状态变化；
> 4. 这三个部分组成了单向数据流：
```
actions--->state--->view--->action
```

3、当应用遇到多个组件共享状态时，单向数据流很容易破坏
> 1.原因：
> 1. 多个视图依赖同一个状态；
> 2. 来自不同视图的行为需要变更同一状态；

4、什么时候使用Vuex
> 1.Vuex可以帮助我们管理共享状态，并附带了更多的概念和框架。
> 2.如果不打算开发大型单页应用，使用Vuex可能是冗余的；
> 3.如果应用够简单，最好不好使用Vuex。

5、Vuex应用核心
> 1.核心：store(仓库)。"store基本是一个容器，它包含着你的应用中大部分的状态(state)"。
> 2.Vuex和单纯的全局对象的不同点：
> 1. Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效的更新；
> 2. 不能直接的改变store中的状态。改变store状态的唯一途径就是显示的提交(commit)mutation。这样，使得我们可以方便的跟踪每一个状态的变化。

6、项目中使用Vuex的具体步骤
> 1.在项目中使用`cnpm install vuex --save`安装vuex模块；
> 1.在项目的，src文件夹中，新建一个文件夹（命名为store），用来存放store的操作；
> 2.在store文件夹下新建一个store.js文件，主要进行store的初始配置；
```
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex);

let store = new Vuex.Store({
    state: {
    num: 5,
  },
});

export default store;
```
> 3.在项目起始配置文件main.js中，新建的router实例中引入之前创建的store实例
```
import Vue from 'vue'
import App from './App'
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
import VueRouter from 'vue-router'
import routes from './routes'
import Vuex from 'vuex'
import store from'./store/store'     //引入store实例

Vue.use(ElementUI);
Vue.use(VueRouter);
Vue.use(Vuex);

//创建router实例
const router = new VueRouter({
  mode: 'history',
  routes,
  store,                  //引入store实例，以便于在以后的各个子组件中，都能使用this.$store来访问store实例
});
```
> 4.在子组件中访问store实例中的值，要在`computed`属性中；
```
<template>
  <div>
    //这里会输出"5"
    <p>state:{{count}}</p>
  </div>
</template>
```
```
export default {
  name: "Page5",
  computed: {
    count() {
      return this.$store.state.num;
    }
}
```


1、单一状态树
> 1.定义用一个对象就包含了全部的应用层级状态；至此它便作为一个“唯一数据源 (SSOT)”而存在。
> 2.这也意味着，每个应用将仅仅包含一个 store 实例。
> 3.单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。

2、在 Vue 组件中获得 Vuex 状态
> 1.Vuex 的状态存储是响应式的，
> 2.从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态
```
// 创建一个 Counter 组件，子组件中返回store实例的state里面的值
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
```
> 3.每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM；
> 4.但是，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态；
> 5.Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）；
```
const app = new Vue({
  el: '#app',
  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件，在main.js文件中配置
  store
})
```
> 6.通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。
```
//在子组件中通过this.$store访问store实例
export default {
  computed: {
    count () {
      return this.$store.state.count;
    }
  }
}
```

3、mapState 辅助函数
> 1.当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余；
> 2.为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键；
```
// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state => state.count,

    // 传字符串参数 'count' 等同于 `state => state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}
```
> 3.当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组；
```
computed: mapState([
  // 映射 this.count 为 store.state.count
  'count'
])
```

4、对象展开运算符
> 1.mapState 函数返回的是一个对象；
> 2.为了将它与局部计算属性混合使用，需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。
> 3.对象展开符：`...`，用三个点号表示；
```
computed: {
  localComputed () { /* ... */ },
  // 使用对象展开运算符将此对象混入到外部对象中
  ...mapState({
    // ...
  })
}
```

5、组件仍然保有局部状态
> 1.使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。
> 2.虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观；
> 3.如果有些状态严格属于单个组件，最好还是作为组件的局部状态；
> 4.应该根据你的应用开发需要进行权衡和确定。


1、getter
> 1.vuex允许在'store'实例中定义getter(类似于store的计算属性)；
> 2.就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变时，才会被重新计算；
```js
let store = new Vuex.Store({
  state: {
    num: 5,
  },
  getters: {
    changeNum(state) {
      return state.num++;
    }
  },
});
```

2、访问getter——属性访问
> 1.以属性的形式访问值——`store.getters`对象；
```js
export default {
  name: "Page5",

  computed: {
    getterNum(){
      return this.$store.getters.changeNum;
    }
  },
}
```

3、getter中传参——方法访问
> 1.通过让getter返回一个函数，来实现给getter传参；
> 2.在对store中的数组进行查询时非常有用。
```js
let store = new Vuex.Store({
  state: {
    num: 5,
    todos: [
      {
        id: 1, text: 'hello'
      },
      {
        id: 2, text: 'world'
      }
    ]
  },
  getters: {
    changeCount(state) {
      return state.num++;
    },
    getId: state => id => {
      return state.todos.find(todo => todo.id === id)
    }
  }
});
```
```js
computed: {
  count() {
    return this.$store.state.num;
  },
  getterNum(){
    return this.$store.getters.changeCount;
  },
  getId(){
    return this.$store.getters.getId(2);  //'{id: 2, text: 'world'}'
  }
},
```

4、传入第二个参数getters——指的是store中的getter中的所有方法
```js
state: {
  num: 5,
},
getters: {
  changeCount(state) {
    return state.num++;
  },
  getCounts(state, getters) {
    //这里的getters参数指向整个getters对象
    return state.num + getters.changeCount;
  }
},
```
```js
computed: {
  count() {
    return this.$store.state.num;              //6
  },
  getterNum(){
    return this.$store.getters.changeCount;    //5
  },
  getterNums(){
    return this.$store.getters.getCounts;      //11
  },
},
```

5、mapGetters辅助函数
> 1.`mapGetters`辅助函数仅仅是将store中的getter映射到局部计算属性；
```js
import {mapGetters} from 'vuex'

computed: {
  ...mapGetters({
    getMapId:'getId',
  })
},
```
```html
<p>getMapId:{{getMapId(1)}}</p>      //'{ "id": 1, "text": "hello" }'
```


1、Mutation
> 1.用途：更新vuex中的store里面的state；
> 2.Mutation非常类似于事件：每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)。
> 3.这个回调函数就是进行状态更改的地方，并且会接受state作为第一个参数。
```
let store = new Vuex.Store({
  state: {
    num: 5,
  mutations: {
    eventCount(state) {
      //变更状态
      state.num -= 1;
    }
  },
});
```
> 4.不能直接调用`mutation.handler`。这个选项更像是一个事件注册。
> 5.当触发一个`eventCount`的mutation时，调用此函数；
> 6.唤醒mutation handler，需要以相应的type调用`store.commit()`方法；
```
//在组件的methods方法中，唤醒handler
methods: {
  eventCount() {
    this.$store.commit('eventCount');
  }
}
```

2、提交载荷(Playload)
> 1.定义：可以向`store.commit`传入额外的参数，即为mutation的载荷(playload)；
```js
mutations: {
  eventCount(state, temp) {
    state.num += temp;
  }
},
```
```js
methods: {
  eventCount() {
    this.$store.commit('eventCount',5);
  }
}
```
```html
<button @click="eventCount">eventCount mutation:</button>
```
> 2.在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的mutation会更易读
```js
mutations: {
  eventCount(state, playload) {
    state.num += playload.temp;
  }
},
```
```js
methods: {
  eventCount() {
    this.$store.commit('eventCount',{temp:10});
  }
}
```

3、对象风格的提交方式
> 1.提交mutation的另一种方式，直接使用包含type属性的对象；
```js
methods: {
  eventCount() {
    this.$store.commit({
      type:'eventCount',
      temp:5
    })
  }
}
```

4、Mutation需要遵循Vue的响应规则
> 1.Vuex中的状态是响应性的，当我们变更状态时，监视状态的Vue组件也会自动更新。
> 2.这就意味着，Vuex中的mutation需要遵循一些规则：
> 3.最好提前在你的store中初始化好所有所需属性。
> 4.当需要在对象上添加新属性时，使用：
> 1. `Vue.set(obj,'newProp',123)`，或者
> 2. 以新对象替换老对象。例如，
```
state.obj = { ...state.obj, newProp:123 }
```

5、使用常量代替Mutation事件类型
> 1.使用常量替代mutation事件类型在各种Flux实现中是很常见的模式。
> 2.这样，可以使得linter之类的工具发挥作用；
> 3.同时，把这些常量放在单独的文件中可以让你的代码合作者对整个app包含的mutation一目了然。
```js
// mutation-types.js
export const SOME_MUTATION = 'SOME_MUTATION'
```
```js
// store.js
import Vuex from 'vuex'
import { SOME_MUTATION } from './mutation-types'

const store = new Vuex.Store({
  state: { ... },
  mutations: {
    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名
    [SOME_MUTATION] (state) {
      // mutate state
    }
  }
})
```

6、Mutation必须是同步函数
>

7、提交Mutation
> 1.在组件中提交`this.$store.commit('')`；
> 2.使用`mapMutations`辅助函数将组件中的methods映射为`store.commit`调用
```js
import { mapMutations } from 'vuex'

export default {
  // ...
  methods: {
    ...mapMutations([
      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`

      // `mapMutations` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`
    ]),
    ...mapMutations({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`
    })
  }
}
```
> 3.


1、Action
> 1.类似于mutation，不同之处在于：
> 2.Action提交的是mutation，而不是直接变更状态；
> 3.Action可以包含任意异步操作。
> 4.Action函数接受一个与store实例具有相同方法和属性的context对象，可以调用`context.commit()`提交一个mutation，或者
> 5.通过`context.state`和`context.getters`啦获取state和getters。
```js
mutations: {
  eventCount(state, playload) {
    state.num += playload.temp;
  }
},
actions: {
  eventAction (context) {
    context.commit('eventCount',{temp:2});
  }
}
```
```js
//需要调用多次commit方法时，用ES的参数解构，简化为
actions: {
  eventAction ({ commit }) {
    commit('eventCount')
  }
}
```

2、分发Action
> 1.Action通过`store.dispatch()`方法触发
```
store.dispatch('eventAction');
```
```js
mutations: {
  eventCount(state, playload) {
    state.num += playload.temp;
  }
},
actions: {
  eventAction (context) {
    context.commit('eventCount',{temp:2});
  }
}
```
```js
//在子组件中调用该方法
methods: {
  eventAction(){
    this.$store.dispatch('eventAction');
  }
}
```
```html
<button @click="eventAction">eventAction 同步Action:</button>
```
> 2.因为mutation必须同步执行，而action不受约束，可以在action内部执行异步操作
```js
mutations: {
  eventCount(state, playload) {
    state.num += playload.temp;
  }
},
actions: {
  //同步action
  eventAction(context) {
    context.commit('eventCount', {temp: 2});
  },
  //异步action,延迟一秒之后进行计算
  eventAsync({commit}) {
    setTimeout(() => {
      commit('eventCount', {temp: 5});
    },1000)
  }
}
```
```js
methods: {
  eventAction(){
    this.$store.dispatch('eventAction');
  },
  eventAsync(){
    this.$store.dispatch('eventAsync');
  }
},
```
```html
<button @click="eventAsync">eventAsync 异步Action:</button>
```

3、载荷分发和对象分发(未用到)
```
// 以载荷形式分发
store.dispatch('incrementAsync', {
  amount: 10
})

// 以对象形式分发
store.dispatch({
  type: 'incrementAsync',
  amount: 10
})
```

4、在组件中分发Action
> 1.方法一：`this.$store.dispatch('xxx')`分发action;
> 2.方法二：使用`mapActions`辅助函数将组件的methods映射为`store.dispatch`调用（需要在根节点注入store实例）
```js
import { mapActions } from 'vuex'

export default {
  // ...
  methods: {
    ...mapActions([
      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`

      // `mapActions` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
    ]),
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
  }
}
```

5、组合Action
> 1.Action通常是异步的，通过组合Action来解决多个异步action何时结束的问题；
> 2.`store.dispatch`可以处理被触发的action的处理函数返回的Promise，并且`store.dispatch`仍旧返回Promise；


1、Module-模块化
> 1.由于使用单一状态树，应用的所有状态会集中到一个比较大的对象中。
> 2.当应用变得非常复杂时，store对象就有可能变得非常臃肿。
> 3.为了解决这个问题，Vuex允许将store分割成模块(module)。
> 4.每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块——从上至下进行同样方式的分割；
```js
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

2、模块的局部状态
> 1.对于模块内的mutation和getter，接受的第一个参数是模块的局部状态对象；
```js
const moduleA = {
  state: { count: 0 },
  mutations: {
    increment (state) {
      // 这里的 `state` 对象是模块的局部状态
      state.count++
    }
  },

  getters: {
    doubleCount (state) {
      return state.count * 2
    }
  }
}
```
> 2.同样，对于模块内的action，局部状态通过`context.state`暴露出来，根节点状态则为`context.rootState`；
```js
const moduleA = {
  // ...
  actions: {
    incrementIfOddOnRootSum ({ state, commit, rootState }) {
      if ((state.count + rootState.count) % 2 === 1) {
        commit('increment')
      }
    }
  }
}
```
> 3.对于模块内部的getter，根节点状态会作为第三个参数暴露出来;；
```js
const moduleA = {
  // ...
  getters: {
    sumWithRootCount (state, getters, rootState) {
      return state.count + rootState.count
    }
  }
}
```

3、命名空间——嵌套模块
> 1.默认情况下，模块内部的action，mutation和getter是注册在全局命名空间的，这样使得多个模块能够对同一mutation或action做出响应。
> 2.如果希望模块具有更好的封装和复用性，可以通过添加`namespace:true`的方式使其成为带命名空间的模块，
> 3.当模块被注册后，它所有的getter，action和mutation都会自动根据模块注册的路径调整命名。
```js
const store = new Vuex.Store({
  modules: {
    account: {
      namespaced: true,

      // 模块内容（module assets）
      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响
      getters: {
        isAdmin () { ... } // -> getters['account/isAdmin']
      },
      actions: {
        login () { ... } // -> dispatch('account/login')
      },
      mutations: {
        login () { ... } // -> commit('account/login')
      },

      // 嵌套模块
      modules: {
        // 继承父模块的命名空间
        myPage: {
          state: { ... },
          getters: {
            profile () { ... } // -> getters['account/profile']
          }
        },

        // 进一步嵌套命名空间
        posts: {
          namespaced: true,

          state: { ... },
          getters: {
            popular () { ... } // -> getters['account/posts/popular']
          }
        }
      }
    }
  }
})
```

4、在带命名空间的模块内访问全局内容
> 1.希望使用全局的state和getter，`rootState`和`rootGetter`会作为第三和第四个参数传入getter，也会通过`context`对象的属性传入action。
> 2.若要在全局命名空间内分发action或提交mutation，将`{root:true}`作为第三个参数传给`dispatch`或`commit`即可。
```js
modules: {
  foo: {
    namespaced: true,

    getters: {
      // 在这个模块的 getter 中，`getters` 被局部化了
      // 你可以使用 getter 的第四个参数来调用 `rootGetters`
      someGetter (state, getters, rootState, rootGetters) {
        getters.someOtherGetter // -> 'foo/someOtherGetter'
        rootGetters.someOtherGetter // -> 'someOtherGetter'
      },
      someOtherGetter: state => { ... }
    },

    actions: {
      // 在这个模块中， dispatch 和 commit 也被局部化了
      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit
      someAction ({ dispatch, commit, getters, rootGetters }) {
        getters.someGetter // -> 'foo/someGetter'
        rootGetters.someGetter // -> 'someGetter'

        dispatch('someOtherAction') // -> 'foo/someOtherAction'
        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'

        commit('someMutation') // -> 'foo/someMutation'
        commit('someMutation', null, { root: true }) // -> 'someMutation'
      },
      someOtherAction (ctx, payload) { ... }
    }
  }
}
```

5、在带命名空间的模块注册全局action
> 1.需要在带命名空间的模块内注册全局action，可以添加`root:true`，并将这个action的定义放在函数`handler`中。
```js
{
  actions: {
    someOtherAction ({dispatch}) {
      dispatch('someAction')
    }
  },
  modules: {
    foo: {
      namespaced: true,

      actions: {
        someAction: {
          root: true,
          handler (namespacedContext, payload) { ... } // -> 'someAction'
        }
      }
    }
  }
}
```

6、带命名空间的绑定函数
> 1.当使用`mapState`,`mapGetters`,`mapActions`和`mapMutations`这些函数来绑定带命名空间的模块时，写起来会比较复杂；
```js
computed: {
  ...mapState({
    a: state => state.some.nested.module.a,
    b: state => state.some.nested.module.b
  })
},
methods: {
  ...mapActions([
    'some/nested/module/foo', // -> this['some/nested/module/foo']()
    'some/nested/module/bar' // -> this['some/nested/module/bar']()
  ])
}
```
> 2.对于这种情况，可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有的绑定都会自动将该模块作为上下文。
```js
computed: {
  ...mapState('some/nested/module', {
    a: state => state.a,
    b: state => state.b
  })
},
methods: {
  ...mapActions('some/nested/module', [
    'foo', // -> this.foo()
    'bar' // -> this.bar()
  ])
}
```
> 3.而且，你可以通过使用`createNamespacedHelpers`创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数。
```js
import { createNamespacedHelpers } from 'vuex'

const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state => state.a,
      b: state => state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      'foo',
      'bar'
    ])
  }
}
```

7、插件开发的注意事项
> 1.如果插件提供了模块并允许用户将其添加到Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，可以通过插件的参数对象来允许用户指定空间名称；
```js
// 通过插件的参数对象得到空间名称
// 然后返回 Vuex 插件函数
export function createPlugin (options = {}) {
  return function (store) {
    // 把空间名字添加到插件模块的类型（type）中去
    const namespace = options.namespace || ''
    store.dispatch(namespace + 'pluginAction')
  }
}
```

8、模块动态注册
> 1.在store创建之后，可以使用`store.registerModule`方法注册模块；
```js
// 注册模块 `myModule`
store.registerModule('myModule', {
  // ...
})
// 注册嵌套模块 `nested/myModule`
store.registerModule(['nested', 'myModule'], {
  // ...
})
```
> 2.之后就可以通过`store.state.myModule`和`store.state.nested.myModule`访问模块的状态；
> 3.模块动态注册功能使得其他Vue插件可以通过在store中附加新模块的方式来实现Vuex管理状态。
> 4.例如，`vuex-router-sync`插件就是通过动态注册模块将vue-router和vuex结合在一起，实现应用的路由状态管理。
> 5.使用`store.unregisterModule(moduleName)`来动态卸载模块。注意，不能使用该方法卸载静态模块（即创建store时声明的模块）。

9、保留state
> 1.在注册一个新的module时，可能想保留过去的state，例如，从一个服务器端渲染的应用保留state。
> 2.可以通过`preserveState`选项将其归档：`store.registerModule('a',module,{preserveState:true})`
> 3.当设置`preserveState:true`时，该模块会被注册，action，mutation和getter会被添加到store中，但是state不会。

10、模块重用
> 1.需要创建一个模块的多个实例，例如：
> 1. 创建多个store，它们公用同一个模块(例如，`runInNewContext`选项时`false`或`once`时，为了在服务器端渲染中避免有状态的单例)；
> 2. 在一个store中多次注册同一个模块；
```
```
> 2.如果我们可以使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时store或模块间数据互相污染的问题；
> 3.实际上，这和Vue组件被的data是同样的问题。解决方法是——使用一个函数来声明模块状态(仅2.3.0+支持)
```js
const MyReusableModule = {
  state () {
    return {
      foo: 'bar'
    }
  },
  // mutation, action 和 getter 等等...
}
```


1、Vuex遵循的规则
> 1.应用层级的状态应该集中到单个store对象中；
> 2.提交mutation是更改状态的唯一方法，并且这个过程是同步的；
> 3.异步逻辑都应该封装带action里面；

2、项目结构
> 1.对于大型应用，store文件过大，只需将action，mutation和getter分割到单独的文件
```
├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块
```
