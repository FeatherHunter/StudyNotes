1、标识符
> 1.定义：指变量、函数、属性的名字，或者函数的参数；
> 2.命名规则：
> 1. 第一个字符必须是字母、下划线或美元符号($)；
> 2. 其他字符可以是字母、下划线、美元符号和数字；
> 3. 格式：驼峰式（首字母小写，其他大写），例如：firstName；

2、注释的方法：
> 1.单行注释：以两个斜杠开头（//）;
> 2.块级注释：以`/*`开头，以`*/`结尾；
>```
>/*
>*   多行注释
>*
>*/
>```

3、严格模式（strict mode）的作用：
> 1.ECMAScript3中的一些不确定的行为将得到处理；
> 2.对某些不安全的操作抛出异常；
> 3.使用方法：在脚本顶部添加`"use strict";`。
>```
>function doSomething()
>{
>  "use strict";
>  //函数体
>}
>```

4、语句结尾的分号可以省略么？
> 1.可以。省略分号，由解析器确定语句的结尾。
> 2.建议不省略，优点：
> 1. 避免错误（不完整的输入）；
> 2. 增加代码性能（解析器不必推测在哪里插入分号）。

5、变量
> 1.类型：松散类型；
> 2.松散类型：可以保存任何类型的数据；
> 3.变量定义：使用var操作符；

6、变量的初始值
> 1.未初始化变量，会保存特殊值-undefined；
> 2.初始化变量不会把它标记为固定类型，只是简单的赋值；
> 3.不建议修改变量所保存的值的类型，但是这样是有效的。
>```
>var message="hello";
>message=10;     //有效，但不推荐
>```

7、变量的作用域
> 1.使用var定义的变量是该变量作用域中的局部变量；
>```
>function test(){
>  var message="hi";  //局部变量，函数退出后变量被销毁
>}
>test();
>alert(message);    //错误！
>```
> 2.不用var操作符，创建的是全局变量
>```
>function test(){
>  message="hi";    //全局变量
>}
>test();
>alert(message);    //"hi"
>```

8、数据类型分类
> 1.基本数据类型：Undefined、Null、Boolean、Number和String；
> 2.复杂数据类型：Object-本质是由一组无序的名值对组成的

9、typeof操作符
> 1.作用：检测给定变量的数据类型
> 2.返回值：undefined，boolean，string，number，object和function。
> 3.typeof是一个操作符，而不是函数，因此不必使用圆括号。
>```
>var message={};
>var message=new Object();  //等价
>console.log(typeof message);  //message是Object类型，它的值是{object Object}，返回的类型是object
>```

10、Undefined类型
> 1.使用var声明的变量未初始化时，这个变量的值就是undefined；
> 2.未初始化的变量执行typeof会返回undefined；
> 3.未声明的变量执行typeof会返回undefined。
>```
>var age;
>console.log(typeof age);   //返回undefined
>console.log(message);      //返回undefined
>```

11、NUll类型
> 1.只有一个值的数据类型，该值为null；
> 2.定义的变量准备在将来用于保存对象，最好将该值初始化为null；
> 3.只要检查该值是否为null，就可以知道是否保存了一个对象。

12、Boolean类型
> 1.由两个字面值：true和false；
> 2.将一个值转换为对应的Boolean值，调用转型函数Boolean()；
> 3.调用转型函数属于强制转换，还存在隐式转化（在if条件语句中）；
```
var box = 'Hello';
if(box){             //隐式转换成Boolean类型
  alert("真");
}else{
  alert("假")；
}
```
> 4.转化规则：

|数据类型|转换为true|转换为false|
|---|---|---|
|Boolean|true|false|
|String|任何非空字符串|空格字符串|
|Number|任何非零数字值|0和NaN|
|Object|任何对象|null|
|Undefined|不适用|undefined|
>```
>var test;                 //undefined
>var message="hello";
>console.log(Boolean(test));     //返回false
>console.log(Boolean(message));  //返回true
>```

13、Number类型
>- 1.整型数值：在计算时八进制和十六进制都被转换成十进制数值。
> 1. 十进制整数：
> 2. 八进制整数：第一位为0（如果字面值超过了范围，则当成十进制）；
> 3. 十六进制整数：以0x开头
>- 2.浮点数值：
> 1. 定义：数值中必须包含一个小数点，并且小数点后面必须至少有一个数字；
> 2. 表示方法：对于极大值和极小值，可以采用科学计算法（默认情况，小数点后面超过6个零以上的浮点数值转换为e表示法）
> 3. 精度：浮点数值的最高精度是17位小数，进行算术计算时精度远不及整数；例如：0.1+0.2的结果不是0.3，而是0.30000000000000004。
>- 3.数值范围：
> 1. 由于内存的限制，ECMAScript能够保存的最小的数值保存在Number.MIN_VALUE中（5e-324）；
> 2. 最大的数值保存在Number.MAX_VALUE（1.797931348623157e+308）；
> 3. 如果超过了JavaScript数值范围，这个值会自动转换为特殊的Infinity值；
> 4. isFinite()函数——函数值位于最小值和最大值之间会返回true。
>- 4.NaN：
> 1. 定义：非数值的一个特殊的数值；
> 2. 作用：表示一个本来要返回数值的操作数未返回数值的情况（不会抛出错误了），例如：任何数除以0会返回NaN；
> 3. 特点：
> > 1.任何涉及NaN的操作都会返回NaN；
> > 2.NaN与任何值都不相等，包括NaN本身。
> 4. isNaN()函数——确定这个参数是否可以转换为数值（true表示不能转换为数值）
>- 5.数值转换（非数值转换为数值）：
> 1. 3个函数：
> > 1.Number():可以用于任何数据类型；
> > 2.parseInt()和parseFloat():专门用于把字符串转换成数值；
> 2. Number()转换规则：
> > 1.Boolean值，true和false分别转换为1和0；
> > 2.数字值，简单的传入和返回；
> > 3.null，返回0；
> > 4.undefined，返回NaN；
> > 5.字符串，遵循以下规则：
> >-只包含数字，则转换为十进制数值；("1"转换为1)；
> >-包含有效的浮点格式，转换为对应的浮点数值，前导和后导0会去掉("1.1"转换为1.1)；
> >-包含有效的十六进制格式，转换为相同大小的十进制整数值("0xf"转换为15)；
> >-为空，转换为0；
> >-包含上述格式之外的字符，转换为NaN;
> > 6.对象，调用valueof()方法，依照前面的规则转换。如果转换结果是NaN，则调用对象toString()方法，然后再按照前面的规则。
> 3. parseInt()转换规则：
> > 1.忽略字符串前面的空格，直到找到第一个非空字符；
> > 2.如果第一个字符不是数字，函数会返回NaN；
> > 3.如果是，会解析接下来的字符，直到解析完所有的字符或找到了非数字字符；
>```
>var num1=parseInt("123blue");   //123
>var num2=parseInt("");          //NaN
>var num3=parseInt("0xA");       //10(十六进制)
>var parseInt("22.5");           //22
>```
> **注意：parseInt解析十进制，八进制，十六进制，存在问题，需要提供基数，告知是多少进制**
>```
>var num1=parseInt("0xAF",16);     //175(十六进制)
>var num2=parseInt("10",2);        //2(二进制)
>var num3=parseInt("10",8);        //8(八进制)
>var num4=parseInt("10",10);       //10(十进制)
>```
> 4.parseFloat()：解析浮点数字字符（第一个小数点有效，后面的都是无效的）
> > 1.如果字符串包含的是可解析为整数的数(没有小数点，或小数点后都为0)，会返回整数；
> > 2.十六进制格式的字符串始终会被转化为0。
> **两者的区别：parseFloat会忽略前面的0；parseInt会忽略前面的空格。**
>```
>var num1=parseFloat("123blue");    //123
>var num2=parseFloat("23.12.68");   //23.12
>var num3=parseFloat("3.24e4");     //32400
>var num4=parseFloat("0xA");        //0
>```

14、String类型
> 1.定义：表示由零或多个16位Unicode字符组成的字符序列，即字符串；
> 2.表示方法：双引号或单引号（左右引号必须匹配）；

15、字符字面量
> 1.String类型包含特殊的字符字面量，称为转义序列。

|字面量|含义|
|---|---|
|\n|换行|
|\t|制表|
|\b|空格|
|\r|回车|
|\f|进制|
|\\|斜杠|
|\'|在单引号表示的字符串中使用，如'he \'hey.\''|
|\"|在双引号表示的字符串中使用，如"he \"said.\""|
|\xnn|以十六进制代码nn表示的一个字符(n为0-F)|
|\unnnn|以十六进制代码nnnn表示的一个Unicode字符(n为0-F)|

16、字符串的特点：
> 1.不可变的。一旦创建，它们的值就不能改变；
> 2.要改变的话，只能销毁原来的字符串，再用新值填充该变量；

17、转换为字符串方法
> 1.toString()方法：null和undefined值没有该方法。
> 1. 一般情况，toString()方法不传递参数；
>```
>var age=11;
>var ageResult=age.toString();          //"11"
>```
> 2. 传递一个参数：输出数值的基数（默认为十进制）
>```
>var num 10;
>console.log(num.toString(2));            //"1010"
>console.log(num.toString(8));            //"12"
>console.log(num.toString());             //"10"
>```
> 2.String()方法：能够将任何类型的值转换为字符串。
>- 转换规则：
> 1. 如果值有toString()方法，则调用该方法；
> 2. 如果值是null，则返回"null";
> 3. 如果值是undefined，则返回"undefined".

18、Object类型
> 1.对象其实是一组数据和功能的集合；
> 2.对象可以通过执行new操作符+要创建的对象类型的名称来创建；
>```
>var object = new Object();
>```

19、Object实例具有的属性和方法
> 1.Constructor:保存着用于创建当前对象的函数，如构造函数；
> 2.hasOwnProperty(propertyName)：用于检查给定的属性在当前的对象实例中是否存在。其中，参数的属性名（propertyName）必须以字符串形式指定。
> 3.isPrototypeOf(object):用于检查传入的对象是都是另一个对象的原型。
> 4.propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。
> 5.toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
> 6.toString()：返回对象的字符串表示。
> 7.valueOf()：返回对象的字符串、数值或布尔值表示。

20、什么是操作符
> 1.定义：一组用于操作数据值符号；
> 2.分类：一元运算符、布尔运算符、算术操作符、三元运算符、位操作符、关系操作符和赋值运算符。

21、一元操作符：
> 1.定义：只能操作一个值的操作符；
> 2.分类：递增和递减操作符、一元加和减操作符；

22、递增和递减操作符
> 1.前置型：位于要操作的变量之前，例如：++i;
> 2.后置型：位于要操作的变量之后，例如：i++；
> 3.应用范围：整数、字符串、布尔值、浮点数值和对象。
> 4.不同的数据类型的规则：
> 1. 包含有效数字字符的字符串，先转换为数字值，再进行操作；
> 2. 不包含有效数字字符的字符串，将变量值设置为NaN；
> 3. 布尔值false，先转换为0，再进行操作；
> 4. 布尔值true，先转换为1，再进行操作；
> 5. 浮点数值，直接进行操作；
> 6. 对象，会调用对象的valueOf()和toString()方法，再对应前面的规则。

23、一元加和减操作符
> 1.应用：数值和非数值；
> 2.位置：放在数值前面；
> 3.应用非数值时，要进行转换：
> 1. 布尔值false转换为0；
> 2. 布尔值true转换为1；
> 3. 字符串会按特殊的规则进行解析；
> 4. 对象是先调用valueOf()和toString()方法，再转换得到的值。
> **注意：一元减操作符，按相应的规则转换之后，最后要将其变成负数**

24、位操作符
> 1.定义：按内存中表示数值的位来操作数值；
> 2.在ECMAScript中所有的数值都以IEEE-754 64位格式存储；
> 3.位操作符先将64位转换成32位整数，再执行操作，最后，将结果转换回64位。
> 1. 问题：对NaN和Infinity值应用位操作符时，这两个值会被当成0来处理；
> 2. 对非数值应用位操作符时，会先使用Number()函数，将该值转换为一个数值。
> 4.有符号位，0表示正数，1表示负数；
> 5.负数是以补码保存的（绝对值的二进制码，0和1互换，反码+1）。
> 1. 负数转换为二进制字符串的时候，得到的结果只是在这个负数的绝对值的二进制码前面加了“-”；
>```
>var num = -18;
>console.log(num.toString());       //"-10010"
>```

25、按位非（NOT）
> 1.符号：波浪线"~"，有一个操作数;
> 2.计算方法：求数值的反码；

26、按位与(AND)
> 1.符号：和号字符"&"，有两个操作数；
> 2.两个数全为1，结果才是1。

27、按位或(OR)
> 1.符号：竖线符号"|"，有两个操作数；
> 2.有一个数为1，结果就为1。

28、按位异或(XOR)
> 1.符号：插入符号"^"，有两个操作数；
> 2.两个数不同，结果为1。

29、左移
> 1.符号：两个小于号"<<";
> 2.以0填充空位。

30、有符号右移
> 1.符号：两个大于号">>";
> 2.保留符号位，空位用符号位填充。

31、无符号右移
> 1.符号：三个大于号">>>"；
> 2.对于正数，和有符号右移相同；
> 3.对于负数，以0填充空位，得到的就是最后的二进制数，不用进行转换。

32、布尔操作符
> 1.作用：测试两个值的关系；
> 2.分类：非(NOT)、与(AND)、或(OR)。

33、逻辑非
> 1.符号：感叹号"!"，有一个操作数；
> 2.规则：
> 1. 操作数为对象，返回false；
> 2. 空字符串，返回true；
> 3. 非空字符串，返回false；
> 4. 数值0，返回true；
> 5. 任意非0数值(Infinity)，返回false；
> 6. null，返回true；
> 7. NaN，返回true；
> 8. undefined，返回true。
>```
>alert(!false);     //true
>alert(!"blue");    //false
>alert(!0);         //true
>alert(!"");        //true
>```
> 3.可用于将一个值转换为其对应的布尔值（使用两个逻辑非操作符，会模拟Boolean()转型函数）；

34、逻辑与
> 1.符号：两个和号"&&"，有两个操作数；
> 2.两个操作数都为true，结果为true；
> 3.规则：
> 1. 第一个操作数是对象，则返回第二个操作数；
> 2. 第二个操作数是对象，只有在第一个操作数结果为true的情况下，返回对象；
> 3. 两个操作数都是对象，返回第二个操作数；
> 4. 有一个是null，返回null；
> 5. 有一个是NaN，返回NaN；
> 6. 有一个是undefined，返回undefined。

35、逻辑或
> 1.符号：两个竖线"||"，有两个操作数；
> 2.规则：
> 1. 第一个操作数是对象，返回第一个操作数；
> 2. 第一个操作数的结果是false，返回第二个操作数；
> 3. 两个操作数都是对象，返回第一个操作数；
> 4. 两个操作数都是null，返回null；
> 5. 两个操作数都是NaN，返回NaN;
> 6. 两个操作数都是undefined，返回undefined。

36、乘性操作符
> 1.分类：乘法、除法和求模；
> 2.操作数是非数值时，后台会先使用Number()转型函数将其转换为数值；

37、乘法
> 1.符号：星号`"*"`，计算两个数值的乘积；
> 2.规则：
> 1. 一个操作数是NaN，结果为NaN；
> 2. Infinity与0相乘，结果是NaN；
> 3. Infinity与非0数值相乘，结果是Infinity或-Infinity；
> 4. Infinity与Infinity相乘，结果是Infinity；
> 5. 有一个操作数不是数值，则在后台调用Number()将其转换为数值，再应用上面的规则。

38、除法
> 1.符号：斜线符号"/"；第二个操作数除第一个操作数的计算；
> 2.规则：
> 1. 有一个操作数是NaN，结果是NaN;
> 2. Infinity被Infinity除，结果是NaN；
> 3. 0被0除，结果是NaN;
> 4. 非零的有限数被0除，结果是Infinity或-Infinity；
> 5. Infinity被任何非零数值除，结果是Infinity或-Infinity；
> 6. 有一个操作数不是数值，则调用Number()转换为数值，再计算。

39、求模
> 1.符号：百分号"%"，两个操作数；
> 2.规则：
> 1. 被除数是无穷大而除数是有限大的数值，结果是NaN；
> 2. 被除数是有限大二除数是0的数值，结果是NaN；
> 3. Infinity被Infinity除，结果是NaN；
> 4. 被除数是有限大而除数是无穷大的数值，结果是被除数；
> 5. 被除数是0，结果是0；
> 6. 有一个操作数不是数值，调用Number()转换为数值，再计算。

40、加性操作符
> 1.分类：加法和减法。

41、加法
> 1.符号：加号"+"，两个操作数；
> 2.规则：
> 1. 一个操作数是NaN，结果是NaN;
> 2. Infinity加Infinity，结果是Infinity；
> 3. -Infinity加-Infinity，结果是-Infinity；
> 4. Infinity加-Infinity，结果是NaN;
> 5. +0加+0，结果是+0；
> 6. -0加-0，结果是-0；
> 7. +0加-0，结果是+0；
> 8. 如果有一个操作数是字符串，则应用以下规则：
> > 1.两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
> > 2.只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再拼接。
> > 3.如果有一个操作数是对象、数值或布尔值，则调用toString()方法取得相应的字符串值。
>```
>var num1=5;
>var num2=10;
>var num="The sum of 5 and 10 is "+(num1+num2);       //"The sum of 5 and 10 is 15"
>var num="The sum of 5 and 10 is "+num1+num2;         //"The sum of 5 and 10 is 510"（拼接）
>var num=num1+num2+" is the sum of 5 and 10";        //"15 is the sum of 5 and 10"
>```

42、减法
> 1.符号：减号"-"，两个操作数；
> 2.规则：
> 1. 有一个操作数是NaN，结果是NaN;
> 2. Infinity减Infinity，结果是NaN;
> 3. -Infinity减-Infinity，结果是NaN；
> 4. Infinity减-Infinity，结果是Infinity；
> 5. -Infinity减Infinity，结果是-Infinity；
> 6. +0减+0，结果是+0；
> 7. +0减-0，结果是-0；
> 8. -0减-0，结果是+0；
> 9. 如果有一个操作数是字符串、布尔值、null或undefined，则先调用Number()转换为数值，再进行操作；
> 10. 有一个操作数是对象，调用valueOf()方法取得该对象的数值，如果对象没有这个方法，则调用toString()方法，并将得到的字符串转换为数值。

43、关系操作符
> 1.作用：两个值进行比较；
> 2.分类：小于(<)、大于(>)、小于等于(<=)、大于等于(>=)、等于（==）、恒等（===）、不等（!=）、不恒等（!==）；
> 3.规则：
> 1. 都是数值，执行数值比较；
> 2. 都是字符串，比较两个字符串对应的字符编码；
> 3. 一个操作数是数值，将另一个操作数转换为数值，执行数值比较；
> 4. 一个操作数是对象，调用对象的valueOf()，如果没有该方法，执行toString()方法；
> 5. 一个操作数是布尔值，先将其转换为数值，再进行比较；

44、相等操作符
> 1.分类：
> 1. 相等和不相等-先转换再比较；
> 2. 全等和不全等-仅比较而不转换；

45、相等和不相等
>- 1.符号：相等-两个等于号(==)；不相等-叹号后跟等号(!=);
>- 2.转换规则：
> 1. 有一个操作数是布尔值，false转换为0，true转换为1；
> 2. 一个操作数是字符串，另一个操作数是数值，先将字符串转换为数值；
> 3. 一个操作数是对象，另一个不是，调用对象的valueOf()，得到基本类型。
>- 3.比较规则：
> 1. null和undefined是相等的；
> 2. 比较相等性之前，不能将null和undefined转换为其他任何值；
> 3. 一个操作数是NaN，相等操作符返回false，不等操作符返回true
> **注意：两个操作数都是NaN，相等操作符也返回false，因为NaN不等于NaN**
> 4. 两个操作数都是对象，比较他们是否是同一个对象；

46、全等和不全等
> 1.符号：全等-三个等号`===`，不全等-叹号后跟两个等号`!==`;
>```
>var result1 = ("55" == 55);          //true
>var result2 = ("55"===55);           //false(数据类型不同)
>var result3 = ("55" != 55);          //false
>var result4 = ("55" !== 55);         //true
>```

47、条件操作符
> 1.符号："?:"；

48、赋值操作符
> 1.分类：
> 2. 乘/赋值：`*=`;
> 3. 除/赋值：`/=`;
> 4. 模/赋值：`%=`;
> 5. 加/赋值：`+=`;
> 6. 减/赋值：`-=`;
> 7. 左移赋值：`<<=`;
> 8. 有符号右移/赋值：`>>=`;
> 9. 无符号右移/赋值：`>>>=`;

49、逗号操作符
> 1.作用：
> 1. 在一条语句中执行多个操作，用于声明变量；
> 2. 用于赋值，总会返回表达式中的最后一项；
>```
>var num1=1,num2=4,num3=5;     //声明变量
>var num=(2,4,5,1);            //num的值为1
>```

50、流程控制语句
> 1.if语句：使用代码块
> 2.do-while语句：后测试循环语句
> 3.while语句：前测试循环语句
> 4.for语句：前测试循环语句，具有初始化变量和定义要执行代码的能力
> 5.for-in语句：精准迭代语句(foreach)
> 6.label语句：添加标签，与for循环一起使用,start标签由break和continue引用
>```
>start:for(var i=0; i<count;i++){
>  alert(i);
>}
>```
> 7.break和continue语句：break立刻退出循环，continue退出本次循环执行下次循环
> 8.with语句：将代码的作用域设置到一个特定的对象
>```
>var hostName=location.hostName;
>var url=location.href;
>   //使用with语句简化上面的代码
>with (location){
>  var hostName=hostname;
>  var url=href;
>}
>```
> 9.switch语句：使用break语句，在代码中注释省略break的原因

51、函数
>- 1.作用：
> 1. 可以封装任意多条语句；
> 2. 可以在任何地方、任何时候调用执行。
>- 2.函数的定义：
>```
>function functionName(arg0,arg1...argN){
>  statements
>}
>```
>- 3.函数的返回值
> 1. 定义时不必指定是否返回值；
> 2. 任何函数都可以在任何时候return返回值；
> 3. 执行return语句之后停止并立即退出。

52、严格模式对函数的限制
> 1.不能把函数命名为eval或arguments；
> 2.不能把参数命名为eval或arguments；
> 3.不能出现两个命名参数同名的情况；
> 4.出现上述情况，会导致语法错误。

53、函数中的参数
> 1.命名的参数只提供便利，但不是必须的。
> 1. ECMAScrip函数不介意传递进来多少个参数，也不在乎参数的类型，
> 2. 因为，参数在内部是用数组来表示的，函数接收到的始终是数组，
> 3. 在函数体内，可以通过arguments对象来访问这个数组。
>```
>//这两个函数功能相同
>function sayHi(){
>  alert("Hello"+arguments[0]+","+arguments[1]);
>}
>function sayHi(name,message){
>  alert("Hello"+name+","+message);
>}
>```
> 2.参数数组中的值与命名参数保持一致，且可以同时使用；
>```
>function sayHi(num1,num2){   //num1=10，num2=20，反之也是如此
>  arguments[0]=10;
>  arguments[1]=20;
>}
>```
> 3.没有传递值的命名参数将被自动赋予undefined值。

54、函数不能重载的原因
> 1.ECMAScript函数没有签名，其参数是由数组表示的，所以不能够重载。
> 2.如果定义了两个相同名字的函数，有效的是后定义的。
>```
>function addNumber(num){
>  return num+100;
>}
>function addNumber(num){
>  return num+200;
>}
>var result = addNumber(100);     //结果是300
>```
