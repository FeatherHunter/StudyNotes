转载请注明链接: https://blog.csdn.net/feather_wch/article/details/52254111

# Java对象的内存布局

版本号:2018/09/20-1(0:13)

---

[TOC]

![Java对象的内存布局](https://static001.geekbang.org/resource/image/8e/92/8eda743c128a33fe446358b740978792.jpg)

---

## 对象

1、Java中创建对象有几种方式?(5)
> 1. new
> 1. 反射机制
> 1. Object.clone
> 1. 反序列化
> 1. Unsafe.allocateInstance()

2、创建对象的多种方法的特点?
> 1. Object.clone()、反序列化: 直接复制已有的数据, 来初始化对象的实例字段
> 1. new、反射机制: 通过调用构造器来初始化实例字段
> 1. Unsafe.allocateInstance(): 创建对象，但不会初始化实例字段

3、Unsafe.allocateInstance()有什么用?
> 1. 能突破限制创建实例
> 1. 通过allocateInstance()方法，可以创建一个类的实例，但是不需要调用其的构造函数、初始化代码、各种JVM安全检查以及底层的内容。
> 1. 即使构造函数是私有，也可以通过这个方法创建它的实例。

4、new语句生成的字节码
> 1. 首先是new指令，用于请求内存。
> 1. 其次是invokespecial指令，用于执行构造器。
```java
 People people = new People();
```
```
         0: new           #2                  // class People
         3: dup
         4: invokespecial #3                  // Method People."<init>":()V
         7: astore_1
         8: return
```

5、Java对象构造器的约束
> 1-一个类没有定义任何构造器，Java 编译器会自动添加一个无参数的构造器。
```java
public class People {
    // 默认具有无参构造器
}
```
> 2-如果父类存在无参数构造器，子类构造器会隐式调用父类无参构造器。
```java
public class People {
}
public class Student extends People{
    public Student(){
        //默认隐式调用父类无参数构造器
    }
    public Student(int age){
        //默认隐式调用父类无参数构造器
    }
}
```
> 3-如果父类没有无参数构造，子类构造器需要显式地调用父类带参数构造器。
```java
public class People {
    public People(String name){
    }
}
// 错误形式
public class Student extends People{
    public Student(){
        // 报错!
    }
    public Student(String name){
        // 报错!
    }
}
// 正确形式
public class Student extends People{
    public Student(){
        super("");
    }
    public Student(String name){
        super(name);
    }
}
```

6、子类显式地调用父类构造器的方法?
> 1. 一是直接使用“super”关键字调用父类构造器
> 1. 二是使用“this”关键字调用同一个类中的其他构造器,间接调用父类构造器。

7、调用父类构造器必须作为构造器的第一条语句?
> 1. 以便优先初始化继承而来的父类字段。
> 1. 不然编译器会报错
> 1. 这个限制可以通过字节码注入绕开
```java
    public Student(){
        // 会报错
        System.out.println("我先执行");
        super("");
    }
```

8、子类会层层调用父类的构造器?
> 1. 父类的构造器会作为子类构造器的第一个语句执行
> 1. 子类的实例对象会层层调用构造器，直到Object类。

9、父类的private字段，子类是无法继承的，因此并没有给这些字段分配空间?被子类的实例字段隐藏的父类实例字段呢？
> 错误！
> 1. 层层调用父类构造器，一定会给所有父类中的实例字段分配内存空间。
> 1. 子类的同名实例字段会隐藏掉父类的同名实例字段(父类该字段无法被子类对象访问)，但依然是分配了内存空间的。


### 对象的组成

10、对象有几个组成部分？
> 1. 对象头-Header
> 1. 对象实例-Instance Data
> 1. 对象填充-Padding

12、Java对象的对象头(Object Header)是什么?由哪几部分组成?
> 1. 标记字段---存储对象自身的运行时数据：
>       1. HashCode
>       1. GC分代年龄
>       1. 锁状态标志
>       1. 线程持有锁
>       1. 偏向线程ID
>       1. 偏向时间戳
> 1. 类型指针
>       1. 对象指向它的类元数据的指针，也就是该对象指向它的类。

13、对象实例存储的什么数据？
> 1. 对象真正存储的有效信息
> 1. 定义的各种字段(父类、子类)

14、对齐填充的作用？
> 1. JVM的内存管理要求对象的`起始地址`都必须是`8字节的整数倍`

## 字段在内存中的分布

1、对象头的大小是多少？
> 1. 64位的JVM中，标记字段占64位，类型指针占64位。(64+64)/8=16个字节。
> 1. 也就是说，每一个Java对象在内存中的额外开销就是16个字节。
> 1. 例如Integer类，仅有一个int类型的私有字段，占4个字节。所以一个Integer对象的额外内存开销至少是 400%。
> 1. 这也是Java要引入基本数据类型的原因之一。

2、Java为什么要引入基本数据类型?
> 1. Integer等包装类会有大量的额外内存开销。
> 1. 原始数据类型数组，数据在内存上是连续的。但是对象数组中的对象分散在堆中，无法利用CPU的缓存机制。
> 1. 原始数据类型数组，能直接在内存地址中取出数值。但是Integer等对象数组，需要先找到目标地址，才能读取数据。

3、压缩指针是什么?
> 1. 为了减少对象的内存使用量，64位JVM引入了`压缩指针`
> 1. JVM参数是: ` -XX:+UseCompressedOops`，默认开启。
> 1. 将堆中原本64位的Java对象指针压缩成32位。
> 1. 对象头中的类型指针也会被压缩成32位，使得对象头的大小从16字节降至12字节。
> 1. 此外压缩指针还可以作用于引用类型的字段和引用类型的数组。

4、压缩指针的原理？
> 1. 场景: 停车场停放房车，每个房车会占据2个车位。
> 1. 原本的内存寻址, 使用的是车位号，值为6的指针代表第6个车位。最大的车位是2^32(4GB个车位)，最大的车号是2^31(2GB辆车)。
> 1. 采用压缩指针，使用的是车号，值为6的指针代表第6个车。其具体的车位是`10、11`。这样最大的车位是2^33(8GB个车位)，最大的车号是2^32(4GB辆车)。
> 1. 假设一个房车占8个车位(8个字节)，最大的车号依然是2^32(4GB辆车)。最大的车位(内存地址)是2^35(32GB个车位)
> 1. 此外具有的前提是，每辆车必须从偶数号车位开始停车。(内存对齐)

5、什么是内存对齐?
> 1. Java中对象的起始地址需要是8的整数倍
> 1. 能提高系统性能(例如如果放置在奇数内存位置上，CPU读取出数据需要读取两次，放到偶数内存位置上，CPU只需要读取一次。)
> 1. JVM是的参数`-XX:ObjectAlignmentInBytes`, 默认值为8。
> 1. 但是通过内存对齐选项进一步提升寻址范围，可能会导致压缩指针没有达到原本节省空间的效果。(一些数据浪费的填空空间过大，整体得不偿失)

6、如果一个对象用不到8的整数倍字节，该怎么办?(对象填充)
> 1. 那些空白的部分空间会被浪费
> 1. 这些浪费掉的空间称之为对象间的填充（padding）

7、JVM中压缩指针可以寻址到多少个字节?
> 1. 在默认情况下，Java 虚拟机中的 32 位压缩指针可以寻址到 2 的 35 次方个字节。
> 1. 也就是 32GB 的地址空间（超过 32GB 则会关闭压缩指针）。
> 1. 在对压缩指针解引用时，将其左移 3 位，再加上一个固定偏移量，便可以得到能够寻址 32GB地址空间的伪64位指针。

8、关闭了压缩指针，Java虚拟机还是会进行内存对齐

9、内存对齐仅仅存在于对象与对象之间?
> 错误！
> 1. 也存在于对象中的字段之间。
> 1. 比如JVM要求 long 字段、double 字段，以及非压缩指针状态下的引用字段的地址为8的倍数。

10、字段为什么要进行内存对齐?
> 1. 是为了让字段只出现在CPU的同一个缓存行中。
> 1. 如果字段不是对齐的，那么就有可能出现跨缓存行的字段。
> 1. 也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。
> 1. 这两种情况都会影响程序的执行效率。


## 问题汇总

## 参考资料
