package LeetCode;

public class P91_解码方法 {
    /**
     * 思路：第i个字符时，方案等于 dp[i-1](需要满足不为0) + dp[i-2](需要满足26以内，并且前一个字符不为0)，否则为0(代表不合法)
     */
    public int numDecodings(String s) {
        char[] w = s.toCharArray();
        int N = w.length + 1;
        // dp[i] w的第i个字符时，有几个方案
        int[] dp = new int[N];
        dp[0] = 1; // 空字符就有1个方案了
        for (int i = 1; i < N; i++) {
            if (w[i - 1] != '0') {
                // 不为0，就有一个独立方案，数量等于dp[i-1]的
                dp[i] += dp[i - 1];
            }
            if (i - 2 >= 0 && w[i - 2] != '0' // 前一个字符不能为0
                    && ((w[i - 1] - '0') + (w[i - 2] - '0') * 10) <= 26) { // 26范围以内
                dp[i] += dp[i - 2]; // 由dp[i-1] + '26' 相同或苏亮方案组成
            }
        }
        return dp[w.length];
    }

    /**
     * 思考：
     * 1. 一维dp，dp[S最大值+1]
     * 1. 从低到顶，还是从顶到底。"1234567890" 应该是从底部开始推导。dp[i] = 前面不需要自己,自己不为0 dp[i-1]， + 自己为0，前面需要自己 dp[i-2]
     * 举例：
     * dp[0] = 1,前面不需要自己 1种
     * dp[1] = 2, 前面不需要自己（1和2）1种 + 前面需要自己（12）一种
     * dp[2] = 3种,前面不需要自己（1和2和3+12和3）2种 + 前面需要自己（1和23）1种。列举一下 1,2,3 12,3 1,23
     * 1. 边界条件判断
     * <p>
     * 1. 注意到了什么？
     * 注意到了需要考虑到条件，需要避免dp[i-1]和dp[i-2]的情况
     * 2. 采取了什么行动？=> 分条件判断
     * 3. 犯了哪些错误？
     * 1. 缺少一个条件判断和考虑
     * 2. dp[0]的情况没有直接提供，导致多了一层判断
     * 3. dp[1]的数据，应该直接给出，避免后面冗余的条件判断
     * 4. 可以怎样去改变？
     * 将可能超出边界的条件，进行预先处理，作为BaseCase
     * <p>
     * 0ms击败 100.00% 使用 Java 的用户
     * <p>
     * // 感受：一维数组，空间优化，很有限
     */
    public int numDecodingsOld(String s) {
        if (s == null || s.length() < 1) return 0;
        int n = s.length();
        char[] w = s.toCharArray();
        int dp[] = new int[n + 1];

// 1-BaseCase dp[0]
        if (w[0] > '0' && w[0] <= '9') {
            dp[0] = 1;
        }

// 2-BaseCase  dp[1]
        if (n > 1) {
            if (w[1] > '0' && w[1] <= '9') {
                dp[1] += dp[0]; // 前面不需要自己, 并且自己不是0，可以符合要求
            }
            if (w[0] != '0' && ((w[0] - '0') * 10 + (w[1] - '0')) <= 26) {
                dp[1] += 1; // 自己就是一个结果
            }
        }
// 3-考虑普遍情况
        for (int i = 2; i < n; i++) {
            if (w[i] > '0' && w[i] <= '9') {
                dp[i] += dp[i - 1]; // 前面不需要自己, 并且自己不是0，可以符合要求
            }
// 前面需要自己
            if (w[i - 1] != '0' && ((w[i - 1] - '0') * 10 + (w[i] - '0')) <= 26) {
                dp[i] += dp[i - 2]; // 前面需要自己, 并且在1~26的范围
            }
        }
        return dp[n - 1];
    }
}
