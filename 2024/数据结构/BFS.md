## BFS 宽度优先遍历
曼哈顿距离：
> 非对角线距离

## 01BFS
01bfs适合：
1. 图中边的权值只有0和1两种
2. 统计从a到所有点的最短距离
为什么不能用传统bfs？
1. 展开的过程中，到目标节点的更短路径会被更正
2. 传统bfs要做，需要对边进行权值排序，O（节点+边）*O（log边）
3. 01bfs可以做到时间复杂度为O（节点+边）
引入【双端队列】
步骤：
1. distance[i]为原点到i的最短距离，默认无穷大
2. 源头进入双端队列，distance[原点]=0
3. 双端队列 头部弹出x
> a. 如果x为目标节点，返回distance[x]表示原点到目标，最短距离
> b. 考察x的每条边，边到y点，边权重w
>   如果distance[y] > distance[x] + w, 跟新distance[y] = distance[x] + w
>   I. w == 0，y 从头部加入双端队列
>   II. w == 1，y 从尾部加入双端队列
> 重复步骤三
4. 双端队列为空，结束
题目：
1368
2290


## 双向广搜
用途一: bfs剪枝优化，分两侧展开，从数量少的开始展开
用途二: 全量数据不允许递归完全展开（比如2的n次方），但是半量数据可以完全展开，先分成两部分展开，再合并结果


