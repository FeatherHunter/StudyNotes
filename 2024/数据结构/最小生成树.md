## 最小生成树
最小生成树必须是：无向带权图
什么是最小生成树？
> 无向带权图中，选择一些边，保证联通性的情况下，边的总权值最小
TIPS：
1. 最小生成树可能有多个，只要总权值最小，都是正确的
2. 如果无向带权图，有n个节点，最小生成树一定有n-1个边
拓展：最小生成树一定是`最小瓶颈树`

### Kruskal算法（最常用）
步骤：
1. 所有边，根据权值，从小到大排序，从权值最小的边开始考虑
2. 当前边，不会导致形成环，选择当前边（会形成则不选择）
3. 考察完所有边后，最小生成树OVER
如何判断是否形成环：并查集
使用并查集，不需要建立图。


时间复杂度：O(m*logm)+O(n)+O(m)
和边的数量有关，m为边
> 边比点多超级多，性能会差

### Prim算法
可以用于有向图？
步骤：
1. 解锁的点，集合为set，解锁的边，集合为heap（小根堆）
2. 任意点开始，加入到set，将开始点的所有边加入到heap中
3. 弹出权值最小的edge（就是顶部），查看edge去到的目标点
> 目标点，已经在set中，将边edge舍去，重复步骤3
> 目标点，不在set中，属于最小生成树，将x加入到set中，重复步骤3
4. 当heap为空，结束
时间复杂度：
> O(n+m)+O(m*logm)和边的数量有关 
> 边比点多超级多，性能会差

#### Prim优化
时间复杂度：O(n+m)+O((m+n)*logn) 和节点数量有关
思路：
1. 将Node（t点，到点t的花费c）以`到点的花费`存放到heap小根堆中
2. 从heap中弹出（t点，到点t的花费c），weightSum += c，考察从t出发的每一条边（e为边，v目标节点，w权重）
> visited[v] =-1没有进入过 / =-2访问过 / =i在堆中位置
> 1. V已经访问过，忽视e
> 2. v没有进入过heap，加入（v，w）
> 3. v在堆中，且原记录为（v，x）
>   1）w >=x 忽略
>   2）w < x，更新为（v，w）并且调整该节点在heap中位置
1. 重复步骤2，直至heap为空

