# JVM
什么是JVM？
> 一种规范
> JVM支持多语音，不同平台有不同JVM实现，符合JVM规范即可
1、JDK、JRE、JVM是什么？
1. JDK：JRE+工具
2. JRE：Java运行环境，包含JVM+java类库
3. JVM：包含ClassLoader、JIT即时编译器、字节码解释器、执行引擎
2、JVM是如何实现的？
1. C++实现的
2. 内部有C++实现的解释器，将Java语言转换为C++语言中的实现（字节码解释，经过一次翻译，性能慢一些）
3、JVM和JIT的关系
1. 热点代码(根据执行次数判断)会通过JIT编译成汇编，汇编会有对应的机器码(10101010101的机器码)
2. 次数怎么确定？后端，一万次。
3. JVM会分为server端和client端
4、JIT的缺点？
1. 需要提前处理
2. 可以将翻译后的汇编代码存放到codecache中
5、运行时数据区是什么？
> 1. JVM在执行Java程序时，将内存划分为若干区域。用于执行程序。这块内存就是`运行时数据区`
> 2. 此外，在运行时数据区之外，还有一块是`直接内存`

## 运行时数据区
1、运行时数据区的组成部分
1. 线程共享：方法区（运行时常量池）、堆
2. 线程私有：每个线程都有，本地方法栈、虚拟机栈、PC
3. 栈中的基本单元是栈帧
2、永久代、元空间是什么？
> HotSpot中概念，JVM规范中没有
> 用永久代、元空间实现了JVM规范中的方法区
3、堆外内存/直接内存是什么？
1. 直接内存，没有经过JVM的虚拟化
2. 需要分配内存、释放
4、虚拟化是什么？运行时数据区经过了JVM的虚拟化
> 实现虚拟化，不需要直接在内存上去找对象
> 用new的方式，将对象存储到堆上，用引用找到堆上对象，就可以使用了

### 栈帧
1、栈帧的组成部分
1. 局部变量表
2. 操作数栈
3. 动态链接：是什么？
4. 方法返回/完成出口：上一个方法的PC值
2、程序计数器/PC是什么？
> 指示器，值是字节码指令的地址，是当前正在执行的
#### Java方法的运行和虚拟机栈
启动一个线程就会创建虚拟机栈
1. main方法会创建栈帧，入栈
2. 后续每个方法，执行时，都会创建栈帧，并且入栈
3. 方法执行完会出栈
2、虚拟机栈有大小限制 -Xss
> 默认值是1024KB
> 可以设置：-Xss1m、-Xss1024K、-Xss1048576 默认是Byte
3、StackoverFlow是什么？
> 栈溢出，死递归，爆掉了
4、虚拟机栈太多了，内存吃紧，会撑爆内存

#### 栈帧执行流程
1、解析执行流程
```c
0:iconst_1 将int常量，值为1，加载到操作数栈。PC=0 //小数值，-1,0,1,2,3,4,5
1:istore_1 将操作数栈数据弹出，放到局部变量表下标为1的位置。**两个1不是一个含义**
// 对应于java一行代码 int x = 1;
// 一行代码，两个字节码
2:iconst_2
3:istore_2
// int z = (x+y)*10;
4:iload_1 将局部变量表下标1数据，加载到操作数栈
5:iload_2 将局部变量表下标2数据，加载到操作数栈
6:iadd 弹出操作数栈两个数据，相加，x+y=3，存入到操作数栈
7:bipush 10 将大数据的10（也可以是特别小的数据 < -1），放到操作数栈 （指令大，占据了两行）因此占据了7和8两个指令
9:imul 操作数栈弹出3和10两个int值，并且相乘=30，放入操作数栈
10:istore_3 将栈顶的数据30，存储到局部变量表下标为3的位置上
11:iload_3 将局部变量表下标3的数据，加载到操作数栈
12:ireturn 将操作数栈顶数据返回
``` 
2、字节码指令前面的0、1、2、3...是什么？
1. 是字节码的偏移量，针对当前方法
2. 指令大，占据的空间大，bipush占据了两个指令的大小
3、方法出口/方法返回是什么？
> 记录的外层的方法的PC值，调用结束后，从下一个指令开始执行
4、动态链接是什么？
> 和多态有关
5、PC寄存器值
> 数值会重复，一个方法一个栈帧，指示当前方法的字节码指令的偏移量即可（可以粗浅理解为行号如0,1,2,3,4...）
> 


