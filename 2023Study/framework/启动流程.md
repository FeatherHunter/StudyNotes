# Android系统启动流程

14、


有道云脑图：https://note.youdao.com/s/GZ9d8vzO

1、整体流程
1. Boot Room
1. BootLoader
1. idle
    1. kthread
    1. init
1. init
    1. ServiceManager
    1. zygote
1. zygote
    1. SystemServer
    1. app




## init


1、kernel/common/init/main.c
```c
kernel_init();
->try_to_run_init_process("/bin/init");
  ->run_init_process(filename)
    ->kernel_execve(filename, xxx, xxx);
      ->// 会执行init
```

2、andorid.mk->android.bp编译
```c
// init/android.bp

cc_binary {
    name: "init_second_stage",
    stem: "init",
    static_libs: ["libinit"],
    srcs: ["main.cpp"], // main.cpp
    // ...
}

```

3、init是用户空间鼻祖
1. 属于C、C++ Framework

### 启动源码

```c
FirstStageMain()
 ->挂载文件系统
 ->重定向输入输出
SetupSelinux()
 ->初始化
SecondStageMain()
 ->初始化属性
 ->设置Selinux
 ->监听子进程终止信号
    ->epoll_ctl 注册监听SIGCHILD 避免僵尸进程
 ->启动属性服务，将sokcet，注册到epoll中
 ->匹配命令和函数
 ->解析init.rc
    ->构造解析器，对应于rc文件里面的service、on、import
    ->parser.ParseConfig：解析rc文件
        ->解析Dir
        ->解析File
            ->按照二进制格式，解析：servicemanager、zygote
 -> 循环执行脚本，epoll循环等待
    -> 执行脚本
```


```c++
// frameworks/core/core/init/main.cpp
int main(int argc, char** argv) {
    // 会反复进入

// 2、第二次进来，根据参数执行
    if (argc > 1) {
        if (!strcmp(argv[1], "subcontext")) {
            const BuiltinFunctionMap& function_map = GetBuiltinFunctionMap();
                // 5、内部while+poll，第四阶段
            return SubcontextMain(argc, argv, &function_map);
        }
    // 3、selinux：第二阶段
        if (!strcmp(argv[1], "selinux_setup")) {
            return SetupSelinux(argv);
        }
    // 4、第三阶段
        if (!strcmp(argv[1], "second_stage")) {
            return SecondStageMain(argc, argv);
        }
    }

// 1、首次进来：第一阶段
    return FirstStageMain(argc, argv);
}

// 第一阶段：
int FirstStageMain(int argc, char** argv) {
    if (REBOOT_BOOTLOADER_ON_PANIC) {
        InstallRebootSignalHandlers();
    }
    CHECKCALL(clearenv());
    CHECKCALL(setenv("PATH", _PATH_DEFPATH, 1));
// 1、挂载文件系统
    CHECKCALL(mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"));
    CHECKCALL(mount("devpts", "/dev/pts", "devpts", 0, NULL));
    CHECKCALL(mount("sysfs", "/sys", "sysfs", 0, NULL));
    CHECKCALL(mount("selinuxfs", "/sys/fs/selinux", "selinuxfs", 0, NULL));
    CHECKCALL(mknod("/dev/random", S_IFCHR | 0666, makedev(1, 8)));
    CHECKCALL(mknod("/dev/urandom", S_IFCHR | 0666, makedev(1, 9)));
    // null也是作为管道文件进行处理
    CHECKCALL(mknod("/dev/null", S_IFCHR | 0666, makedev(1, 3)));
    CHECKCALL(mkdir("/mnt/vendor", 0755));
    CHECKCALL(mkdir("/mnt/product", 0755));

// 2、重定向输入输出：stdio重定向Dev Null，作为管道文件，输入输出
    SetStdioToDevNull(argv);
    // 日志输出初始化
    InitKernelLogging(argv);
// 3、设置selinux安全策略：重新进入main.cpp
    const char* path = "/system/bin/init";
    const char* args[] = {path, "selinux_setup", nullptr};
    execv(path, const_cast<char**>(args)); // 执行

    return 1;
}
// Selinux：设置SeLinux安全策略，Android最小权限原则，selinux控制
int SetupSelinux(char** argv) {

    // 设置selinux
    SelinuxSetupKernelLogging();
    // selinux初始化
    SelinuxInitialize();
    // 重新进入第二阶段
    const char* path = "/system/bin/init";
    const char* args[] = {path, "second_stage", nullptr};
    execv(path, const_cast<char**>(args));
    return 1;
}

// frameworks/core/core/init.coo
int SecondStageMain(int argc, char** argv) {

    // Set init and its forked children's oom_adj.
    if (auto result = WriteFile("/proc/1/oom_score_adj", StringPrintf("%d", DEFAULT_OOM_SCORE_ADJUST));
        !result.ok()) {
        LOG(ERROR) << "Unable to write " << DEFAULT_OOM_SCORE_ADJUST
                   << " to /proc/1/oom_score_adj: " << result.error();
    }

// 1. 初始化属性：加载属性
    PropertyInit();

    // Mount extra filesystems required during second stage init
    MountExtraFilesystems();

// 2. Selinux相关
    SelinuxSetupKernelLogging();
    SelabelInitialize();
    SelinuxRestoreContext();

    Epoll epoll; // =========================> epoll
    if (auto result = epoll.Open(); !result.ok()) {
        PLOG(FATAL) << result.error();
    }
// 3. 监听子进程中止信号：避免僵尸进程 ====================> 僵尸进程
    InstallSignalFdHandler(&epoll);
    InstallInitNotifier(&epoll);
// 4. 启动属性服务
    StartPropertyService(&property_fd);

    SetUsbController();

// 5. 匹配命令和函数的关系：mount等命令都对应于函数
    const BuiltinFunctionMap& function_map = GetBuiltinFunctionMap();
    Action::set_function_map(&function_map);

// 6. 解析 init.rc
    LoadBootScripts(am, sm);

// 7. while循环解析脚本：启动zygote、执行重启
    while (true) {
        // 解析start等命令
        am.ExecuteOneCommand();
        // epoll_wait循环等待 ===================> Handler中Looper.loop
        auto pending_functions = epoll.Wait(epoll_timeout);
    }

    return 0;
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>
//在linux当中，父进程是通过捕捉SIGCHLD信号来得知子进程运行结束的情况，
//SIGCHLD信号会在子进程终止的时候发出
//函数的作用就是，接收到SIGCHLD信号时触发HandleSignalFd进行信号处理
// 这样可以在当子进程发出信号后能够及时的将它销毁，避免僵尸进程的存在
static void InstallSignalFdHandler(Epoll* epoll) {


    const struct sigaction act { .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP };
    sigaction(SIGCHLD, &act, nullptr);

    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGCHLD); //SIGCHLD

    signal_fd = signalfd(-1, &mask, SFD_CLOEXEC);
    // 注册，epoll注册handler。 ===========================> epoll_ctl EPOLL_CTL_ADD
    if (auto result = epoll->RegisterHandler(signal_fd, HandleSignalFd); !result.ok()) {
        LOG(FATAL) << result.error();
    }
}
    // 注册，epoll注册handler。 ===========================> epoll_ctl EPOLL_CTL_ADD
Result<void> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {
    epoll_event ev;
    ev.events = events;
    ev.data.ptr = reinterpret_cast<void*>(&it->second);
    if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {
        epoll_handlers_.erase(fd);
        return result;
    }
    return {};
}

// >>>>>>>>>>>>>>>>>>> 启动属性服务，注册到epoll中
void StartPropertyService(int* epoll_socket) {
    InitPropertySet("ro.property_service.version", "2");

    int sockets[2];
    if (socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, sockets) != 0) {
        PLOG(FATAL) << "Failed to socketpair() between property_service and init";
    }
    *epoll_socket = from_init_socket = sockets[0];
    init_socket = sockets[1];
    StartSendingMessages();

    if (auto result = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, false, 0666, 0, 0, {});
        result.ok()) {
        property_set_fd = *result;
    }

    listen(property_set_fd, 8);

    auto new_thread = std::thread{PropertyServiceThread};
    property_service_thread.swap(new_thread);
}


```

init.rc解析
```c++
// 解析init.rc
static void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list) {
    // 1、创建对应解析器 service、on、import
    Parser parser = CreateParser(action_manager, service_list);

    // 2、解析init.rc init.rc里面有zygote等等
    std::string bootscript = GetProperty("ro.boot.init_rc", "");
    if (bootscript.empty()) {
        parser.ParseConfig("/system/etc/init/hw/init.rc");
        if (!parser.ParseConfig("/system/etc/init")) {
            late_import_paths.emplace_back("/system/etc/init");
        }
        parser.ParseConfig("/system_ext/etc/init");
        if (!parser.ParseConfig("/product/etc/init")) {
            late_import_paths.emplace_back("/product/etc/init");
        }
        if (!parser.ParseConfig("/odm/etc/init")) {
            late_import_paths.emplace_back("/odm/etc/init");
        }
        if (!parser.ParseConfig("/vendor/etc/init")) {
            late_import_paths.emplace_back("/vendor/etc/init");
        }
    } else {
        parser.ParseConfig(bootscript);
    }
}
// 根据rc文件的内容，创建对应解析器 
Parser CreateParser(ActionManager& action_manager, ServiceList& service_list) {
    Parser parser;
    parser.AddSectionParser("service", std::make_unique<ServiceParser>(&service_list, GetSubcontext(), std::nullopt));
    parser.AddSectionParser("on", std::make_unique<ActionParser>(&action_manager, GetSubcontext()));
    parser.AddSectionParser("import", std::make_unique<ImportParser>(&parser));

    return parser;
}

// frameworks/core/core/init/parse.cpp
// 解析
bool Parser::ParseConfig(const std::string& path) {
    if (is_dir(path.c_str())) {
        return ParseConfigDir(path); // 目录 -> ParseConfigFile
    }
    return ParseConfigFile(path); // 文件
}
bool Parser::ParseConfigFile(const std::string& path) {
    // 解析数据
    ParseData(path, &config_contents.value());
    return true;
}

// 根据二进制格式要求，解析数据
void Parser::ParseData(const std::string& filename, std::string* data) {
    for (;;) {
        switch (next_token(&state)) {
            case T_EOF:
                // ...
                return;
            case T_NEWLINE: {
                // ...
                break;
            }
            case T_TEXT:
                args.emplace_back(state.text);
                break;
        }
    }
}
```

### init.rc文件

```bash
import /system/etc/init/hw/init.${ro.zygote}.rc

on init

    # Mount binderfs
    mkdir /dev/binderfs
    mount binder binder /dev/binderfs stats=global
    chmod 0755 /dev/binderfs

    symlink /dev/binderfs/binder /dev/binder
    symlink /dev/binderfs/hwbinder /dev/hwbinder
    symlink /dev/binderfs/vndbinder /dev/vndbinder

    # Start essential services.
    start servicemanager
    start hwservicemanager
    start vndservicemanager

on late-init
    # Now we can start zygote for devices with file based encryption
    trigger zygote-start

on zygote-start && property:ro.crypto.state=unencrypted
    # A/B update verifier that marks a successful boot.
    exec_start update_verifier_nonencrypted
    start statsd
    start netd
    start zygote
    start zygote_secondary
```

### 答疑

1、挂载是什么意思？
1. U盘插入，会绑定到一个文件，才能看到

## ServiceManager

ServiceManager启动流程：见Binder部分。
```c
main()
->1.初始化Binder驱动，加载"/dev/binder"
->2.实例化ServiceManager，并将自己作为第一个服务，进行添加注册
->3.将自己设置为IPCThreadState的contextobject，也就是设置服务端的BBinder对象
->4.利用Looper，也就是底层epoll处理事务，设置BinderCallback监听（epoll_ctl），无限等待
->5.while() // Binder驱动遇到事件，会回调handleEvent
```

## Zygote

### rc解析

```bash
// init.zygote64.rc
# 启动一个服务
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    priority -20
    user root
    group root readproc reserved_disk
    socket zygote stream 660 root system
    socket usap_pool_primary stream 660 root system
 # zygote被关闭就会重启Android操作系统 
    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    onrestart restart wificond
    writepid /dev/cpuset/foreground/tasks
```
```c++
// frameworks/base/cmds/app_process/Android.bp
cc_binary {
    name: "app_process",
    srcs: ["app_main.cpp"] // 指明代码为app_main.cpp
}
```

### 启动:app_main.cpp

#### AppRuntime

```c++
class AppRuntime : public AndroidRuntime
{
public:
    AppRuntime(char* argBlockStart, const size_t argBlockLength): AndroidRuntime(argBlockStart, argBlockLength), mClass(NULL){}

    void setClassNameAndArgs(const String8& className, int argc, char * const *argv) {
        mClassName = className;
        for (int i = 0; i < argc; ++i) {
             mArgs.add(String8(argv[i]));
        }
    }

    virtual void onVmCreated(JNIEnv* env)
    {
        if (mClassName.isEmpty()) {
            return; // Zygote. Nothing to do here.
        }

        char* slashClassName = toSlashClassName(mClassName.string());
        mClass = env->FindClass(slashClassName);
        if (mClass == NULL) {
            ALOGE("ERROR: could not find class '%s'\n", mClassName.string());
        }
        free(slashClassName);

        mClass = reinterpret_cast<jclass>(env->NewGlobalRef(mClass));
    }

    virtual void onStarted()
    {
        sp<ProcessState> proc = ProcessState::self();
        ALOGV("App process: starting thread pool.\n");
        proc->startThreadPool();

        AndroidRuntime* ar = AndroidRuntime::getRuntime();
        ar->callMain(mClassName, mClass, mArgs);

        IPCThreadState::self()->stopProcess();
        hardware::IPCThreadState::self()->stopProcess();
    }

    virtual void onZygoteInit()
    {
        sp<ProcessState> proc = ProcessState::self();
        ALOGV("App process: starting thread pool.\n");
        proc->startThreadPool();
    }

    virtual void onExit(int code)
    {
        if (mClassName.isEmpty()) {
            // if zygote
            IPCThreadState::self()->stopProcess();
            hardware::IPCThreadState::self()->stopProcess();
        }

        AndroidRuntime::onExit(code);
    }


    String8 mClassName;
    Vector<String8> mArgs;
    jclass mClass;
};
```

#### main
1、app_main.cpp 启动Zygote或者正常app流程 ->目录frameworks\base\cmds\app_process\
```c++
// 核心：根据init.zygote64.rc里面配置的参数，--zygote和--start-system-server，启动zygote，systemserver作为参数传入，以后启动
int main(int argc, char* const argv[])
{
    /**========================
     * 1、根据rc配置，解析出需要启动zygote，并且在zygote启动后，
     *========================*/
    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));
    // 解析传入的参数 -Xzygote /system/bin --zygote --start-system-server
    int i;
    for (i = 0; i < argc; i++) {
        // 参数解析
        runtime.addOption(strdup(argv[i]));
    }

    // 判断是zygote还是app
    bool zygote = false;
    bool startSystemServer = false; // 用于存入参数
    bool application = false; // app
    String8 niceName;
    String8 className;

    ++i;  // Skip unused "parent dir" argument.
    while (i < argc) {
        const char* arg = argv[i++];
        if (strcmp(arg, "--zygote") == 0) {
            zygote = true;
            niceName = ZYGOTE_NICE_NAME;
        } else if (strcmp(arg, "--start-system-server") == 0) {
            startSystemServer = true;
        } else if (strcmp(arg, "--application") == 0) {
            application = true;
        } else if (strncmp(arg, "--nice-name=", 12) == 0) {
            niceName.setTo(arg + 12);
        } else if (strncmp(arg, "--", 2) != 0) {
            className.setTo(arg);
            break;
        } else {
            --i;
            break;
        }

    }
    Vector<String8> args;
    if (!className.isEmpty()) {
        // 非zygote模式，存入application启动相关参数
        args.add(application ? String8("application") : String8("tool"));
        runtime.setClassNameAndArgs(className, argc - i, argv + i);

    } else {
        // zygote模式，将systemserver和其他剩余参数，都一次型放入

        if (startSystemServer) {
            args.add(String8("start-system-server"));
        }
        String8 abiFlag("--abi-list=");
        abiFlag.append(prop);
        args.add(abiFlag);
        // In zygote mode, pass all remaining arguments to the zygote
        // main() method.
        for (; i < argc; ++i) {
            args.add(String8(argv[i]));
        }
    }

    /**===============================================
     * 2、启动zygote(systemserver等内容作为参数传入)
     *=====================================================*/

    //  启动zygote的java层调用
    if (zygote) {
        ////zygote 为true 表示正在启动的进程为zygote进程
        //由此可知app_main.cpp在zygote启动其他进程的时候都会通过main()方法
        //这里启动的是zygote进程调用runtime start()方法 传入参数
        runtime.start("com.android.internal.os.ZygoteInit", args, zygote);
    } else if (className) {  //这个地方是用于启动app的 // application = true时，会解析。
        runtime.start("com.android.internal.os.RuntimeInit", args, zygote);
    } else {
        fprintf(stderr, "Error: no class name or --zygote supplied.\n");
        app_usage();
        LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
    }
}
```

2、AndroidRuntime.cpp ->目录frameworks\base\core\jni\
```c++
void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
{

    // 创建虚拟机
    if (startVm(&mJavaVM, &env, zygote, primary_zygote) != 0) { // heapsize默认16MB，也在这里面设置
        return;
    }    
    // 注册JNI
    if (startReg(env) < 0) {
        return;
    }
    // 反射调用main方法（进入ZygoteInit.java的main()方法） ==============================> JNI反射
    char* slashClassName = toSlashClassName(className != NULL ? className : "");
    jclass startClass = env->FindClass(slashClassName);

    jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
"([Ljava/lang/String;)V");

    env->CallStaticVoidMethod(startClass, startMeth, strArray);
}
```

##### JNI注册

AndroidRuntime.cpp中注册了所有JNI
```c++
    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {
        env->PopLocalFrame(NULL);
        return -1;
    }

// 数组存放了所有JNI对应关系
RegJNIRec gRegJNI[] = {....}
```

3、ZygoteInit.java ->目录frameworks\base\cor\java\com\android\internal\os\
```c++

public static void main(String argv[]) {
    //step1 重要的函数 preload
    preload(bootTimingsTraceLog);
    //Step2 重要函数 创建socket服务
    zygoteServer = new ZygoteServer(isPrimaryZygote);  

   if (startSystemServer) {
        //Step3 重要函数 Zygote Fork出的第一个进程 system_server
        Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);
        r.run(); // r: ZygoteInit.zygoteInit
        return;
   }
   //Step4 重要函数 循环等待fork出其他的应用进程，比如Launcher，比如app
   caller = zygoteServer.runSelectLoop(abiList);
   //执行返回的Runnable对象，进入子进程
   caller.run();
      
}
```

#### preload
```c++
    static void preload(TimingsTraceLog bootTimingsTraceLog) {
        preloadClasses();// 加载系统类
        preloadResources();// 加载系统资源
        nativePreloadAppProcessHALs();
        maybePreloadGraphicsDriver();
        preloadSharedLibraries();// 加载一些共享so库，其实就三个：android、compiler_rt、jnigraphics
        preloadTextResources();// 加载字体资源
        WebViewFactory.prepareWebViewInZygote();// 加载webview相关资源
        warmUpJcaProviders();// 初始化JCA安全相关的参数
    }

```

### SystemServer

1、fork出SystemServer
ZygoteInit.java ->目录frameworks\base\core\java\com\android\internal\os\
```c++
    private static Runnable forkSystemServer(String abiList, String socketName,
            ZygoteServer zygoteServer) {
        int pid = Zygote.forkSystemServer(
                    parsedArgs.mUid, parsedArgs.mGid,
                    parsedArgs.mGids,
                    parsedArgs.mRuntimeFlags,
                    null,
                    parsedArgs.mPermittedCapabilities,
                    parsedArgs.mEffectiveCapabilities);

        // 子进程继续处理
        if (pid == 0) { 
            if (hasSecondZygote(abiList)) {
                waitForSecondaryZygote(socketName);
            }
            zygoteServer.closeServerSocket();
            return handleSystemServerProcess(parsedArgs);
        }
        // 父进程什么也不做
        return null;
    }
```

2、Zygote.java frameworks\base\core\java\com\android\internal\os\Zygote.java
```java
    static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {

        int pid = nativeForkSystemServer(
                uid, gid, gids, runtimeFlags, rlimits,
                permittedCapabilities, effectiveCapabilities);

        return pid;
    }

// 核心作用：调用底层fork()
    private static native int nativeForkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,
            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities);
```

3、ZygoteInit.java frameworks\base\core\java\com\android\internal\os\
```java
private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) 
    
    ClassLoader cl = createPathClassLoader(systemServerClasspath, parsedArgs.mTargetSdkVersion); ===> PathClassLoader

    return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                    parsedArgs.mDisabledCompatChanges,
                    parsedArgs.mRemainingArgs, cl);
}
```

4、ZygoteInit.java frameworks\base\core\java\com\android\internal\os\
```c++
    public static final Runnable zygoteInit(xxx) {
        //1. 初始化运行环境
        RuntimeInit.commonInit();//初始化运行环境 
        //2. 启动Binder ，方法在 androidRuntime.cpp中注册       
        ZygoteInit.nativeZygoteInit();
        //3. 通过反射创建程序入口函数的 Method 对象，并返回 Runnable 对象
        // ActivityThread.main
        return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader);
    }

    protected static Runnable applicationInit(xxx, ClassLoader classLoader) {
        // startClass: 如果AMS通过socket传递过来的是 ActivityThread
        return findStaticMain(args.startClass, args.startArgs, classLoader);
    }
```

#### RuntimeInit.commonInit

framworks\base\core\java\com\android\internal\os\
```java
    protected static final void commonInit() {
        if (DEBUG) Slog.d(TAG, "Entered RuntimeInit!");

//1、设置异常处理器：
// 1. 设置未捕获异常的预处理器（pre-handler）为 LoggingHandler，用于处理未捕获的异常日志。
// 2. 设置默认的未捕获异常处理器为 KillApplicationHandler，用于处理应用程序崩溃并终止应用。 ===> ANR KillApplicationHandler
        LoggingHandler loggingHandler = new LoggingHandler();
        RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);
        Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler));

//2、设置日志管理器
        LogManager.getLogManager().reset();
        new AndroidConfig();

//3、关联套接字标记和流量统计：
        NetworkManagementSocketTagger.install();
// 省略
        initialized = true;
    }
```

### 答疑

1、先分配进程还是先分配虚拟机？
1. 先分配进程
1. 再分配虚拟机：虚拟机是一段代码，并且实现了内存管理


## SystemServer
### 创建Context
1、SystemServer的启动流程
```
run()
->createSystemContext()
  ->1. 创建ActivityThread，并且activityThread.attach(true, 0)
    -> 把自己的ApplicationThread（binder对象）交给了AMS
  ->2. 创建ContextImpl并且设置
```

