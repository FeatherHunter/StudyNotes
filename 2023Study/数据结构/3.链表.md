

# 链表

1、链表的复杂度

1.  插入、删除：O(1)
2.  随机访问：O(n)

2、淘汰缓存算法是什么？

1.  LRU
2.  应用场景：CPU缓存、数据库缓存
3.  有哪些缓存淘汰算法？1.FIFO 先进先出 2.LFU 最少使用 3.LRU 最近最少使用

3、链表的结构有哪些？

1.  单链表
2.  循环链表
3.  双向循环链表

4、哨兵节点可以帮助编程

5、LRU的实现方式

1.  满删尾
2.  新插头
3.  新放头

6、LinkedHashMap和链表的关系

1.  采用LRU策略的双向循环链表
2.  有序性：让HashMap具有有序性
3.  又具有HashMap，查找，插入，删除的高性能


## 链表 ==> LRU Glide
1. 插入、删除O(1)
2. 查找O(n)
结构：单链表、双向链表、循环链表
LRU缓存算法：新插头，用插头，满删尾
LinkedHashMap：用了双向循环链表，符合LRU需求
### 【字符串单链表存储，如何判断是否是回文字符串？】
一直入栈，相同的就出栈，遍历后栈空代表是回文
### 约瑟夫问题
### 哨兵
带头链表，可以简化：
1. 插入排序
2. 归并排序
3. 动态规划
### 实战【206 141 21 19 876】
### 实现技巧
1. 警惕指针丢失
2. 哨兵
3. 重点处理边界条件：头、尾、空、一个元素、两个元素
4. 画图法、举例法

### 快慢指针
快2步，慢1步
#### 判断单链表是否有环
#### 判断两个单链表相交得的第一个交点 
都无环，等效于160判断
一个有环，一个无环，一定不想交
两个都有环，情况分三种：
1. loop1和loop2相等，把loop1/loop2作为终止节点，当做160处理。
2. 从loop1开始next找，找loop2，
   1. 不存在，不相交
   2. 存在，相交在loop1或者loop2
a和b，右侧第一个bit为1的位
a&(-b)
归并 稳定
堆 O(1)

## Leetcode

【剑指 Offer 24. 反转链表】
【83. 删除排序链表中的重复元素】
【237. 删除链表中的节点】
【203. 移除链表元素】

## 链表 
>234回文链表
>LCR 018. 验证回文串
>148. 排序链表
>61. 旋转链表
>138/剑指Offer35. 复制带随机指针的链表
>160
>142.环形链表II
>287.寻找重复数
>剑指 Offer 22. 链表中倒数第k个节点

常用技巧：快慢指针

LCR 022. 环形链表 II [Title](https://leetcode.cn/problems/c32eOV/)

面试题 02.06. 回文链表：[Title](https://leetcode.cn/problems/palindrome-linked-list-lcci/)
