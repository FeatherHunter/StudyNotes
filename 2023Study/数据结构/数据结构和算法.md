
1、复杂度是指什么？

1.  又称为渐进复杂度
2.  代表和数据规模的增长关系

2、复杂度的两个维度：时间、空间

1.  时间：时间和数据规模的增长关系
2.  空间：空间和数据规模的增长关系

3、复杂度分为四个标准

1.  最好
2.  最坏
3.  平均 => 同一代码在不同情况下时间复杂度有量级区别的时候，才有用
    1.  涉及到概率论(加权平均值、期望值)
    2.  又称为“加权平均复杂度/期望复杂度”
4.  均摊
    1.  摊还分析法（把操作耗时多的平摊到耗时操作少的）
    2.  一般等于最好情况 => 一种特殊的平均复杂度

## 数组

1、数组是一种线性表：数据像一条线
2、连续的内存空间，存储相同类型的数据 => 支持随机访问

3、线性表有哪些？

1.  链表
2.  数组
3.  队列
4.  栈

4、数组的实战场景：卡表

1.  卡表的一种实现方式是字节数组
2.  JVM堆分为一个个512Byte的卡页
3.  卡表：用于记录卡页状态

5、数组的复杂度

1.  时间复杂度：
2.  支持随机访问，复杂度是O(1)
3.  查找：适合二分查找 O(logn)
4.  插入：O(n)
5.  删除：O(n)
6.  空间复杂度：O(n)

6、数组在插入和删除上的优化

1.  插入：index上原有的数据插入到数组尾部，index放入要插入的值 => 破坏原有顺序
2.  删除: 不删除只标记，后续一次性删除。
3.  两者的平均复杂度O(n), 最好O(1)

7、为什么数组下标从0开始？

1.  数组下标代表偏移量
2.  数组名代表首地址
3.  取元素的地址 = 首地址 + index \* 数据typesize
4.  这样实际是减少了一次减法指令，性能效率提升

8、多维数组

1.  多维数组概念上是多维的
2.  实际上是一维数组

9、数组有什么好处？

1.  可以借助CPU缓存机制（地址连续）
2.  扩容可以用系统copy方法实现

10、数组内部在物理内存上存储是反向的

1.  a\[3]三个元素
2.  a\[2]存储在低地址
3.  a\[0]存储在高地址
4.  小端字节序：对CPU、性能更好

## 链表

1、链表的复杂度

1.  插入、删除：O(1)
2.  随机访问：O(n)

2、淘汰缓存算法是什么？

1.  LRU
2.  应用场景：CPU缓存、数据库缓存
3.  有哪些缓存淘汰算法？1.FIFO 先进先出 2.LFU 最少使用 3.LRU 最近最少使用

3、链表的结构有哪些？

1.  单链表
2.  循环链表
3.  双向循环链表

4、哨兵节点可以帮助编程

5、LRU的实现方式

1.  满删尾
2.  新插头
3.  新放头

6、LinkedHashMap和链表的关系

1.  采用LRU策略的双向循环链表
2.  有序性：让HashMap具有有序性
3.  又具有HashMap，查找，插入，删除的高性能

# 算法题

1、字符串用单链表存储，如何判断是否是回文字符串？

1.  一直入栈，遇到相同的字符就出栈
2.  栈空为回文字符串

2、约瑟夫问题

3、LeetCode-2 两数相加

=====================================


## 哈希算法
### 哈希冲突
开放寻址法
公共溢出区

### 对称/非对称加密
对称：相同秘钥，AES、DES、3DES
非对称：RSA、DSA、ECC

#### MD5
1. HASH算法的应用，进行信息摘要
2. 散列到32byte，128bit的字符串
3. 不可逆、敏感

## 二叉树
红黑树：平衡二分查找树
完全二叉树：去除最后一层为满二叉树，最后一层节点从左到右排序
遍历：
深度：前，中，后
广度：层次遍历
前序遍历(递归)：
```java
public void travPre(BinaryNode root){
    root.value;
    travPre(root.left);
    travPre(root.right);
}
```
前序遍历(非递归)：
```java
public void travPre(BinaryNode root){
    ArrayDeque<BinaryNode> stack = new ArrayDeque();
    BinaryNode cur = root;
    while(cur != null || !stack.isEmpty()){
        if(cur != null){
            // 输出 cur.value 中序
            stack.push(cur);
            cr = cur.left
        }else{
            cur = stack.pop();
            // 输出 cur.value 前序，先序
            cur = cur.right;
        }
    }
}
```
后序遍历(非递归)：
```java
public void travPost(BinaryNode root){
    ArrayDeque<BinaryNode> stack = new ArrayDeque();
    BinaryNode pre = null;
    BinaryNode cur = null;
    stack.push(root);
    while(!stack.isEmpty()){
        cur = stack.peek();
        if((cur.left == null && cur.right == null)
            ||(pre != null && (cur.right == pre || cur.left == pre))){
            // 输出 cur.value 后序
            pre = cur;
            stack.pop(); // 当前节点访问结束了
        }else{
            // 先加右边，再加左边。弹出来的优先是左边。
            if(cur.right != null) stack.push(cur);
            if(cur.left != null) stack.push(cur);
        }
    }
}
```




# 极客
# 数据结构基本概念
1、如何判断算法的优劣？
1. 时间复杂度 （流程决定）
2. 额外空间复杂度（流程决定）
3. 常数项时间（细节决定）
2、时间复杂度：
1. 一定是发散的
2. 可以判断出算法发散的速度（发散慢的更好些
3. O 最差时间复杂度
4. _n_ 平均
5. O- 最好
3、额外空间复杂度
1. 需求要求的，实现目的的空间，不算在空间复杂度
4、时间复杂度一致时，看常数项时间，怎么看？大量数据实际运行。理论分析是没用的
5、什么是最优解？
1. 时间复杂度最好的情况下，看空间复杂度
2. 常数项没意义（和思想无关）
6、时间复杂度排名
1. 1、logn、n、nlogn、n^2、2^n
## 对数器 =>【可以深入】
对数器思路：
1. 生成随机数组
2. 算法A和算法B测试，输出结果
3. 结果数组比对，不一样的时候输出。
4. 说明：有一个出错了，输出结果，调整算法。继续测试。
5. 如果一致，重复比较，比如五十万次。
## 二分法
1、时间复杂度O(1og2N)=O(logN) 默认2为底。
> lgN 10为底
> lnN e为底
> log5N,不是2为底，但都可以忽略常数项，写logN
2、有序才可以二分吗？
1. 不是，能构建左右淘汰策略也可以二分
3、局部最小，无需数组，任意相邻的数不相等。一个数小于左边，小于右边，代表局部最小。找到一个即可。
1. 可以二分
2. 边界条件看0和n-1是否是局部最小，直接返回
3. 思路：mid > left 到左边找，mid < left 并且 mid > right 到右边找 
## 异或
1、异或可以理解为不同为1，相同为0 => 可以理解为无进位相加
2、0 ^ N = N
3、N ^ N = 0
4、异或满足交换律和结合律，随便交换位置都可以。
### 两数交换
题目一
```java
// a和b不能是同一块内存区域
a = a^b;
b = a^b;
a = a^b;
```
### 奇数次
题目二
一个数组中，一个数出现奇数次，其他数出现了偶数次。
```java
// 遍历
int r = 0;
r = r ^ a[i]; // 偶数次都被消除了
return r; 
```
题目三：整形数，右侧的1提取出来。
```c
a  = 0110 1110 0001 0000
~a = 1001 0001 1110 1111
~a+1=1001 0001 1111 0000
ans = a & (~a + 1) = a & (-a)//~a+1是补码，等于取负数
ans= 0000 0000 0001 0000
```
题目四：数组中，两种数出现奇数次，其他出现偶数次，找到并打印这两种数 ===> 【LeetCode.260】
```c
1. eor ^= xxx遍历xxx = a ^ b, 因为 a != b, 一定某一位为1
2. ans = eor & (-eor) // 找到该1，该位置上 a 和 b，一定不一样.===> 利用该数值进行分类
//数组可以分为两类，第一类该位=1，第二类该位=0
3. a = eor1 ^= 遍历，第三位 = 1的数 // 第一类中，偶数个其他数 + 奇数次的a或者b
4. b = eor1 ^ eor// 拿到另一个数
```
思路总结：
1. eor = 所有数据异或 = a ^ b
2. 找到eor中右侧第一个为1的数，a和b既然不一样，一定有
3. a = 所有该位=1的数 异或
4. b = eor ^ a 消除
题目五：数组中一种数出现k次，其他数出现M次，`M>1 K<M`,找到出现了K的数字，额外空间复杂度O(1) ===>【137. 只出现一次的数字 II】
比如：一个数出现3次，其他的出现5次。
```c
1. int t[32] = new int[32]; // O(1)
2. 所有数字的每一位加到数组中  // t[0] = 37, 所有在第0位有1的数都加进来了。3次的有甲个，5次的有乙个。一定是M的整数倍 + K
```
## 链表
【剑指 Offer 24. 反转链表】
【83. 删除排序链表中的重复元素】
【237. 删除链表中的节点】
【203. 移除链表元素】



======================================


# 极客
## 复杂度
渐进复杂度：时间、空间，和数据规模的增长关系
最坏：O
最好：少用
平均：概率论（加权平均值、期望值）=> 加权平均（期望）复杂度 => 统一代码在不同情况时间复杂度有量级区别，才使用
均摊：摊还分析法 
1. 把操作耗时多的，平摊到耗时邵德。
2. 一般等于最好情况 => 一种特殊的平均复杂度
2、O（nlogn）好于O（n^2）?
1. 特定情况需要看常数项
2. 常数项的性能，只能实际数据测试，理论无法推导
3. 不同常数操作在实际情况下运算效率都不相同
## 数组 ===> 卡表
线性表：数据像一条线，连续的内存空间，存相同类型的数组
随机访问：O(1) =======> JVM卡表，一种实现方式字节数组；JVM堆分为512byte卡页，卡表记录卡页状态状态。
ArrayList：支持动态扩容，1.5
数组下标本身是偏移量：a[10] a：表首地址 10：表首地址 + 10 * typesize，少一次减法操作效率更高
数组可以借助CPU缓存机制
数组扩容用Array的Copy实现
多维数组实际上也是一位数组
### 优化
1、数组插入：需要移动的数据，直接放到尾部O(1)
2、删除：不删除，只记录，要用时，一次性删除，直接移动 O(n)
ArrayList: 支持动态扩容，1.5BEI
## 链表 ==> LRU Glide
1. 插入、删除O(1)
2. 查找O(n)
结构：单链表、双向链表、循环链表
LRU缓存算法：新插头，用插头，满删尾
LinkedHashMap：用了双向循环链表，符合LRU需求
### 【字符串单链表存储，如何判断是否是回文字符串？】
一直入栈，相同的就出栈，遍历后栈空代表是回文
### 约瑟夫问题
### 哨兵
带头链表，可以简化：
1. 插入排序
2. 归并排序
3. 动态规划
### 实战【206 141 21 19 876】
### 实现技巧
1. 警惕指针丢失
2. 哨兵
3. 重点处理边界条件：头、尾、空、一个元素、两个元素
4. 画图法、举例法
## 栈 => 函数调用栈（JVM虚拟机栈）
时间复杂度：O(1)
空间复杂度：O(1)
## 应用
函数调用栈
表达式求值
1. 准备：操作数栈、运算符栈
1. 数字入栈
2. 运算符比栈顶优先级高（x>+）入栈
3. 低/相等：出栈两个数字和一个运算符，运算
括号匹配
## LeetCode【20,155,32,44,24,82,96】
## 递归
1、如何递归？
1. 写出递归公式（大问题化为小问题）
2. 找到终止条件
3. ！不要用人脑取分解递归的每个步骤
4. 警惕重复计算：可以用散列表缓存求解的数值
2、递归优点和缺点
1. 表达能力强，简洁
2. 空间复杂度高
3. 重复计算
4. 有堆栈溢出风险
5. 过多函数调用
### Master公式
求递归时间复杂度：
T(N) = a * T(N/b) + O(N^d), a b d常数
logb底a < d => O(N^d)
logb底a > d  => O(N^(logb底a))
logb底a = d  => O(N^d * logN)
## 排序
冒泡、插入、选择 O(n^2) 基于比较
归并、快速 O(nlogn) 基于比较
桶排序、计数、基数 O(n) 不基于比较
原地排序算法：空间复杂度O(1)，如冒泡、插入、选择
稳定性：排序后，相等元素之间原先顺序不变，冒泡(相等时不要交换)、插入
有序度：数组有序关系的元素对个数。（2,4,3）有序度2 (2,4)(2,3)
满有序度：完全有序
逆有序度：满有序度-有序度
交换次数=逆有序度
### 选择排序
1. 非稳定排序
2. 不好的算法，最好，最坏，平均都是O(n^2)
### 插入排序
插入排序永远好于冒泡排序：归并排序
### 归并排序
1. 空间复杂度 O(N)=> 每次分配空间后都会释放，因此O(n) => 非原地排序算法
2. 时间复杂度 O(NlogN)
#### 递归版本
根据递归函数，构造出master公式
1. 2 * T(n/2) + O(n) => 不要想递归里面的东西，merge这一层就是O(n)
2. a=2 b=2 d=1 O(N*logN)
#### 非递归
思路：
1. 步长，第一轮步长1，后续是2，4，8，16
2. 时间复杂度：每次都要遍历所有数O(n),要走几轮呢？N向上取整 = O(logN)
3. 最终：O(NlogN)
### 快速排序
归并排序：从下到上，先处理子问题，再合并
快速排序：从上到下，先分区，再处理子问题
快速排序的时间复杂度：O(nlogn)最坏O(n^2)
#### 荷兰国旗问题
一个数组， <=x放左边，或者>=x放右边，或者 <左边 >右边 = 中间
1. 左边和右边可以无序，没有要求
2. 空间复杂度O(1)
2、解题
1. 左侧设置 <= 区域
2. 当前数 <= 目标数，当前数和小于等于区域的下一个数交换，区域右扩
3. 当前数 > 目标数，跳下一个
#### 优化
快速排序最差O(n^2)是分区点不理想导致的（最好要平分）
1. 三数取中：首尾中，取中值，范围太大就五数，十数
2. 随机法：随机，概率学中
#### glibc中qsort
1. 分区点：三数取中
2. 栈：堆上实现栈，手动模拟递归
3. 元素数《=4，用插入
4. 数据量小：归并
5. 数据量大：快速
### TimSort
1、归并、二分、插入混合体号称世界上最好的排序
> Python标准库
### 线性排序
#### 桶排序：按年龄给一百万用户排序
适用场景：将数据划分到几个有序桶内，桶内快速排序
数据：N
桶：M
每个桶：N/M=k个数据
每个桶快速排序：O(K*logK) = O(N/M * logN/M)
M个桶 = m*O(K*logK) = m * O(N/M * logN/M) = N * logN/M, 若m接近于n， =O(N)
##### 外部排序
适合外部排序：数据存储在外部磁盘中，内存有限，无法全部加载到内存中。
#### 计数排序：高考分排序，年龄排序
计数排序：桶的特殊情况
每个桶内数值相同，如高考分：0~900分，分为901个桶，不再需要桶内排序
特点：
1. 数据范围不能远大于排序的数据n
2. 只能是非负整数
题目：8个考生，数组A[2,5,3,0,2,3,0,3]，按照分数排名
构造出人数数组C[2,2,4,7,7,8] 下标是分数(0~5)
最终排名数组R[ , , , , , , , ] 下标是排名，内容是分数
逻辑思路：A从A[7]遍历到A[0]
1. A[7]=3，找到C[3]=7,代表需要放置于R[7-1]=R[6]，放入3。C[3]中7-1=6
2. 一点点将分数，根据人数，放置到R
#### 基数排序：十万手机号排序
1.范围11位，但范围太大，不适合计数排序
思路：先按最后一位排序，依次到第一位（用稳定排序算法）
1. 每位用桶排序/计数排序，总O(K+N),因为K=11，=O(N)
2. 不等长的数据，后面补0至登场。
3. 要求：可以分出独立为，a的高位>b的高位，表示a>b
4. 每一位范围不能太长，如0~9，否则不能为O(N)
##### 题目二：D a F B C A z
小写在大写前面，内部不能排序
思路：分小写桶、大写桶，再依次取出（桶排序）
## 有序表
红黑树、avl、sb树、跳表
## TreeMap
1. 支持 ===> Glide
1. 用红黑树实现
1. 有序表
2. firstKey 最小的key
1. lastKey 最大的key
2. floorKey(4) <=4 离4最近的key
3. ceilingKey(4) >=4 离4最近的key  ====> Glide找到能缓存buffer的
1. 时间复杂度只能做到O(logN)
// 增删改查
O(logN)
## 散列表
### HashMap
HashMap存Node，Node里面有String是整个小说，占用多大？8Byte
HashMap<Integer, String>按数值传递String？
HashMap存入基本数据类型的包装类，判断是否存在时，判断值。
其他对象判断引用。



------------------------------

# 0826

---------------------------------

## 快速排序
时间复杂度：随机优化后O(NlogN)
空间复杂度：最差O(N^2)，最好O(logN)。数学推导最终为O(logN)
### 快速排序 3.0
递归版本：
```java
void quickSort3(int[] arr){
    process3(arr, 0, arr.length - 1);
}
void process3(int[] arr, int L, int R){
    if(L < R){
        swap(arr, R, L + (int)(Math.random() * (R - L + 1)));
        int[] equalArea = netherlandsFlag(arr, L, R);
        process3(arr, L, equalArea[0] - 1);
        process3(arr, equalArea[1] + 1, R);
    }
}
int[] netherlandsFlag(int[] arr, int L, int R){
        int[] ans = new int[2];
        if(L < 0 || R >= arr.length){
            ans[0] = -1;
            ans[1] = -1;
            return  ans;
        }
        // 返回相等区域的左边和右边
        int less = L - 1;
        int more = R;
        int index = L;
        while(index < more){
            if(arr[index] < arr[R]){
                swap(arr, index++, ++less);
            }else if(arr[index] > arr[R]){
                swap(arr, index, --more);
            }else{
                index++;
            }
        }
        swap(arr, R, more);
        ans[0] = less + 1;
        ans[1] = more - 1;
        return ans;
}
```
3.0好处是什么？
> 会有最差情况
> 随机数，避免最差情况的几率。
> 原先时间复杂度O(N^2)
时间复杂度公式
> T(N)=O(N)+2*T(N/2)
> a=2 b=2 d = 1
> = O(NlogN)
#### 非递归
手动模拟栈
```java
    public void quickSort3ByStack(int[] nums) {
        // 手动模拟递归
        Deque<OP> stack = new ArrayDeque<>();
        stack.push(new OP(0, nums.length - 1));
        while (!stack.isEmpty()){
            OP op = stack.pop();
            if(op.l < op.r){
                swap(nums, op.l + (int)(Math.random()*(op.r-op.l+1)), op.r);
                int[] equalArea = netherlandsFlag(nums, op.l, op.r);
                stack.push(new OP(op.l, equalArea[0] - 1)); // 左侧入栈
                stack.push(new OP(equalArea[1] + 1, op.r)); // 右侧入栈
            }
        }
    }
```
### Master公式
求递归时间复杂度：
T(N) = a * T(N/b) + O(N^d), a b d常数
logb底a < d => O(N^d)
logb底a > d  => O(N^(logb底a))
logb底a = d  => O(N^d * logN)
## 堆 Heap
各个语言使用的名字：优先级队列
PriorityQueue：底层堆实现
数据结构名：堆
### 堆结构
#### 完全二叉树
1、完全二叉树是什么？
> 树满的就是完全二叉树
```c
   1
 2   3
4 5 // 每一层从左往右完全变满
```
2、连续的数组就是完全二叉树
1. 空树是不是完全二叉树？是
1. 一个节点是完全二叉树
1. 一个数每一层从左往右满的，就是完全二叉树
1. 堆就是完全二叉树一行行展开：1234567
3、节点i和左右孩子、父亲关系
```
左：2*i + 1
右：2*i + 2
父亲：
（i-1）/2 ，取整，左右节点都可以。
```
#### 大根堆
1. 每个节点都>=子树中每个阶段：大顶堆
2. 每个节点都<=子树中每个阶段：小顶堆
#### 堆化
构建大顶堆：
```kotlin
    var arr = intArrayOf(-1, 1, 7, 9, 3, 5, 2, 7, 0, 4, 5, 8, 1)
    for(i in 0 until arr.size){
        Heap.heapInsert(arr, i);
    }
    println(arr.contentToString())
输出：
[9, 7, 8, 7, 5, 5, 2, -1, 0, 3, 4, 1, 1]
```
##### 插入
1、大根堆/大顶堆 插入流程：插入数据会导致不符合要求，按以下流程进行堆化
1. 从下往上
2. 和父节点比较，> 父节点，交换
3. 父节点：(i - 1) / 2
```java
    static public void heapInsert(int[] arr, int index){
        while(arr[index] > arr[(index - 1)/2]){
            swap(arr, index, (index-1)/2);
            index = (index - 1) / 2;
        }
    }
```
2、小根堆/小顶堆，相反
##### 删除堆顶
1. 数组末尾值交换到堆顶 => 满足堆定义（完全二叉树）
2. 堆化：从上至下，父子比较，较大的子节点和父节点，交换 => 满足，大顶堆定义
```java
    static public void heapify(int[] arr, int i, int heapsize){ // 从i往下heapify
        int index = i; 
        int left;
        int right;
        int max;
        while(index < heapsize && (left = 2 * index + 1) < heapsize){
            // 必须存在叶子节点，才有处理价值
            if((right = 2 * index + 2) < heapsize){ // 存在右侧儿子
                if(arr[left] < arr[right]){
                    max = right;
                }else{
                    max = left;
                }
            }else{
                max = left;
            }
            if(arr[index] < arr[max]){
                swap(arr, index, max);
                index = max;
            }else{
                break; // 跳出// 父节点，最大了。
            }
        }
    }
```
小顶堆，和较小的交换。
### 堆排序
1、堆排序
1. 原地排序
2. O(NlogN)
3. 不稳定（末尾、头会交换）
2、堆排序和快速排序比较？为什么用快速排序更多？
1. 堆排序：跳着访问，对CPU缓存不友好
2. 快速排序：顺序访问
3. 堆排序：第一步建堆会打乱原有顺序，有序顺序反而无序，降低效率
4. 快速排序：不会打乱原有顺序
5. 堆排序：交换次数多余快速排序
3、堆排序优点：时间复杂度稳定
4、堆排序实现顺序，时间复杂度
1. 建堆 O(N)
2. 排序 O(nlogn) ：n个元素，堆化n次，一次堆化O(logn)=O(n * logn)
3. 总共：O(nlogb)
5、Java中PriorityQueue默认是小顶堆
6、要点
1. heapInsert是节点往上移动
2. heapify是节点往下移动
7、堆排序代码
1. 构建大顶堆，输出堆顶
1. 删除堆顶后，堆化调整
8、堆复杂度
1. N个元素的堆，有多高？logN
2. insert：时间复杂度O(logN)(只和父比较，次数就是堆高度，logN)
3. heapify：树的高度，O(logN)
4. 堆排序：n个元素，logN = O(NlogN)
#### 代码
思路：
1. 构建大顶堆
2. 将大顶堆数据放到末尾，heapsize-1，就等于不考虑这个数据了
3. 剩下数据进行堆化
4. 直至heapsize=0
```kotlin
    static public void heapSort(int[] arr){
        // 构建大顶堆
        for (int i = 0; i < arr.length; i++) { //O(N)
            heapInsert(arr, i); //O(logN)
        }
        int heapsize = arr.length;
        while(heapsize > 0){ // O(N)
            swap(arr, 0, --heapsize); //O(1)
            heapify(arr, 0, heapsize); //O(logN)
        }
    }
```
复杂度分析：
> O(NlogN) + O(NlogN) = O(2NlogN) = O(NlogN)
##### 建堆优化 O(N)
思路：从尾部节点开始heapify(对于排序适合，如果是数据一个个提供，只能从上往下)
推导过程：
```c
//最后一层N/2个节点，看1层
//倒数第二层 N/4个节点，看2层
//倒数第三层 N/8个节点，看3层
//时间复杂度：O(N)
T(n) = N/2 + N/4 * 2 + N/8 * 3 ...
2T(n) = N + N/2*2 + N/4*3 ...
相减 T(n) = N + N/2 + N/4 + N/8 +...(等比数列求和) < 2N
```
时间复杂度O(N)
**为什么？**
从上往下：节点越来越多
从下往上：节点越来越少
**最终时间复杂度O(N + NlogN) = O(NlogN)**
#### 应用
1. 优先级队列
2. 求TopK
3. 求中位数
1、合并有序小文件（100个100MB文件）
1. 每个小文件取一个字符串，构建小顶堆，删除堆顶，放入大文件中
2. 再取该文件下一个字符串插入堆：时间 = 删堆顶 + 插入 O(logn) + O(logn) = O(logn)
2、高性能定时器
1. 多个任务需要定时执行 ==========================> Handler
2. 将多个小任务用小顶堆存储，以堆顶时间进行等待
3、求Top K：前K大的数（静态数据）
1. 维护大小为K的小顶堆，先填满堆顶（放入K个数）
2. 遍历数组，数据>堆顶，删除堆顶，插入新数据，并且堆化
3. 数具<堆顶，不做处理
4. 最终，小顶堆中数据就是 前K大 的数据
4、求Top K：前K大的数（动态数据）
1. 实时添加数据，实时查询前K大
2. 如果每次重新计算为：O(nlogK)
3. 如果每次插入时计算：插入新数据和堆顶比较，>，删除堆顶，插入数据，O(logK)
5、求99%的响应时间(99百分位数)
1. 建立两个堆：
2. 1个99%大顶堆
3. 1个1小顶堆
6、如何在十亿个搜索关键字的日志文件中获取TOP10的关键字
1. 遍历，放入散列表中，已经存在就+1
2. 用储存的次数，构建10个容量的小顶堆，慢慢装填小顶堆
3. 【联机】用MapReduce
7、求中位数，若10亿个关键词，需要5GB内存，实际1GB内存。
1. 分为十个文件：哈希算法，对10取膜，分到十个文件
2. 对每个文件用HasMap+堆，求Top10
3. 是10个Top 10，用堆，求Top10。
##### 优先队列应用场景
1. 赫夫曼编码
2. 图的最短路径
3. 最小生成树算法
1、一个有小规律的数组，每个元素，移动不超过K步，就可以有序（K比N小很多），排序
> 如果K=5
> 取前5个数，构建小顶堆。顶部弹出放到下标0。
> while循环，加一个，弹出一个，不够加就一个一个弹出
> 时间复杂度：O（N*logK）N个元素，每个操作logK
### 最大线段重合问题
1、问题：一个已经构建好的大顶堆，出现一个节点数据被改变（可能大，可能小）要如何调整恢复大顶堆？
1. 先heapinsert
2. 在heapify
2、最大线段重合问题思路
1. 线段数组排序
2. 小顶堆
3. 遍历线段数组：堆中 < start的都出堆
4. 将end入堆，堆中数量为包含该start的线段数量。
5. 循环
2、复杂度：
1. 排序：O(nlogn)
2. 每个结尾：进一次弹出一次小顶堆 O(2n * logn)
3. O(n*logn)
### 手写堆（反向索引表）
如何删掉b？
1. 没有反向索引表，只能遍历再删除。 O(n) + O(logn)
2. 根据索引表找到那个点，删除，向下调整 O(logn)
```java
    static class HeapGreater<T>{
        ArrayList<T> heap;
        HashMap<T, Integer> indexMap;
        int heapSize;
        Comparator<? super T> comp;
        public HeapGreater(Comparator<T> c){
            comp = c;
            heap = new ArrayList<>();
            indexMap = new HashMap<>();
            heapSize = 0;
        }
        public boolean isEmpty(){
            return heapSize == 0;
        }
        public int size(){
            return heap.size();
        }
        public boolean contains(T item){
            return indexMap.containsKey(item);
        }
        public T peek(){
            return heap.get(0);
        }
        public void push(T item){
            heap.add(item);
            indexMap.put(item, heapSize);
            heapInsert(heapSize++);
        }
        public T pop(){
            T r = heap.get(0);
            swap(0, heapSize - 1); // 交换到末尾
            indexMap.remove(r);
            heap.remove(--heapSize); // 删除该节点
            heapify(0);
            return r;
        }
        private void swap(int a, int b){
            T t1 = heap.get(a);
            T t2 = heap.get(b);
            heap.set(a, t2);
            heap.set(b, t1);
            indexMap.put(t1, b); // 更新下标
            indexMap.put(t2, a);
        }
        private void heapInsert(int index){
//            System.out.println("");
//            System.out.println("heapInsert index = "+ index);
            while(comp.compare(heap.get(index), heap.get((index-1)/2)) < 0){
                swap(index, (index-1)/2);
                index = (index-1)/2;
            }
        }
        // 从index开始heapify
        private void heapify(int index){
            int left = 2 * index + 1;
            while(left < heapSize){
                // 存在右儿子，并且右儿子小于左儿子，才选右儿子
                int best = (left + 1 < heapSize && comp.compare(heap.get(left + 1), heap.get(left)) < 0)?(left + 1):left;
                // 叶子小于自己，处理
                if(comp.compare(heap.get(best), heap.get(index)) < 0){
                    swap(index, best);
                    index = best;
                    left = 2 * index + 1;
                }else {
                    break; //结束咯
                }
            }
        }
        public boolean replace(T oldVal, T newVal){
            if(contains(oldVal)){
                int index = indexMap.get(oldVal);
                heap.set(index, newVal);
                indexMap.put(newVal, index);
                indexMap.remove(oldVal);
                // 需要先向下调整，再向上调整
                heapify(index);
                heapInsert(index);
                return true; // 替换成功
            }else{
                return false;
            }
        }
    }
    static class Inner<T>{
        public T val;
        public Inner(T val) {
            this.val = val;
        }
    }
```

## 哈希表
1、哈希表插入是O(1)吗？不考虑数据长度
1. 如果是String = O(K)
2. 需要遍历String算出hash值
3. 大量String，需要算平均长度
## 前缀树 Prefix Tree、Trie Tree 
1. 查询字符串是否在？该字符串作为前缀出现几次？O(K)
```java
    // 小写字母
    public static class Node{
        int pass = 0;
        int end = 0;
        Node[] nexts = new Node[26];
    }
    public static class Trie{
        Node root = new Node();
        int size = 0; // 有多少个字符串构成的。
        public void insert(String word){
            size++; //调用几次insert插入几个字符串，null也会算在内
            if(word == null){
                return;
            }
            char[] arr = word.toCharArray();
            Node cur = root;
            cur.pass++;
            for (char c : arr) {
                if(cur.nexts[c-'a'] == null){
                    cur.nexts[c-'a'] = new Node();
                }
                cur = cur.nexts[c-'a'];
                cur.pass++;
            }
            cur.end++;
        }
        public void delete(){
        }
        // 搜索word加入过几次
        public int search(String word){
            if(word == null){
                return 0;
            }
            Node cur = root;
            char[] arr = word.toCharArray();
            for (char c : arr) {
                if(cur.nexts[c - 'a'] == null){
                    return 0;
                }
                cur = cur.nexts[c - 'a'];
            }
            return cur.end;
        }
        public int pre(String word){
            if(word == null){
                return 0;
            }
            Node cur = root;
            char[] arr = word.toCharArray();
            for (char c : arr) {
                if(cur.nexts[c - 'a'] == null){
                    return 0;
                }
                cur = cur.nexts[c - 'a'];
            }
            return cur.pass;
        }
        // 找到已有字符串中，包含的最大公共前缀。
        public String findMaxPrefix(){
            Node cur = root;
            int index = 0;
            String res = "";
            while(true){
                for (index = 0; index < cur.nexts.length; index++) {
                    if(cur.nexts[index] != null){
                        break;
                    }
                }
                if(index == cur.nexts.length || cur.nexts[index].pass != size){ // 代表要么结束了，要么两个节点
                    return res;
                }
                cur = cur.nexts[index];
                res += (char)(index + 'a');
            }
        }
    }
```
删除逻辑：判断+避免内存泄漏
```java
        public void delete(String word){
            if(search(word) < 1){
                return;
            }
            // 找到了哦
            Node cur = root;
            char[] arr = word.toCharArray();
            for (char c : arr) {
                cur.nexts[c-'a'].pass--;
                if(cur.nexts[c-'a'].pass == 0){
                    cur.nexts[c-'a'] = null;
                    return; // 结束了，直接斩断一切
                }
                cur = cur.nexts[c-'a'];
            }
            cur.end--; // 到最后一个节点，end--
        }
```
## 排序总结
||时间复杂度|空间复杂度|稳定性||
|---|---|---|---|---|
|选择|n2|1|X||
|冒泡|n2|1|||
|插入|n2|1|||
|归并|nlogn|n|稳||
|随机快速|nlogn|logn|X||
|堆|nlogn|1|X||
|计数|n|M|||
|基数|n|n|||
最快：快速
最省：堆
最稳：归并
### 工程和稳定性
1、稳定性：对基本数据类型之外的才有意义。
2、Java Arrays.sort()底层：
基本数据类型：快排
其他：归并排序
3、充分利用nlogn和n^2
1. 低于60，用插入排序，常数项小。
### 坑
## 链表
### 快慢指针
快2步，慢1步
#### 判断单链表是否有环
#### 判断两个单链表相交得的第一个交点 
都无环，等效于160判断
一个有环，一个无环，一定不想交
两个都有环，情况分三种：
1. loop1和loop2相等，把loop1/loop2作为终止节点，当做160处理。
2. 从loop1开始next找，找loop2，
   1. 不存在，不相交
   2. 存在，相交在loop1或者loop2
a和b，右侧第一个bit为1的位
a&(-b)
归并 稳定
堆 O(1)
## AC自动机
前缀树 + KMP
## 二叉树
先序遍历：头左右
中序遍历：左头右
后序遍历：左右头
递归方法中，会三次访问每个节点。
第123次访问：先序、中序、后序
### x节点的祖先节点
前序遍历，x节点，前面的集合
后序遍历，x节点，后面的集合
求交集：一定是x的祖先节点
**为什么？**
先序：头左右，x的所有祖先一定在左侧，x的所有孩子一定在右侧，x的左兄弟在左侧。
后序：左右头，x的所有祖先一定在右侧，x的所有孩子一定在左侧，x的右兄弟在右侧
所以：两个集合，为什么只有祖先，没有其他节点？
> 左侧：所有祖先+左兄弟。孩子一定在右。
> 右侧：所有祖先+右兄弟。孩子一定在左。
> 结论：左兄弟!=右兄弟，因此所有祖先是交集。
>
手动递归的意义：
使用内存，不使用方法栈，避免stackoverflow
### 微软：折纸
```java
// 想象构建二叉树
// 额外空间 O(N)树的深度
// 时间复杂度 O()
    public void printAllForTree(int N){
        process(1, N, true);
    }
    public void process(int i, int N, boolean isDown){
        if(i > N) return;
        process(i + 1, N, false);
        System.out.println((isDown)?"凹":"凸");
        process(i+1, N, false);
    }
```
## 图
所有图都可以认为是有向图。
无向图(可以认为双向)
### 实现
1、图的实现（笔试、面试很少用）
1. 邻接表法
1. 邻接矩阵
图如何表达？
图：难在表达
图：深度，栈
图：广度，队列 ====> 二叉树层序遍历
矩阵表达：
[3,0,7] 权重3，从0到7.
[5,1,2] 权重5，从1到2.
数组表达：
[3,1,1,1] 
a[0] = 3, 代表0节点到3节点的边
a[1] = 1, 1->1
a[2] = 1, 2->[1]
a[3] = 1, 3->1
### 抽象出熟悉的图结构
固定，该图结构的算法。
研究点：将目标结构转为自己熟悉的结构 ====> 适配器模式
```java
    class Node{
        int val;
        int in = 0;
        int out = 0;
        ArrayList<Node> nexts = new ArrayList<>(); // 从我出发能找到的点
        ArrayList<Edge> edges = new ArrayList<>(); // 从我出发能找到的边
        public Node(int val) {
            this.val = val;
        }
    }
    
    class Edge{
        int weight;
        Node from;
        Node to;
        public Edge(int weight, Node from, Node to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }
    class Graphic{
        LinkedHashMap<Integer, Node> nodes;
        HashSet<Edge> edges;
        public Graphic() {
            this.nodes = new LinkedHashMap<>();
            this.edges = new HashSet<>();
        }
    }
// 适配
    public Graphic adapteToGraphic(List<List<Integer>> rooms){
        Graphic graphic = new Graphic();
        graphic.nodes.put(0, new Node(0));
        for (int i  = 0; i < rooms.size(); i++) {
            List<Integer> room = rooms.get(i);
            Node from = graphic.nodes.get(i);
            for (Integer num : room) {
                if(!graphic.nodes.containsKey(num)){
                    graphic.nodes.put(num, new Node(num));
                }
                Node to = graphic.nodes.get(num);
                from.nexts.add(to);
                from.out++;
                to.in++;
                Edge newEdge = new Edge(0, from, to);
                graphic.edges.add(newEdge);
                from.edges.add(newEdge);
            }
        }
        return graphic;
    }
// 是否可以遍历所有节点。
    private boolean dfs(Graphic graphic){
        HashSet<Node> visited = new HashSet<>();
        Deque<Node> stack = new LinkedList<>();
        // 放入第一个节点
        stack.push(graphic.nodes.get(0));
        visited.add(graphic.nodes.get(0));
        while (!stack.isEmpty()){
            Node cur = stack.pop();
            for (Node next : cur.nexts) {
                if(!visited.contains(next)){
                    // 没有访问就
                    stack.push(cur);
                    stack.push(next);
                    visited.add(next); // 访问到了
                    break;
                }else{
                    // 没有访问到, 会遍历。
                }
            }
        }
        if(graphic.nodes.size() > visited.size()){
            return false;
        }
        return true;
    }
```
**841. 钥匙和房间**
# LeetCode
## Heap
LeetCode题目-215、295、347、414、480【滑动窗口中位数】
## Trie树(前缀树)
LeetCode-12、208、LCR 062、211. 添加与搜索单词 - 数据结构设计（Trie+dfs）
## 链表 
>234回文链表
>LCR 018. 验证回文串
>148. 排序链表
>61. 旋转链表
>138/剑指Offer35. 复制带随机指针的链表
>160
>142.环形链表II
>287.寻找重复数
>剑指 Offer 22. 链表中倒数第k个节点
## 二叉树
144. 二叉树的前序遍历 // 头左右
145. 二叉树的后序遍历 // 头右左 -> 左右头
94. 二叉树的中序遍历 // 
102. 二叉树的层序遍历
103. 二叉树的层序遍历 II
662. 二叉树最大宽度 // 看每一层的宽度 。按层遍历，编号保存
剑指 Offer 26. 树的子结构

