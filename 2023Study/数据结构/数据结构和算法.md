

## 哈希算法
### 哈希冲突
开放寻址法
公共溢出区

### 对称/非对称加密
对称：相同秘钥，AES、DES、3DES
非对称：RSA、DSA、ECC

#### MD5
1. HASH算法的应用，进行信息摘要
2. 散列到32byte，128bit的字符串
3. 不可逆、敏感

## 二叉树
红黑树：平衡二分查找树
完全二叉树：去除最后一层为满二叉树，最后一层节点从左到右排序
遍历：
深度：前，中，后
广度：层次遍历
前序遍历(递归)：
```java
public void travPre(BinaryNode root){
    root.value;
    travPre(root.left);
    travPre(root.right);
}
```
前序遍历(非递归)：
```java
public void travPre(BinaryNode root){
    ArrayDeque<BinaryNode> stack = new ArrayDeque();
    BinaryNode cur = root;
    while(cur != null || !stack.isEmpty()){
        if(cur != null){
            // 输出 cur.value 中序
            stack.push(cur);
            cr = cur.left
        }else{
            cur = stack.pop();
            // 输出 cur.value 前序，先序
            cur = cur.right;
        }
    }
}
```
后序遍历(非递归)：
```java
public void travPost(BinaryNode root){
    ArrayDeque<BinaryNode> stack = new ArrayDeque();
    BinaryNode pre = null;
    BinaryNode cur = null;
    stack.push(root);
    while(!stack.isEmpty()){
        cur = stack.peek();
        if((cur.left == null && cur.right == null)
            ||(pre != null && (cur.right == pre || cur.left == pre))){
            // 输出 cur.value 后序
            pre = cur;
            stack.pop(); // 当前节点访问结束了
        }else{
            // 先加右边，再加左边。弹出来的优先是左边。
            if(cur.right != null) stack.push(cur);
            if(cur.left != null) stack.push(cur);
        }
    }
}
```




# 极客
# 数据结构基本概念
1、如何判断算法的优劣？
1. 时间复杂度 （流程决定）
2. 额外空间复杂度（流程决定）
3. 常数项时间（细节决定）
2、时间复杂度：
1. 一定是发散的
2. 可以判断出算法发散的速度（发散慢的更好些
3. O 最差时间复杂度
4. _n_ 平均
5. O- 最好
3、额外空间复杂度
1. 需求要求的，实现目的的空间，不算在空间复杂度
4、时间复杂度一致时，看常数项时间，怎么看？大量数据实际运行。理论分析是没用的
5、什么是最优解？
1. 时间复杂度最好的情况下，看空间复杂度
2. 常数项没意义（和思想无关）
6、时间复杂度排名
1. 1、logn、n、nlogn、n^2、2^n
## 对数器 =>【可以深入】
对数器思路：
1. 生成随机数组
2. 算法A和算法B测试，输出结果
3. 结果数组比对，不一样的时候输出。
4. 说明：有一个出错了，输出结果，调整算法。继续测试。
5. 如果一致，重复比较，比如五十万次。
## 二分法
1、时间复杂度O(1og2N)=O(logN) 默认2为底。
> lgN 10为底
> lnN e为底
> log5N,不是2为底，但都可以忽略常数项，写logN
2、有序才可以二分吗？
1. 不是，能构建左右淘汰策略也可以二分
3、局部最小，无需数组，任意相邻的数不相等。一个数小于左边，小于右边，代表局部最小。找到一个即可。
1. 可以二分
2. 边界条件看0和n-1是否是局部最小，直接返回
3. 思路：mid > left 到左边找，mid < left 并且 mid > right 到右边找 
## 异或
1、异或可以理解为不同为1，相同为0 => 可以理解为无进位相加
2、0 ^ N = N
3、N ^ N = 0
4、异或满足交换律和结合律，随便交换位置都可以。
### 两数交换
题目一
```java
// a和b不能是同一块内存区域
a = a^b;
b = a^b;
a = a^b;
```
### 奇数次
题目二
一个数组中，一个数出现奇数次，其他数出现了偶数次。
```java
// 遍历
int r = 0;
r = r ^ a[i]; // 偶数次都被消除了
return r; 
```
题目三：整形数，右侧的1提取出来。
```c
a  = 0110 1110 0001 0000
~a = 1001 0001 1110 1111
~a+1=1001 0001 1111 0000
ans = a & (~a + 1) = a & (-a)//~a+1是补码，等于取负数
ans= 0000 0000 0001 0000
```
题目四：数组中，两种数出现奇数次，其他出现偶数次，找到并打印这两种数 ===> 【LeetCode.260】
```c
1. eor ^= xxx遍历xxx = a ^ b, 因为 a != b, 一定某一位为1
2. ans = eor & (-eor) // 找到该1，该位置上 a 和 b，一定不一样.===> 利用该数值进行分类
//数组可以分为两类，第一类该位=1，第二类该位=0
3. a = eor1 ^= 遍历，第三位 = 1的数 // 第一类中，偶数个其他数 + 奇数次的a或者b
4. b = eor1 ^ eor// 拿到另一个数
```
思路总结：
1. eor = 所有数据异或 = a ^ b
2. 找到eor中右侧第一个为1的数，a和b既然不一样，一定有
3. a = 所有该位=1的数 异或
4. b = eor ^ a 消除
题目五：数组中一种数出现k次，其他数出现M次，`M>1 K<M`,找到出现了K的数字，额外空间复杂度O(1) ===>【137. 只出现一次的数字 II】
比如：一个数出现3次，其他的出现5次。
```c
1. int t[32] = new int[32]; // O(1)
2. 所有数字的每一位加到数组中  // t[0] = 37, 所有在第0位有1的数都加进来了。3次的有甲个，5次的有乙个。一定是M的整数倍 + K
```
## 链表
【剑指 Offer 24. 反转链表】
【83. 删除排序链表中的重复元素】
【237. 删除链表中的节点】
【203. 移除链表元素】



======================================


# 极客
## 复杂度
渐进复杂度：时间、空间，和数据规模的增长关系
最坏：O
最好：少用
平均：概率论（加权平均值、期望值）=> 加权平均（期望）复杂度 => 统一代码在不同情况时间复杂度有量级区别，才使用
均摊：摊还分析法 
1. 把操作耗时多的，平摊到耗时邵德。
2. 一般等于最好情况 => 一种特殊的平均复杂度
2、O（nlogn）好于O（n^2）?
1. 特定情况需要看常数项
2. 常数项的性能，只能实际数据测试，理论无法推导
3. 不同常数操作在实际情况下运算效率都不相同
## 数组 ===> 卡表
线性表：数据像一条线，连续的内存空间，存相同类型的数组
随机访问：O(1) =======> JVM卡表，一种实现方式字节数组；JVM堆分为512byte卡页，卡表记录卡页状态状态。
ArrayList：支持动态扩容，1.5
数组下标本身是偏移量：a[10] a：表首地址 10：表首地址 + 10 * typesize，少一次减法操作效率更高
数组可以借助CPU缓存机制
数组扩容用Array的Copy实现
多维数组实际上也是一位数组
### 优化
1、数组插入：需要移动的数据，直接放到尾部O(1)
2、删除：不删除，只记录，要用时，一次性删除，直接移动 O(n)
ArrayList: 支持动态扩容，1.5BEI
## 链表 ==> LRU Glide
1. 插入、删除O(1)
2. 查找O(n)
结构：单链表、双向链表、循环链表
LRU缓存算法：新插头，用插头，满删尾
LinkedHashMap：用了双向循环链表，符合LRU需求
### 【字符串单链表存储，如何判断是否是回文字符串？】
一直入栈，相同的就出栈，遍历后栈空代表是回文
### 约瑟夫问题
### 哨兵
带头链表，可以简化：
1. 插入排序
2. 归并排序
3. 动态规划
### 实战【206 141 21 19 876】
### 实现技巧
1. 警惕指针丢失
2. 哨兵
3. 重点处理边界条件：头、尾、空、一个元素、两个元素
4. 画图法、举例法
## 栈 => 函数调用栈（JVM虚拟机栈）
时间复杂度：O(1)
空间复杂度：O(1)
## 应用
函数调用栈
表达式求值
1. 准备：操作数栈、运算符栈
1. 数字入栈
2. 运算符比栈顶优先级高（x>+）入栈
3. 低/相等：出栈两个数字和一个运算符，运算
括号匹配
## LeetCode【20,155,32,44,24,82,96】
## 递归
1、如何递归？
1. 写出递归公式（大问题化为小问题）
2. 找到终止条件
3. ！不要用人脑取分解递归的每个步骤
4. 警惕重复计算：可以用散列表缓存求解的数值
2、递归优点和缺点
1. 表达能力强，简洁
2. 空间复杂度高
3. 重复计算
4. 有堆栈溢出风险
5. 过多函数调用
### Master公式
求递归时间复杂度：
T(N) = a * T(N/b) + O(N^d), a b d常数
logb底a < d => O(N^d)
logb底a > d  => O(N^(logb底a))
logb底a = d  => O(N^d * logN)
## 排序
冒泡、插入、选择 O(n^2) 基于比较
归并、快速 O(nlogn) 基于比较
桶排序、计数、基数 O(n) 不基于比较
原地排序算法：空间复杂度O(1)，如冒泡、插入、选择
稳定性：排序后，相等元素之间原先顺序不变，冒泡(相等时不要交换)、插入
有序度：数组有序关系的元素对个数。（2,4,3）有序度2 (2,4)(2,3)
满有序度：完全有序
逆有序度：满有序度-有序度
交换次数=逆有序度
### 选择排序
1. 非稳定排序
2. 不好的算法，最好，最坏，平均都是O(n^2)
### 插入排序
插入排序永远好于冒泡排序：归并排序
### 归并排序
1. 空间复杂度 O(N)=> 每次分配空间后都会释放，因此O(n) => 非原地排序算法
2. 时间复杂度 O(NlogN)
#### 递归版本
根据递归函数，构造出master公式
1. 2 * T(n/2) + O(n) => 不要想递归里面的东西，merge这一层就是O(n)
2. a=2 b=2 d=1 O(N*logN)
#### 非递归
思路：
1. 步长，第一轮步长1，后续是2，4，8，16
2. 时间复杂度：每次都要遍历所有数O(n),要走几轮呢？N向上取整 = O(logN)
3. 最终：O(NlogN)
### 快速排序
归并排序：从下到上，先处理子问题，再合并
快速排序：从上到下，先分区，再处理子问题
快速排序的时间复杂度：O(nlogn)最坏O(n^2)
#### 荷兰国旗问题
一个数组， <=x放左边，或者>=x放右边，或者 <左边 >右边 = 中间
1. 左边和右边可以无序，没有要求
2. 空间复杂度O(1)
2、解题
1. 左侧设置 <= 区域
2. 当前数 <= 目标数，当前数和小于等于区域的下一个数交换，区域右扩
3. 当前数 > 目标数，跳下一个
#### 优化
快速排序最差O(n^2)是分区点不理想导致的（最好要平分）
1. 三数取中：首尾中，取中值，范围太大就五数，十数
2. 随机法：随机，概率学中
#### glibc中qsort
1. 分区点：三数取中
2. 栈：堆上实现栈，手动模拟递归
3. 元素数《=4，用插入
4. 数据量小：归并
5. 数据量大：快速
### TimSort
1、归并、二分、插入混合体号称世界上最好的排序
> Python标准库
### 线性排序
#### 桶排序：按年龄给一百万用户排序
适用场景：将数据划分到几个有序桶内，桶内快速排序
数据：N
桶：M
每个桶：N/M=k个数据
每个桶快速排序：O(K*logK) = O(N/M * logN/M)
M个桶 = m*O(K*logK) = m * O(N/M * logN/M) = N * logN/M, 若m接近于n， =O(N)
##### 外部排序
适合外部排序：数据存储在外部磁盘中，内存有限，无法全部加载到内存中。
#### 计数排序：高考分排序，年龄排序
计数排序：桶的特殊情况
每个桶内数值相同，如高考分：0~900分，分为901个桶，不再需要桶内排序
特点：
1. 数据范围不能远大于排序的数据n
2. 只能是非负整数
题目：8个考生，数组A[2,5,3,0,2,3,0,3]，按照分数排名
构造出人数数组C[2,2,4,7,7,8] 下标是分数(0~5)
最终排名数组R[ , , , , , , , ] 下标是排名，内容是分数
逻辑思路：A从A[7]遍历到A[0]
1. A[7]=3，找到C[3]=7,代表需要放置于R[7-1]=R[6]，放入3。C[3]中7-1=6
2. 一点点将分数，根据人数，放置到R
#### 基数排序：十万手机号排序
1.范围11位，但范围太大，不适合计数排序
思路：先按最后一位排序，依次到第一位（用稳定排序算法）
1. 每位用桶排序/计数排序，总O(K+N),因为K=11，=O(N)
2. 不等长的数据，后面补0至登场。
3. 要求：可以分出独立为，a的高位>b的高位，表示a>b
4. 每一位范围不能太长，如0~9，否则不能为O(N)
##### 题目二：D a F B C A z
小写在大写前面，内部不能排序
思路：分小写桶、大写桶，再依次取出（桶排序）
## 有序表
红黑树、avl、sb树、跳表
## TreeMap
1. 支持 ===> Glide
1. 用红黑树实现
1. 有序表
2. firstKey 最小的key
1. lastKey 最大的key
2. floorKey(4) <=4 离4最近的key
3. ceilingKey(4) >=4 离4最近的key  ====> Glide找到能缓存buffer的
1. 时间复杂度只能做到O(logN)
// 增删改查
O(logN)
## 散列表
### HashMap
HashMap存Node，Node里面有String是整个小说，占用多大？8Byte
HashMap<Integer, String>按数值传递String？
HashMap存入基本数据类型的包装类，判断是否存在时，判断值。
其他对象判断引用。



