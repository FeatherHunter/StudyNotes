

## 哈希算法
### 哈希冲突
开放寻址法
公共溢出区

### 对称/非对称加密
对称：相同秘钥，AES、DES、3DES
非对称：RSA、DSA、ECC

#### MD5
1. HASH算法的应用，进行信息摘要
2. 散列到32byte，128bit的字符串
3. 不可逆、敏感

## 二叉树
红黑树：平衡二分查找树
完全二叉树：去除最后一层为满二叉树，最后一层节点从左到右排序
遍历：
深度：前，中，后
广度：层次遍历
前序遍历(递归)：
```java
public void travPre(BinaryNode root){
    root.value;
    travPre(root.left);
    travPre(root.right);
}
```
前序遍历(非递归)：
```java
public void travPre(BinaryNode root){
    ArrayDeque<BinaryNode> stack = new ArrayDeque();
    BinaryNode cur = root;
    while(cur != null || !stack.isEmpty()){
        if(cur != null){
            // 输出 cur.value 中序
            stack.push(cur);
            cr = cur.left
        }else{
            cur = stack.pop();
            // 输出 cur.value 前序，先序
            cur = cur.right;
        }
    }
}
```
后序遍历(非递归)：
```java
public void travPost(BinaryNode root){
    ArrayDeque<BinaryNode> stack = new ArrayDeque();
    BinaryNode pre = null;
    BinaryNode cur = null;
    stack.push(root);
    while(!stack.isEmpty()){
        cur = stack.peek();
        if((cur.left == null && cur.right == null)
            ||(pre != null && (cur.right == pre || cur.left == pre))){
            // 输出 cur.value 后序
            pre = cur;
            stack.pop(); // 当前节点访问结束了
        }else{
            // 先加右边，再加左边。弹出来的优先是左边。
            if(cur.right != null) stack.push(cur);
            if(cur.left != null) stack.push(cur);
        }
    }
}
```

