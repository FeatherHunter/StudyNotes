

## 哈希算法
### 哈希冲突
开放寻址法
公共溢出区

### 对称/非对称加密
对称：相同秘钥，AES、DES、3DES
非对称：RSA、DSA、ECC

#### MD5
1. HASH算法的应用，进行信息摘要
2. 散列到32byte，128bit的字符串
3. 不可逆、敏感

## 二叉树
红黑树：平衡二分查找树
完全二叉树：去除最后一层为满二叉树，最后一层节点从左到右排序
遍历：
深度：前，中，后
广度：层次遍历
前序遍历(递归)：
```java
public void travPre(BinaryNode root){
    root.value;
    travPre(root.left);
    travPre(root.right);
}
```
前序遍历(非递归)：
```java
public void travPre(BinaryNode root){
    ArrayDeque<BinaryNode> stack = new ArrayDeque();
    BinaryNode cur = root;
    while(cur != null || !stack.isEmpty()){
        if(cur != null){
            // 输出 cur.value 中序
            stack.push(cur);
            cr = cur.left
        }else{
            cur = stack.pop();
            // 输出 cur.value 前序，先序
            cur = cur.right;
        }
    }
}
```
后序遍历(非递归)：
```java
public void travPost(BinaryNode root){
    ArrayDeque<BinaryNode> stack = new ArrayDeque();
    BinaryNode pre = null;
    BinaryNode cur = null;
    stack.push(root);
    while(!stack.isEmpty()){
        cur = stack.peek();
        if((cur.left == null && cur.right == null)
            ||(pre != null && (cur.right == pre || cur.left == pre))){
            // 输出 cur.value 后序
            pre = cur;
            stack.pop(); // 当前节点访问结束了
        }else{
            // 先加右边，再加左边。弹出来的优先是左边。
            if(cur.right != null) stack.push(cur);
            if(cur.left != null) stack.push(cur);
        }
    }
}
```




# 极客
# 数据结构基本概念
1、如何判断算法的优劣？
1. 时间复杂度 （流程决定）
2. 额外空间复杂度（流程决定）
3. 常数项时间（细节决定）
2、时间复杂度：
1. 一定是发散的
2. 可以判断出算法发散的速度（发散慢的更好些
3. O 最差时间复杂度
4. _n_ 平均
5. O- 最好
3、额外空间复杂度
1. 需求要求的，实现目的的空间，不算在空间复杂度
4、时间复杂度一致时，看常数项时间，怎么看？大量数据实际运行。理论分析是没用的
5、什么是最优解？
1. 时间复杂度最好的情况下，看空间复杂度
2. 常数项没意义（和思想无关）
6、时间复杂度排名
1. 1、logn、n、nlogn、n^2、2^n
## 对数器 =>【可以深入】
对数器思路：
1. 生成随机数组
2. 算法A和算法B测试，输出结果
3. 结果数组比对，不一样的时候输出。
4. 说明：有一个出错了，输出结果，调整算法。继续测试。
5. 如果一致，重复比较，比如五十万次。
## 二分法
1、时间复杂度O(1og2N)=O(logN) 默认2为底。
> lgN 10为底
> lnN e为底
> log5N,不是2为底，但都可以忽略常数项，写logN
2、有序才可以二分吗？
1. 不是，能构建左右淘汰策略也可以二分
3、局部最小，无需数组，任意相邻的数不相等。一个数小于左边，小于右边，代表局部最小。找到一个即可。
1. 可以二分
2. 边界条件看0和n-1是否是局部最小，直接返回
3. 思路：mid > left 到左边找，mid < left 并且 mid > right 到右边找 
## 异或
1、异或可以理解为不同为1，相同为0 => 可以理解为无进位相加
2、0 ^ N = N
3、N ^ N = 0
4、异或满足交换律和结合律，随便交换位置都可以。
### 两数交换
题目一
```java
// a和b不能是同一块内存区域
a = a^b;
b = a^b;
a = a^b;
```
### 奇数次
题目二
一个数组中，一个数出现奇数次，其他数出现了偶数次。
```java
// 遍历
int r = 0;
r = r ^ a[i]; // 偶数次都被消除了
return r; 
```
题目三：整形数，右侧的1提取出来。
```c
a  = 0110 1110 0001 0000
~a = 1001 0001 1110 1111
~a+1=1001 0001 1111 0000
ans = a & (~a + 1) = a & (-a)//~a+1是补码，等于取负数
ans= 0000 0000 0001 0000
```
题目四：数组中，两种数出现奇数次，其他出现偶数次，找到并打印这两种数 ===> 【LeetCode.260】
```c
1. eor ^= xxx遍历xxx = a ^ b, 因为 a != b, 一定某一位为1
2. ans = eor & (-eor) // 找到该1，该位置上 a 和 b，一定不一样.===> 利用该数值进行分类
//数组可以分为两类，第一类该位=1，第二类该位=0
3. a = eor1 ^= 遍历，第三位 = 1的数 // 第一类中，偶数个其他数 + 奇数次的a或者b
4. b = eor1 ^ eor// 拿到另一个数
```
思路总结：
1. eor = 所有数据异或 = a ^ b
2. 找到eor中右侧第一个为1的数，a和b既然不一样，一定有
3. a = 所有该位=1的数 异或
4. b = eor ^ a 消除
题目五：数组中一种数出现k次，其他数出现M次，`M>1 K<M`,找到出现了K的数字，额外空间复杂度O(1) ===>【137. 只出现一次的数字 II】
比如：一个数出现3次，其他的出现5次。
```c
1. int t[32] = new int[32]; // O(1)
2. 所有数字的每一位加到数组中  // t[0] = 37, 所有在第0位有1的数都加进来了。3次的有甲个，5次的有乙个。一定是M的整数倍 + K
```
## 链表
【剑指 Offer 24. 反转链表】
【83. 删除排序链表中的重复元素】
【237. 删除链表中的节点】
【203. 移除链表元素】


