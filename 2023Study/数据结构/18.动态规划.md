

# 动态规划


哪些递归没必要改成动态规划？

递归是知道怎么算的算法
动态规划是知道怎么试的算法

重复调用的递归，很适合改成动态规划。

## 一维动态规划

### 509.斐波那契数列

时间复杂度O(n)
> 最优解是矩阵快速幂，可以做到O(logn)

`F(i)=F(i-1)+F(i-2)`

左边界必然是O(n)，但是有右侧分支(有毛刺)，用缓存后，将右侧毛刺优化。只是增加常数项。


### 983.最低票价

// 动态规划P983


1. 注意到了什么？
> * 需要dp进行缓存
> * 需要进行递推
2. 采取了什么行动？
> * 使用dp，后面采用dp数组
> * 需要从i=0到n进行推导
3. 犯了哪些错误？
> * 没有考虑边界
> * 需要考虑dp是数组形式，因为每个数据是从多个可能的数据中获取的
> * 应该是从顶部到底部的推导，因为顶部的数据，收到的影响最小
4. 可以怎样去改变？
> * 开场罗列所有边界情况，并处理
> * 分析需要dp还是dp数组
> * 需要仔细考虑是从底部还是从顶部，开始推导



### 91_解码方法

> 动态规划
> 推荐从尝试入手，出了问题很好调整，不需要像dp一样考虑边界和考虑code问题

```java
    /**
     * 思考：
     * 1. 一维dp，dp[S最大值+1]
     * 1. 从低到顶，还是从顶到底。"1234567890" 应该是从底部开始推导。dp[i] = 前面不需要自己,自己不为0 dp[i-1]， + 自己为0，前面需要自己 dp[i-2]
     * 举例：
     * dp[0] = 1,前面不需要自己 1种
     * dp[1] = 2, 前面不需要自己（1和2）1种 + 前面需要自己（12）一种
     * dp[2] = 3种,前面不需要自己（1和2和3+12和3）2种 + 前面需要自己（1和23）1种。列举一下 1,2,3 12,3 1,23
     * 1. 边界条件判断
     * <p>
     * 1. 注意到了什么？
     * 注意到了需要考虑到条件，需要避免dp[i-1]和dp[i-2]的情况
     * 2. 采取了什么行动？=> 分条件判断
     * 3. 犯了哪些错误？
     * 1. 缺少一个条件判断和考虑
     * 2. dp[0]的情况没有直接提供，导致多了一层判断
     * 3. dp[1]的数据，应该直接给出，避免后面冗余的条件判断
     * 4. 可以怎样去改变？
     * 将可能超出边界的条件，进行预先处理，作为BaseCase
     * <p>
     * 0ms击败 100.00% 使用 Java 的用户
     * <p>
     * // 感受：一维数组，空间优化，很有限
     */
    public int numDecodingsOld(String s) {
        if (s == null || s.length() < 1) return 0;
        int n = s.length();
        char[] w = s.toCharArray();
        int dp[] = new int[n + 1];

// 1-BaseCase dp[0]
        if (w[0] > '0' && w[0] <= '9') {
            dp[0] = 1;
        }

// 2-BaseCase  dp[1]
        if (n > 1) {
            if (w[1] > '0' && w[1] <= '9') {
                dp[1] += dp[0]; // 前面不需要自己, 并且自己不是0，可以符合要求
            }
            if (w[0] != '0' && ((w[0] - '0') * 10 + (w[1] - '0')) <= 26) {
                dp[1] += 1; // 自己就是一个结果
            }
        }
// 3-考虑普遍情况
        for (int i = 2; i < n; i++) {
            if (w[i] > '0' && w[i] <= '9') {
                dp[i] += dp[i - 1]; // 前面不需要自己, 并且自己不是0，可以符合要求
            }
// 前面需要自己
            if (w[i - 1] != '0' && ((w[i - 1] - '0') * 10 + (w[i] - '0')) <= 26) {
                dp[i] += dp[i - 2]; // 前面需要自己, 并且在1~26的范围
            }
        }
        return dp[n - 1];
    }
```

### 639_解码方法_II

```java

/**
*
*1. 舒适区之外  => 写代码难受
*2. 反馈 => LeetCode反馈是否正确
*3. 提供正确的问题，解答问题  => 问什么好呢？
*4. 实干 >>> 知晓 => 编码更重要
*5. 特定目标 => 1. 能够很好地分析题目 2. 能分析中其中涉及的知识模块 3.分析会采用的技术
*6. 有效的训练方法 => LeetCode
*7. 针对性 => 针对动态规划

*三省吾身：
*1. 注意到了什么？ => 1.很像普通版本 2.需要考虑多种情况 3.用dp动态规划
*2. 采取了什么行动？ => 编码中罗列可能的场景
*3. 犯了哪些错误？ => 1.题目就没看明白 2.需要提前分析场景，罗列好 3.场景太多了，很混乱
*4. 可以怎样去改变？ => 1.多看一些题目，自己仔细去理解。 2. 是否应该用递归方式去尝试？
*/

```

### 264_丑数_II


## 二维动态规划