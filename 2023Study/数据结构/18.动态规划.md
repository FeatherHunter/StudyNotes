

# 动态规划


哪些递归没必要改成动态规划？

递归是知道怎么算的算法
动态规划是知道怎么试的算法

重复调用的递归，很适合改成动态规划。

## 一维动态规划

### 509.斐波那契数列

时间复杂度O(n)
> 最优解是矩阵快速幂，可以做到O(logn)

`F(i)=F(i-1)+F(i-2)`

左边界必然是O(n)，但是有右侧分支(有毛刺)，用缓存后，将右侧毛刺优化。只是增加常数项。


### 983.最低票价

// 动态规划P983


1. 注意到了什么？
> * 需要dp进行缓存
> * 需要进行递推
2. 采取了什么行动？
> * 使用dp，后面采用dp数组
> * 需要从i=0到n进行推导
3. 犯了哪些错误？
> * 没有考虑边界
> * 需要考虑dp是数组形式，因为每个数据是从多个可能的数据中获取的
> * 应该是从顶部到底部的推导，因为顶部的数据，收到的影响最小
4. 可以怎样去改变？
> * 开场罗列所有边界情况，并处理
> * 分析需要dp还是dp数组
> * 需要仔细考虑是从底部还是从顶部，开始推导



### 91_解码方法

> 动态规划
> 推荐从尝试入手，出了问题很好调整，不需要像dp一样考虑边界和考虑code问题

```java
    /**
     * 思考：
     * 1. 一维dp，dp[S最大值+1]
     * 1. 从低到顶，还是从顶到底。"1234567890" 应该是从底部开始推导。dp[i] = 前面不需要自己,自己不为0 dp[i-1]， + 自己为0，前面需要自己 dp[i-2]
     * 举例：
     * dp[0] = 1,前面不需要自己 1种
     * dp[1] = 2, 前面不需要自己（1和2）1种 + 前面需要自己（12）一种
     * dp[2] = 3种,前面不需要自己（1和2和3+12和3）2种 + 前面需要自己（1和23）1种。列举一下 1,2,3 12,3 1,23
     * 1. 边界条件判断
     * <p>
     * 1. 注意到了什么？
     * 注意到了需要考虑到条件，需要避免dp[i-1]和dp[i-2]的情况
     * 2. 采取了什么行动？=> 分条件判断
     * 3. 犯了哪些错误？
     * 1. 缺少一个条件判断和考虑
     * 2. dp[0]的情况没有直接提供，导致多了一层判断
     * 3. dp[1]的数据，应该直接给出，避免后面冗余的条件判断
     * 4. 可以怎样去改变？
     * 将可能超出边界的条件，进行预先处理，作为BaseCase
     * <p>
     * 0ms击败 100.00% 使用 Java 的用户
     * <p>
     * // 感受：一维数组，空间优化，很有限
     */
    public int numDecodingsOld(String s) {
        if (s == null || s.length() < 1) return 0;
        int n = s.length();
        char[] w = s.toCharArray();
        int dp[] = new int[n + 1];

// 1-BaseCase dp[0]
        if (w[0] > '0' && w[0] <= '9') {
            dp[0] = 1;
        }

// 2-BaseCase  dp[1]
        if (n > 1) {
            if (w[1] > '0' && w[1] <= '9') {
                dp[1] += dp[0]; // 前面不需要自己, 并且自己不是0，可以符合要求
            }
            if (w[0] != '0' && ((w[0] - '0') * 10 + (w[1] - '0')) <= 26) {
                dp[1] += 1; // 自己就是一个结果
            }
        }
// 3-考虑普遍情况
        for (int i = 2; i < n; i++) {
            if (w[i] > '0' && w[i] <= '9') {
                dp[i] += dp[i - 1]; // 前面不需要自己, 并且自己不是0，可以符合要求
            }
// 前面需要自己
            if (w[i - 1] != '0' && ((w[i - 1] - '0') * 10 + (w[i] - '0')) <= 26) {
                dp[i] += dp[i - 2]; // 前面需要自己, 并且在1~26的范围
            }
        }
        return dp[n - 1];
    }
```

### 639_解码方法_II

```java

/**
*
*1. 舒适区之外  => 写代码难受
*2. 反馈 => LeetCode反馈是否正确
*3. 提供正确的问题，解答问题  => 问什么好呢？
*4. 实干 >>> 知晓 => 编码更重要
*5. 特定目标 => 1. 能够很好地分析题目 2. 能分析中其中涉及的知识模块 3.分析会采用的技术
*6. 有效的训练方法 => LeetCode
*7. 针对性 => 针对动态规划

*三省吾身：
*1. 注意到了什么？ => 1.很像普通版本 2.需要考虑多种情况 3.用dp动态规划
*2. 采取了什么行动？ => 编码中罗列可能的场景
*3. 犯了哪些错误？ => 1.题目就没看明白 2.需要提前分析场景，罗列好 3.场景太多了，很混乱
*4. 可以怎样去改变？ => 1.多看一些题目，自己仔细去理解。 2. 是否应该用递归方式去尝试？
*/

```

### 264_丑数_II

丑数有更好的三指针移动逻辑

丑数题目和动态规划有什么关系？

题目六：最长有效括号 32. 最长有效括号

940的规则是怎么来的？
题目7和8，考虑的是26个字符结尾，打破了位置进行dp的规则。


动态规划：做过就会，不做过就不会




## 二维动态规划


1. 从递归到二维动态规划
2. 二维动态规划的空间压缩技巧
3. 哪些递归不适合动态规划：可变参数不会比int更复杂 (如记忆化走一个单词)

1个可变参数完全决定返回值，一维动态规划
2个可变参数完全决定返回值，二维动态规划

动态规划表大小：每个可变参数，范围，相乘
动态规划时间复杂度：动态规划表大小 * 每个格子枚举代价

二维动态规划：需要整理，动态规划表格子之间的依赖关系

如何寻找依赖关系？画图建立空间感
> 依然从简单格子填写到复杂格子（严格位置依赖的动态规划，从底到顶）

空间压缩：细心画图，整理依赖关系，最后实现空间压缩
方法：
1. 两个数组滚动
2. 一个数组（细致的画图）


### 115_不同的子序列

```java
public int numDistinct(String s, String t) {
/**
* dp[i][j] 前i个生成子序列，有多少个是等于t的严格前j个的
* dp[n][m]为答案
* 不考虑当前i 1.dp[i][j] = dp[i-1][j] // 不管当前i字符，数量最起码等于i上一个字符的dp
*   考虑当前i 2. s[i-1] = t[j-1], dp[i][j] += dp[i-1][j-1] // 两个字符相等，
*/
char sa[] = s.toCharArray();
char ta[] = t.toCharArray();
int N = sa.length;
int M = ta.length;
int dp[][] = new int[N+1][M+1];
dp[0][0] = 1; // 两个空字符串一定是相等的哦
for (int i = 1; i <= N; i++) {
for (int j = 0; j <= M; j++) {
if(j == 0){
dp[i][j] = 1;
}else{
dp[i][j] = dp[i-1][j];
if(sa[i-1] == ta[j-1]){
dp[i][j] += dp[i-1][j-1];
}
}
}
}
return dp[N][M];
}
```
空间优化
```java
// 空间优化 4ms 95.74 39.70mb 92.70%
public int numDistinct(String s, String t) {
char sa[] = s.toCharArray();
char ta[] = t.toCharArray();
int N = sa.length;
int M = ta.length;
int dp[] = new int[M+1];
dp[0] = 1; // 两个空字符串一定是相等的哦
for (int i = 1; i <= N; i++) {
for (int j = M; j >= 0; j--) {
if(j == 0){
dp[j] = 1;
}else{
if(sa[i-1] == ta[j-1]){
dp[j] += dp[j-1];
}
}
}
}
return dp[M];
}
```

### LCR_096_交错字符串
```java
    // 原始动态规划：2ms 95.02% 40MB 9.05%
    // 空间优化：1ms 98.19% 39MB 91.85%
    public boolean isInterleave(String s1, String s2, String s3) {
        // dp[i][j] s1的i-1，s2的j-1，是否可以组成s2[0...i+j-1]
        if (s3.length() != s1.length() + s2.length()) return false;
        // 1、i=j=0=true
        char[] a = s1.toCharArray();
        char[] b = s2.toCharArray();
        char[] t = s3.toCharArray();
        int N = a.length;
        int M = b.length;
        boolean[] dp = new boolean[M+1];
        dp[0] = true;
        for (int j = 1; j <= M; j++) {
            dp[j] = dp[j-1] && b[j-1] == t[j-1];
        }
        // 填充dp
        for (int i = 1; i <= N ; i++) {
            for (int j = 0; j <= M; j++) {
                if(j == 0){
                    dp[0] = dp[0] && a[i-1] == t[i-1];
                }else{
                    dp[j] = (dp[j-1] && t[i+j-1] == b[j-1]) || (dp[j] && t[i+j-1] == a[i-1]);
                }

            }
        }
        return dp[M];
    }
```




