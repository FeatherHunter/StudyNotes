JVM知识点梳理

本文链接：https://blog.csdn.net/feather_wch/article/details/132326246

[toc]

# JMM


## 定义
1、什么是内存模型？
1. 在特定操作协议下，对特定内存和高速缓存读写的过程的抽象

2、JMM的作用是什么？
1. 解决缓存一致性和指令重排序导致的安全问题
2. 屏蔽具体的平台，保证CPU对内存访问效果一致

3、JMM的主要目的
1. 定义程序中变量的访问规则：存储和读取
2. 只针对线程共享变量：静态字段、实例字段、构成对象数组的元素
3. 线程私有变量：局部变量、方法参数不在考虑范围内


## 特点

1、JMM内存结构：分为主内存、工作内存，工作内存对应于高速缓存区
1. 所有变量存储在主内存
2. 工作内存中放副本
3. 程序运行时主要访问工作内存

## 目的

1、JMM的目的是什么？
1. 避免数据竞争的干扰


### 变量

2、JMM如何保证变量的并发问题
1. 线程私有
1. 线程共享===>原子操作

## 缓存一致性

1、MESI：M-修改，E-独享互斥，S-共享，I-无效

2、缓存一致性协议是什么？
1. 多个CPU从主内存读取数据到各自的高速缓存中
2. 某个CPU修改缓存内数据，会立马同步到主内存
3. 其他CPU会通过总线嗅探机制，感知到，并且让自己缓存内数据失效

3、缓存加锁是什么?CPU的缓存写回内存会导致其他CPU的缓存失效（基于MESI）

### CPU高速缓存区

缘由：高速缓存区（Cache）作为CPU和内存中间：数据复制入Cache中，运算结束放回内存。缓解CPU和内存速度有几个数量级的差距

#### 缓存一致性

多个CPU有缓存一致性问题，如果出现缓存数据不一致以谁的为准？
> 各个CPU采取一定协议：MSI、MESI等


#### 私有工作内存
1、每个线程都有私有工作内存，操作副本其他线程无法感知到，可见性问题 => volatile
```java
线程一：
while(!initFlag){} // 循环
线程二：
initFlag = true
```
### 协议MESI
#### 总线嗅探机制 ==> MQ
## 重排序
### 三种

1、重排序分为三类
1. 即时编译器的指令重排序
2. CPU的乱序执行
3. 内存系统的重排序

2、指令重排序为什么会导致问题？
1. 数据竞争

3、JMM如何避免指令重排序？
1. 内存屏障


### as-if-serial

1、重排序需要遵守as-if-serial原则

2、as-if-serial是什么？
1. 在单线程的情况下，有顺序执行的假象
1. 假如数据互相依赖，不会重排序

### HB

1、JMM和HB是什么？
1. JMM的核心关键点在于构建一个跨线程的HB关系


2、无需同步手段就能成立的HB原则，有且仅有八种
1. 程序次序规则：线程内，按照控制流顺序，书写在前面的操作 HB 书写在后面的操作
2. 管程锁定规则：对一个锁的unlock操作，HB，对同一个锁的lock操作（时间顺序上）
3. volatile：volatile的写操作，HB，对同一字段读操作
4. 线程启动：start，HB，线程的第一个操作
5. 线程终止：线程中最后一个操作，HB，线程的终止检查
6. 线程中断：对线程interrupt，HB，线程收到的中断事件
7. 对象终结：对象构造器的最后一个操作，HB，finalize()
8. 传递性:A HB B， B HB C， A HB C

3、Happen-Before不代表时间上先发生
4、时间上先发生也不代表Happen-Before

### 三大特征

1、JMM的构建是围绕三大原则的
1. 有序性
2. 可见性
3. 原子性

2、JMM如何保证原子性的？
1. 提供了原子性操作：read load use assign store write
2. 提供了更大范围的原子性：lock和unlock指令
3. 提供了更高层面字节码指令：monitorenter、monitorExit（对应于synchronized）

3、JMM如何保证有序性？
1. volatile、synchronized保证线程间操作的有序性
2. 禁止指令重排序
3. 持有同一锁的两个代码块串行进入

4、JMM如何保证可见性？
1. 可见性：一个线程修改了变量，其他线程立即可见
1. JMM规定变量修改后会同步回主内存，变量读取前从主内存刷新
2. volatile是变量修改后立即同步回主内存，变量读取前立即刷新
3. Java中可见性关键字：volatile、synchronized、final


### 内存屏障
1、JVM内存屏障有哪些类型？
1. 读读，loadload
2. 读写，loadstore
3. 写写，storestore
4. 写读，storeload

2、JVM如何实现这些屏障的
1. 代码中读读、读写、写写，方法都是acquire()，X86底层是空指令
2. 写读，方法是fence()，fence底层是lock指令。底层是`刷新写缓存指令`

3、lock指令的作用
1. 本身不是内存屏障，但可以实现内存屏障的效果

4、volatile instance的赋值，instance = xxx，内存屏障是如何做的？
```
StoreStore
putStatic
StoreLoad,加内存屏障
```
#### volatile
1、volatile适合什么场景？有什么限制？
1、volatile两个作用
1. 禁止指令重排序
2. 保证可见性

2、volatile如何做到禁止指令重排序的？
1. 内存屏障
2. 底层是汇编指令，x86上写读是lock相关指令，读读，读写，写写是no-op(空指令)

3、volatile如何保证可见性？
1. 汇编指令，写读，情况下 lock前缀的x86指令，保证两个效果
2. 1-会锁定缓存数据数据对应在主内存中的内存地址，将当前CPU的缓存行数据 立即写回到主内存
3. 2-写操作，会导致其他CPU缓存了该内存地址的缓存数据失效（MESI）

1、volatile是什么？
1. JMM的最轻量的同步机制
1. volatile变量具有可见性
   1. volatile变量对其他线程可见（写操作立即反映到其他线程）
   2. 只能保证拿到的变量值是最新的，不能保证哪个结果被同步回主内存
2. 具有有序性: 禁止指令重排序
   1. 双重检查加锁：避免对象半初始化问题

2、volatile线程不安全
1. 不保证原子性：运算操作不是原子性的

3、volatile什么情况下是线程安全的？
1. 运算结果不依赖变量当前值 ++ --
2. 变量不和其他状态变量共同参与不变约束：a >= b

4、非volatile指令重排序问题
```
线程A：1和2交换顺序
1. 初始化
1. initFlag = true
线程B：
1. 判断 initFlag = true
1. 使用相关内容 // 会出错，根本没初始化完成
```


## 内存间交互操作

1、八大数据原子操作
1. 主内存 传输到 工作内存: read
2.       存储到 工作内存: load
3. 工作内存 传输到 执行引擎: use
4. 执行引擎 赋值到 工作内存：assign
5. 工作内存 传输到 主内存：store
6.         写入到 主内存：write
7. lock：主内存变量加锁   => 表示变量进入线程独占状态
8. unlock：主内存变量解锁

2、什么是原子操作？不可以再细分
