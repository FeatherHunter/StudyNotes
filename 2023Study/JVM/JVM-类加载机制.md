## 类加载机制
1、类加载机制是什么？
1. 将二进制字节流从文件、网络、磁盘中读取出来，通过加载、链接、初始化，形成在JVM方法区的动态数据结构。也就是Class对象。
2. JVM可以直接使用Class对象，创建对象。

2、Java的动态扩展依赖于什么？
1. 依赖动态加载和动态链接
2. 动态加载：运行时指定实现类，用预置或者自定义类加载器从网络等地方加载二进制流，作为程序的一部分
3. 如：Applet(废弃)、JSP、OSGI(OSGi是一种Java的动态模块化系统框架)

3、类加载有哪些阶段？
1. 加载
2. 链接：验证、准备、解析
3. 初始化

4、类对象的生命周期
1. 加载、链接、初始化
2. 使用
3. 卸载

5、注意：类加载的顺序，都是指开始顺序，具体内部工作是交叉混合进行的。

### 前言：立即初始化/触发类加载
1、必须理解类加载的五种情况（主动引用）
1. new关键字实例化对象   ===================================>对象初始化本身不属于创建对象的流程，是new指令后面携带了invokeSpeical指令。
2. 子类的类加载，如果父类没有类加载，触发父类的类加载（接口只会对真正用到的父接口进行类加载）
3. 引用类的静态字段（final字段除外）
4. 调用类的静态方法
5. 反射调用

2、被动引用不会触发类加载
1. 通过子类引用父类的静态字段：只会触发父类，不会触发子类
2. 数组定义引用的类 Person[]
3. 引用类的final修饰的静态字段(常量)
> 常量会被编译时写入到Class文件的字段表集合中属性表集合里面的ConstantValue属性

### 加载
1、加载做了什么？三件事
1. 用类的全限定名来获取定义此类的二进制字节流 =================================> 类加载器，BootClassloader,PathClassLoader,DexClassLoader。PathClassLoader在ZygoteInit源码中，可以发现反射调用App的ActivityThread的main方法时传入了PathClassLoader
2. 将流所代表的静态存储结构，转换为，方法区中运行时数据结构
3. 在Heap中生成Class对象，作为访问入口，通过该对象 ，可以访问该类在方法区内的运行时数据结构、

2、类加载阶段，开发者可以通过自定义类加载器局部参与，整体都是JVM主导

### 链接

#### 验证

1、验证阶段的作用是什么？
> 确保Class文件的字节流符合规范（避免恶意代码）

2、验证分为四阶段
1. 文件格式：魔数和版本号，通过验证后，才允许二进制字节流存储在JVM内存的方法区中，后续操作都是直接操作方法区的运行时数据结构。
2. 元数据：对类的元数据信息，进行语义验证（如继承关系是否正确）
3. 字节码：对类的方法体进行验证 ========================> Class文件中的Code属性
4. 符号引用：1. 对各类信息进行匹配性校验，如符号引用能付找到对应类 （确保解析阶段没问题）2.发生在解析阶段(将符号引用->直接引用) =========================> NoClassDefFoundError

#### 准备

1、准备阶段做了什么？
1. 为类的static变量，分配内存，并且设置为零值。（因此类变量不需要一定设置初始值）
2. static final 常量，会通过ConstantValue属性 设置数值。
> static 变量，设置初始值，在类初始化阶段，调用clinit

2、类变量分配的内存在哪儿？
1. 类变量在方法区只是逻辑概念
2. 实际上可以在方法区也可以在Heap

#### 解析

1、解析阶段是干什么的？（静态解析）
1. 将常量池的符号引用替换为直接引用

2、解析的四个阶段
1. 类和接口解析：符号引用，转换为。直接引用
2. 字段解析：1.先解析其所属类或者接口的符号引用 2.按照规则寻找简单名称和字段描述符都匹配的字段，返回直接引用。
3. 方法解析：1.先解析其所属类的符号引用 2.按照规则寻找简单名称和方法描述符都匹配的字段，返回直接引用。
4. 接口方法解析：1.先解析其所属接口的符号引用 2.按照规则寻找简单名称和方法描述符都匹配的字段，返回直接引用。

3、解析出来的直接引用存放到方法区的运行时数据结构中。

4、什么是直接引用？
1. 直接指向目标的指针
2. 偏移量
3. 能间接定位到目标的句柄

5、解析可以在之后完成：动态绑定

6、JVM只规定了在执行前解析即可

### 初始化

## 并发

1、synchronized修饰普通方法和静态方法的区别是什么？
1. 底层monitorenter指令，参数需要传入对象。
2. 对象和类对象

2、什么是可见性？
1. JMM构建的目的是在并发情况下构建HB关系避免数据竞争
2. JMM是建立在原子性、有序性、可见性之上的
3. 可见性：前面的操作对后面的操作是可见的
4. 可见性由volatile和synchronized保证
5. JMM定义了有且仅有八种HB规则
```
1. 线程内程序次序规则：在控制流顺序上，书写在前的HB书写在后面的。
1. 线程间有6种：volatile之前HBvolatile之后的
1. 解锁操作，HB，之后对同一把锁的上锁操作
1. 线程start HB，线程执行的第一行代码
1. 线程最后一行代码，HB，线程销毁代码
1. 线程的中断消息，HB，对中断状态的查询
1. 对象的构造方法，HB，finalize
1. HB传递性，A HB B,B HB C，A HB C
```

3、锁的分类

4、CAS原理

5、ReentrantLock原理

6、AQS原理

7、synchronized原理

8、volatile能否保证线程安全？在DCL上的作用是什么？

9、volatile和synchronized的区别是什么？

10、什么是守护线程？

11、如何退出一个线程？

12、sleep、wait、yield的区别？wait线程如何唤醒？sleep可以中断吗？

13、线程生命周期

14、ThreadLocal是什么？

15、线程池的基本原理？
1. 减少消耗，提高响应速度，提供管理能力
2. 参数的作用，工作机制
3. 流程、线程数量如何选择？拒绝策略。

线程数量限制
1. 操作系统线程数量限制
2. 文件描述符数量限制
3. 句柄数量限制
4. 资源限制：内存，一个线程1MB

线程有哪些状态？

线程启动方式

## 对象

### 对象创建

类加载检查：
new指令，先检查其参数，是否可以在常量池中定位到一个类的符号引用，并检查符号引用对应的类是否已经被加载、链接、初始化。如果没有走类加载流程

分配内存空间：
1.大小在类加载阶段确定
2.堆空间分配需要同步，避免剐蹭
3.方法有：TLAB或者指针碰撞用CAS+失败重试机制

初始化为零值：将内存空间内容都设置为0

设置对象头：
1.将信息放入对象头。类构造方法clinit是在类加载流程的初始化阶段完成的

引用入栈：

调用构造方法：
1.创建后，执行class文件的init方法。（由new指令后是否有invokespecial指令决定，程序中new关键字会同时生成该两条指令）

### 对象结构

### 对象访问

对象访问有两种：

#### 句柄访问

Java本地变量表有reference引用指向句柄池。

Java堆中有句柄池，有两种指针，指向对象实例和方法区的类型元数据
多一次间接访问的开销。

#### 直接访问
refrence指向堆中对象，对象有类型指针，指向方法区。

### Java对象内存布局
1. Java创建对象的五种方式
2. 父类的private字段，以及父类被隐藏的实例字段，都会分配内存

对象头 8+8=16byte
压缩指针：12byte

Java用基本数据类型的好处：
1. 占用内存小
2. 可以借助CPU缓存机制
3. 数组，可以直接取值，地址连续

#### 内存对齐
1. 对象：偶地址CPU取数据只需要一次
2. 字段：
   1. 字段只在CPU同一缓存行，不然可能1个字段跨缓存行
   2. 字段读取需要替换两个缓存行
   3. 字段存储需要脏两个缓存行
@contented 不虚共享，但会影响字段重排序
