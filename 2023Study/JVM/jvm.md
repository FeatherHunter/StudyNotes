



# JMM
## 定义
1、JMM的定义是什么？
## 特点
## 目的
1、JMM的目的是什么？
### 变量
2、JMM如何保证变量的并发问题
1. 线程私有
1. 线程共享===>原子操作
## 缓存一致性
1、MESI：M-修改，E-独享互斥，S-共享，I-无效
2、缓存一致性协议是什么？
1. 多个CPU从主内存读取数据到各自的高速缓存中
2. 某个CPU修改缓存内数据，会立马同步到主内存
3. 其他CPU会通过总线嗅探机制，感知到，并且让自己缓存内数据失效

3、缓存加锁是什么?CPU的缓存写回内存会导致其他CPU的缓存失效（基于MESI）
### CPU高速缓存区
#### 私有工作内存
1、每个线程都有私有工作内存，操作副本其他线程无法感知到，可见性问题 => volatile
```java
线程一：
while(!initFlag){} // 循环
线程二：
initFlag = true
```
### 协议MESI
#### 总线嗅探机制 ==> MQ
## 重排序
### 三种
### as-if-serial
1、指令重排序后乱序执行但是会有顺序执行的错觉
1. 假如数据互相依赖，不会重排序
### HB
1、HB八大原则
1. 锁，解锁操作 HB 之后对同一锁的加锁操作。unlock HB lock
2. 

2、HB解决了并发什么问题？
### 三大特征
### 内存屏障
1、JVM内存屏障有哪些类型？
1. 读读，loadload
2. 读写，loadstore
3. 写写，storestore
4. 写读，storeload

2、JVM如何实现这些屏障的
1. 代码中读读、读写、写写，方法都是acquire()，X86底层是空指令
2. 写读，方法是fence()，fence底层是lock指令。

3、lock指令的作用
1. 本身不是内存屏障，但可以实现内存屏障的效果

4、volatile instance的赋值，instance = xxx，内存屏障是如何做的？
```
StoreStore
putStatic
StoreLoad,加内存屏障
```
#### volatile
1、volatile适合什么场景？有什么限制？
1、volatile两个作用
1. 禁止指令重排序
2. 保证可见性

2、volatile如何做到禁止指令重排序的？
1. 内存屏障
2. 底层是汇编指令，x86上写读是lock相关指令，读读，读写，写写是no-op(空指令)

3、volatile如何保证可见性？
1. 汇编指令，写读，情况下 lock前缀的x86指令，保证两个效果
2. 1-会锁定缓存数据数据对应在主内存中的内存地址，将当前CPU的缓存行数据 立即写回到主内存
3. 2-写操作，会导致其他CPU缓存了该内存地址的缓存数据失效（MESI）
## 内存间交互操作
# 对象
## 组成部分
1、对象的内部结构
1. 对象头
2. 实例数据(Data1、Data2)
3. Padding
### 对象头
1、对象头组成部分
1. MarkWord
2. 类型元数据指针
3. 数组对象长度

2、对象头的MarkWord包含哪些数据？
1. 偏向锁、偏向线程ID、锁状态、 ====> 锁升级
2. hashcode
3. 分代年龄 ===> GC

3、Markword在不同锁状态下的内容
||||||
|---|---|---|---|---|
|无锁|hashcode|对象分代年龄|0|01|
|偏向锁|thread id|对象分代年龄|1|01|
|轻量级锁|指向栈中LockRecord的指针|||00|
|重量级锁|指向重量级锁的指针|||10|
|GC||||11|

4、为什么起始地址需要是8字节的整数倍？
1. 实验出的寻址最优解（硬件级别大量实验）

5、如何打印对象的内部组成？
> ClassLayout.parseInstance(user).toPrintable()

6、字节序
1. 大端字节序：高位字节在低地址，方便人类阅读，网络传输 ==================>
2. 小端字节序：低位字节在低地址，计算机效率高 ====> MMKV

## 对象创建

1、对象创建流程
1. 类加载检查
2. 分配内存空间
3. 初始化零值：内存空间都设置为0，等效于成员变量都设置为零值
4. 设置对象头：Markwork、类型引用、对齐 ===> 对象头
5. init实例初始化 ===> invokespecial
6. 引用赋值

2、对象创建流程中，new指令对应于1，2，3，4

3、volatile，在对象创建流程中，123456步骤上下会插入monitorEnter和monitorExit？

### new指令

1、什么场景下会有new指令
1. new关键字创建对象
2. 对象克隆
3. 对象序列化

# 并发

## synchronized

1、synchronized底层是什么？
1. 底层是monitorenter和monitorexit指令 ==> 体现了JVMM处理原子性时，提供了更高层面的字节码指令

2、synchronized和底层monitorenter需要一个对象参数
1. 当前对象
2. 指定对象
3. 类对象

### 管程

3、synchronized内部加锁真正的是Monitor对象
1. 操作系统中的对象

4、Monitor对象的原理
1. ObjectMonitor:
1. EntryList：阻塞队列，存储获得了Monitor对象锁的线程
2. WaitSet：等待队列，存储调用了wait()而阻塞的线程，会释放锁
3. 1-线程加锁不成功会加到等待队列中（等待队列非EntryList，是另一个数据结构）

5、为什么会有EntryList？同时获得到锁的线程不是只有一个吗？
1. 在某些情况下，多个线程可以同时获得同一个锁
2. 例如：在可重入锁的情况下，同一个线程可以多次获取同一个锁。EntryList以便释放时可以顺序正确。
3. 例如：读写锁时，多个线程持有读锁

## 原子类

1、原子类的性能，最少高一倍多

### CAS

1、原子类借助while+CAS实现 = (自旋)
2、CAS自称无锁是指真的没有锁吗？在CPU层面也是有锁的
3、CompareAndSet源码
```
->Unsafe.java
->Unsafe.cpp
->1. LOCK_IF_MP: 多核CPU返回lock指令 // 加锁，保证多CPU并行安全
->2. cmpxchg: // 原子比较和交换指令 Compare and Exchange
```

4、lock是什么？
1. 缓存行锁
2. 若超过64byte(跨缓存行)会加总线锁

5、lock cmpxchg的解析，为什么原子指令还需要lock？
1. lock前缀时，在执行cmpxchg，会对总线上的其他处理器进行锁定，以防止其他线程对同一共享变量进行并发的修改
2. cmpxchg的操作在多核情况下会有问题，需要lock

6、CAS具有的问题
1. ABA: 加版本号 ===> AtomicStampRefrence
2. 原子性: 

## 锁升级
1、锁升级的流程，以及锁各状态之间如何切换？
```
无状态-001（默认4秒）
|-线程id写入markword（启用偏向锁）
偏向锁-101
|-多个线程轻量竞争，CAS轻量竞争
轻量锁-00
|-自旋不成功，自适应自旋也不行，重度竞争
重量级锁-10 // markword指向monitor
```
```
无状态-001
|-未启用偏向锁
轻量锁-00
```
```
偏向锁-101
|-调用wait，直接进入重量级锁。重量级锁才有的状态。  ====> wait
重量级锁-10
```

2、JVM默认4秒后自动开启偏向锁
1. 4S后new的所有对象都是101，而不是无锁的001
2. 未开启时，加锁，直接到轻量级锁

3、偏向锁或者无锁进入轻量级锁的检查流程
1. 检查对象头，无锁(非重量级锁)，在栈帧中创建LockRecord，CAS将对象头的MarkWord更新为LockRecord指针
2. 成功：进入轻量级锁状态
3. 失败：检查1-MW指向自己的栈帧，代表已经拥有锁，执行（可重入）
4. 检查2-MW指向其他线程的栈帧中LockRecord，代表有竞争，用重度锁

4、锁升级流程
1. 默认无锁，4s后进入偏向锁状态
2. 偏向锁释放时，不作任何操作，方便再次进入时比较threadid
3. 拿锁时，发现有其他线程拿过锁(有竞争)，进入轻量级锁
4. 有竞争（CAS失败n次-代表起码2个线程在竞争），进入重量级锁。指向Monitor对象。

5、CAS自旋10次，或者可能自适应自旋2~3次，进入重锁

6、分代年龄等信息暂存在其他地方，会恢复。

## LongAdder
1、LongAdder用于高并发下替换Atomic类, 高并发计数器

2、LongAdder原理
1. 采用分段CAS
2. 只有一个线程：CAS实现，有base数值
3. 多个线程：cell数组
4. 1-各个线程处理自己的cell1、cell2、cell3
5. 2-最后会求和，得到最终计数（无锁，每个线程负责自己的计数，不会有冲突，求和也不会冲突）
6. 3-数组会根据实际情况增减-有扩容、缩容机制

# QUESTION

1、双重检查加锁的对象半始化问题
1. 对象创建过程中：类加载检查、分配空间、初始化零值、设置对象头、调用init、引用指向该对象(putStatic)
2. 不使用volatile的instance，会导致在init初始化和引用指向该对象重排序的情况下，拿到还未初始化的实例。
3. 不会违背as-if-serial原则和HB原则
4. volatile禁止指令重排序和保证可见性



# 执行引擎

### 字节码

1、下面字节码指令导致的效果是怎么样的？
|地址|指令|
|---|---|
|0|ICONST_1|
|1|ISTORE 0|
|2|ICONST_2|
|3|ISTORE 1|
|4|ILOAD 0|
|5|ILOAD 1|
|6|ADD|
|7|ISTORE 2|
|8|RETURN|

> 阐述在PC、操作数栈、局部变量表中是如何变换的

