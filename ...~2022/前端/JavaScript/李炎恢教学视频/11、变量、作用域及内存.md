1、什么是基本类型值和引用类型值
> 1.基本类型值：简单的数据段（Undefined,Null,Boolean,Stringhe Number）；
> 2.引用类型值：可能由多个值构成的对象（Object）；

2、基本类型值和引用类型值的区别
>- 1.基本数据类型：
> 1. 是按值访问的;
> 2. 可以操作保存在变量中的实际值；
> 3. 保存在栈内存中；
>- 2.引用类型的值：
> 1. 是按引用访问的;
> 2. 是保存在堆内存中的对象，
> 3. 操作对象实际上是操作对象的引用而不是实际的对象；

3、动态的属性
> 1.对于引用类型的值：可以添加，修改属性和方法；
>```
>var person = new Object();
>person.name="John";
>alert(person.name);     //"John"
>```
> 2.对于基本数据类型的值：不能添加属性（不会导致任何错误）
>```
>var name = "Hello";
>name.age=12;
>console.log(name.age);     //undefined
>```

4、复制变量值
> 1.基本数据类型
> 1. 在变量对象上创建一个新值，然后把值复制到新变量分配的位置上；
> 2. 这两个变量互不影响，完全独立。
>```
>var num1=9;
>var num2=num1;
>```
> 2.引用数据类型
> 1. 会将存储在变量对象中的值复制一份放到新变量分配的空间中；
> 2. 复制的实际上是一个指针；
> 3. 这个指针指向存储在堆中的一个对象。
> 4. 两个变量引用同一个对象，改变其中一个变量，会影响另一个变量。

5、传递参数
> 1.ECMAScript中所有函数的参数都是按值传递的；
> 2.把函数外部的值赋值给函数内部的参数，就和把值从一个变量复制到另一个变量一样。
> 3.基本类型值的传递如同基本类型变量的复制一样；
> 4.而引用类型值的传递，如引用类型变量的复制一样。
>```
>function setName(obj){
>  obj.name="Niky";
>  obj = new Object();      //在函数外不认识
>  obj="Kitty";
>}
>var person=new Object();
>setName(person);
>console.log(person.name);    //输出Niky
>```
> **注意点**
> 1.在函数内部修改参数的值，但原始的引用仍然保持未变；
> 2.在函数内部重写参数时，变量引用的就是一个局部变量，
> 3.这个局部变量在函数执行完后立即销毁。

6、检测类型
> 1.基本类型：typeof操作符；
> 2.typeof只能判断是否是object类型，无法确定是哪一个类型，因此，引入了instanceof操作符；
> 3.引用类型：instanceof操作符。
>```
>var person = {};
>console.log(person instanceof Object);          //对象 true
>var reg = /g/;
>console.log(reg instanceof RegExp);             //正则表达式 true
>var arr = ['1','2','3'];
>console.log(arr instanceof Array);              //数组 true
>```

7、执行环境
> 1.定义了变量或函数有权访问的其他数据，决定了它们各自的行为。
> 2.每个执行环境都有个与之关联的变量对象，
> 3.环境中定义的所有变量和函数都保存在变量对象中。
> 4.执行环境中的代码执行完毕后，环境被销毁，其中变量和函数也销毁了。

8、全局执行环境
> 1.是最外围的一个执行环境。
> 2.在web浏览器中，全局执行环境被认为是window对象；
> 3.所有的全局变量和函数都是作为window对象的属性和方法创建的。

9、变量的作用域链
>- 1.作用：保证对执行环境有权访问的所有变量和函数有序访问。
>- 2.执行过程：
> 1. 每个函数调用时，会创建自己的执行环境；
> 2. 执行到这个函数的时候，这个环境会被放到环境栈中；
> 3. 执行结束后，在环境栈中退出；
> 4. 吧控制权交给上一级的执行环境，一直延续到全局执行环境。
>- 3.标识符解析是沿着作用域链一级一级地搜索标识符的过程。（找不到标识符，会导致错误）
>```
>var color="blue";    //全局环境
>function changeColor(){
>  if(color==="blue"){
>    color="red";
>  }else{
>    color="blue";
>  }
>}
>changeColor();
>alert("Color is now "+color);     //red
>```

10、没有块级作用域
> 1.花括号封闭的代码块没有作用域，只有执行环境；
> 2.if语句和for语句的区别（区别不大）：
> 1. if语句中的变量声明会将变量添加到当前的执行环境中；
> 2. 而for语句创建的变量，在循环结束后依然存在循环外部的执行环境。
>```
>if(true){    //if语句中的变量声明会将变量添加到当前的执行环境中，这里是全局环境
>  var color="blue";
>}
>alert(color);        //"blue"
>```
>```
>for(var i=0;i<10;i++){     //for语句创建的变量，在循环结束后依然存在循环外部的执行环境
>  doSomething(i);
>}
>alert(i);            //10
>```

11、声明变量
>- 1.使用var创建的变量会自动被添加到最接近的环境中。
> 1. 在函数内部，最接近的环境是函数的局部环境；
> 2. 在with语句中，最接近的是函数环境。
>- 2.初始化变量时，没有使用var声明，该变量会自动被添加到全局环境中(不建议，在严格模式下，会出错)
>```
>function add(num1,num2){
>  var sum=num1+num2;
>  return sum;
>}
>var result=add(10,20);    //30
>alert(sum);              //sum不是有效的变量，会报错
>```
>```
>function add(num1,num2){
>  sum=num1+num2;        //sum添加到全局环境中
>  return sum;
>}
>var result=add(10,20);    //30
>alert(sum);               //30
>```

12、查询标识符
> 1.搜索过程与作用域链的过程一致。
> 1. 调用getColor()时会引用变量color；
> 2. 开始搜索，先搜索变量对象，未找到；
> 3. 搜索全局环境中的变量，找到了标识符，结束搜索。
>```
>var color="blue";
>function getColor(){
>  return color;
>}
>alert(getColor());        //"blue"
>```
> 2.如果在函数中定义了一个局部变量，过程如下：
> 1. 调用getColor()时会引用变量color；
> 2. 开始搜索，先搜索变量对象，找到了color，值为red，搜索结束。
> **注：如果想访问全局变量，可以使用window.color**
>```
>var color="blue";
>function getColor(){
>  color="red";
>  return color;
>}
>alert(getColor());        //"red"
>```

13、垃圾收集
>- 1.JavaScript具有自动垃圾收集机制。
>- 2.原理：
> 1. 找出不再使用的变量，释放其占用的内存；
> 2. 垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)。周期性的执行这个操作。
>- 3.垃圾收集策略：
> 1. 标记清除；
> 2. 引用计数；

14、标记清除(mark-and-sweep)
> 1.在运行的时候，会给存储在内存中的所有变量都加上标记（可以使用任何标记方式），
> 2.然后，会去掉环境中的变量以及被环境中的变量引用的变量的标记；
> 3.之后，再被加上标记的变量将被视为准备删除的变量，
> 4.原因是，环境中的变量已经无法访问到这些变量了。
> 5.最后，垃圾收集器完成清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

15、性能问题
> 1.垃圾收集器是周期性运行的，如果为变量分配的内存数量很可观，那么回收工作量也很大，
> 2.此时，确定垃圾收集的时间间隔是一个非常重要的问题。
> 3.IE7的发布，JavaScript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。
> 4.如果垃圾收集例程回收的内存分配量低于15%，则字面量，变量和数组元素的临界值就会加倍；
> 5.如果例程回收了85%的内存分配量，则将各个临界值重置为默认值。

16、优化内存
> 1.为执行的代码只保存必要的数据。
> 2.一旦数据无用，就设置为null来释放引用——解除引用；
> 3.适合于大多数全局变量和全局对象的属性。
> 4.局部变量会在离开执行环境时自动被解除。
> **注：解除引用的目的是让值脱离执行环境，以便垃圾收集器下次运行时将其回收**
