1、解构赋值
> 1.是对赋值运算符的扩展；
> 2.一种针对数组或对象进行模式匹配，然后对其中的变量进行赋值；
> 3.书写简洁易懂，语义更加清晰明了。

2、结构模型
> 1.解构的源：解构赋值表达式的右边部分；
> 2.解构的目标：解构赋值表达式的左边部分。

3、数组模型的解构（Array）
> 1.只要等号两边的模式相同，左边的变量就会被赋予对应的值
> 1. 可嵌套的
```
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3
```
> 2. 可忽略的
```
let [ , , third] = ["foo", "bar", "baz"];
third // "baz"
```
> 3. 剩余运算符
```
let [a, ...b] = [1, 2, 3];
//a = 1
//b = [2, 3]
```
> 2.解构不成功：左边的变量值为undefined；
```
let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```
> 3.不完全解构：左边的变量只匹配右边数组的一部分；
```
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```

4、解构默认值
> 1.解构赋值允许执行默认值。
```
let [foo = true] = [];    //foo=true
let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```
> 2.这里的`=`号，使用严格相等运算符`===`，判断一个位置是否有效。只有严格等于undefined时，默认值才会有效。
```
let [x = 1] = [undefined];    // x=1

let [x = 1] = [null];         // x=null
```

5、对象的解构赋值
> 1.数组的元素是按顺序排列的，变量的取值由位置来决定。
> 2.但是，对象的属性没有顺序，变量名必须与属性同名，才能取到对应的值。
> 3.基本
```
let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
// foo = 'aaa'
// bar = 'bbb'

let { baz : foo } = { baz : 'ddd' };
// foo = 'ddd'
```
> 4.可嵌套的
```
let obj = {p: ['hello', {y: 'world'}] };
let {p: [x, { y }] } = obj;
// x = 'hello'
// y = 'world'
```
> 5.可忽略的
```
let obj = {p: ['hello', {y: 'world'}] };
let {p: [x, {  }] } = obj;
// x = 'hello'
```
> 6.剩余运算符
```
let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40};
// a = 10
// b = 20
// rest = {c: 30, d: 40}
```

6、已声明的变量用于解构赋值
> 1.因为`{x}`会理解为一个代码块，从而发生语法错误。
```
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
```
> 2.解决方法：放在圆括号里面
```
// 正确的写法
let x;
({x} = {x: 1});
```
> 3.解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式
```
({} = [true, false]);
({} = 'abc');
({} = []);
```
> 4.由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构
```
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```

7、字符串的解构赋值
> 1.字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象
```
let [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

8、数值和布尔值的解构赋值
> 1.构赋值时，如果等号右边是数值和布尔值，则会先转为对象
```
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```
