1、条件运算符
> 1.（?:）也称为三元运算符，是if...else结构的简化形式。
> 2. 首先是一个判断条件，如果为真，就返回一个值；如果条件为假，则返回另一个值。
> ```
>     //语法结构
>     condition ? true_value: false_value
> ```

2、checked和unchecked运算符
> 1. 作用：打开或者关闭溢出检查。
> 2. 把一个代码块标记为checked，CLR会执行溢出检查，发生溢出，就抛出OverflowException异常。
> 2. 把代码块标记为unchecked，禁止溢出检查，不会抛出异常，但如果存在溢出，会丢失数据。

3、is运算符
> 1. 可以检查对象是否与特定的类型兼容。
> 2. “兼容”表示对象或者是该类型，或者派生自该类型。
> ```
>     //检查变量是否与object类型兼容
>     int i = 10;
>     if(i is object)
>     {
>         WriteLine("i is an object");
>     }
> ```

4、as运算符
> 1. 用于执行引用类型的显式转换。
> 2. 如果要转换的类型与指定的类型兼容，转换就会成功进行；
> 3. 如果类型不兼容，as运算符就会返回null值。
> ```
> object o1 = "Some String";  
> object o2 = 5;  
> string s1 = o1 as string; //s1 = "Some String"  
> string s2 = o2 as string; //s2 = null
> ```

5、sizeof运算符
> 1. 确定栈中值类型需要的长度（单位是字节）。
> 2. 对于复杂类型（而非基本类型），使用sizeof，需要将代码放在unsafe块中。
> ```
>     //基本类型
>     WriteLine(sizeof(int));
>     //复杂类型
>     unsafe
>     {
>         WriteLine(sizeof(Person));
>     }
> ```

6、typeof运算符
> 1. 返回一个表示特定类型的System.Type对象。
> 2. 例如，typeof(string)返回表示System.String类型的Type对象。

7、nameof运算符
> 1. 是新的C#6运算符。
> 2. 该运算符接受一个符号、属性或方法，并返回其名称。

8、index运算符
> 1. 是一个索引运算符。
> 2. 不需要把整数放在括号内，而且可以用任何类型定义。
> ```
>     var dict = new Dictionary<string, int>();
>     dict["first"] = 1;
>     int x = dict["first"];
> ```

9、可空类型和运算符
> 1. 值类型和引用类型的重要区别是，引用类型可以为空，值类型不能为空。
> 2. 但是，C#类型映射到数据库时，数据库中的数值可以为空，此时就需要可空的数据类型。

10、空合并运算符
> 空合并运算符(??)，可以在处理可空类型和引用类型时表示null值得可能性。
> > **注意：**
> > 1. 这个运算符放在两个操作数之间，第一个操作数必须是一个可空类型或引用类型；
> > 2. 第二个操作数必须与第一个操作数的类型相同，或者可以隐式地转换为第一个操作数的类型。
> > >- 如果第一个操作数不是null，整个表达式就等于第一个操作数的值。
> > >- 如果第一个操作数是null，整个表达式就等于第二个操作数的值。

11、空值传播运算符
> 是C#6的一个杰出新功能。
> ```
>     //使用空值传播运算符来访问FirstName属性，当p为空时，就只返回null，而不会继续执行表达式的右侧
>     public void ShowPerson(Person p)
>     {
>         string firstName = p?.FirstName;
>     }
> ```
> > 使用空值传播运算符访问int类型的属性时，不能把结果直接分配给int类型，因为结果可能为空。
> > ```解决方法1
> >     //把结果分配给可空的int
> >     int? age = p?.Age;
> > ```
> > ```解决方法2
> >     //使用空合并运算符，定义另一种结果
> >     int age = p?.Age ?? 0;
> > ```
> > ```解决方法3
> >     //结合多个空值传播运算符
> >     Person p = GetPerson();
> >     string city = null;
> >     if(p != null && p.Address != null)
> >     {
> >         city = p.Address.City;
> >     }
> >     //可以简化为
> >     string city = p?.Address.City;
> > ```

12、类型转换
>- 1、隐式转换
> > 1. 隐式转换是自动进行的，
> > 2. 只能将较小范围的数据类型转换为较大范围的数据类型，否则，会出现数据丢失的风险。
> > > 对于可空类型，有几点需要注意：
> > >- 可空类型隐式地转换为其他可空类型；
> > >- 非可空类型隐式转换为可空类型
> > >- 可空类型不能隐式地转换为非可空类型，必须进行显式转换。
>- 2、显式转换

13、装箱和拆箱
>- 装箱：将值类型转换为引用类型；
>- 拆箱：将引用类型转换为值类型。

14、比较引用类型的相等性
>- 1、ReferenceEquals()方法
> > 1. 这是一个静态方法，其测试两个引用是否指向类的同一个实例，特别是两个引用是否包含内存中的相同地址。
> > 2. 作为静态方法，它不能重写。
> > ```
> >     Someclass x, y;
> >     x = new SomeClass();
> >     y = new SomeClass();
> >     bool B1 = ReferenceEquals(null, null); //returns true
> >     bool B2 = ReferenceEquals(null, x);  //returns false
> >     bool B3 = ReferenceEquals(x, y);  //returns false(指向不同的对象实例)
> > ```
>- 2、Equals()虚方法
> > 因为是虚方法，可以在自己的类中重写它，从而按值来比较对象；
>- 3、静态的Equals()方法
> > 1. 该方法的静态版本与虚实例版本的作用相同，
> > 2. 其区别是金泰版本带有两个参数，并对他们进行相等性比较；
>- 4、比较运算符(==)
> > 最好将比较运算符看作严格的值比较和严格的引用比较之间的中间选项。

15、比较值类型的相等性
> 规则：ReferenceEquals()用于比较引用，Equals()用于比较值，比较运算符可以看作一个中间项。例如`sA.Equals(sB)`

16、ReferenceEquals()方法用于比较引用类型，能否将值类型装箱之后再进行比较？
> 不能。因为ReferenceEquals()方法在转换每个参数时，都会被单独装箱，这意味着就会得到不同的引用，因此，调用这个方法比较值类型没有什么意义。

17、运算符重载

18、实现用户定义的类型强制转换
