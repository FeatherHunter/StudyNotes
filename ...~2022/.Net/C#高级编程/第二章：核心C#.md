1、变量必须初始化么？
> 是的。为了强调安全性，C#编译器必须初始化变量。
> 1. 若未初始化初始化，编译器当成错误；
> 2. 判断是否初始化的方法：
> >- 变量是类或结构中的字段，没有显式初始化，创建的时候会默认为0；
> >- 方法的局部变量必须在代码中显式初始化，如果没有的话，会标记为错误。

2、变量的作用域
> 遵循以下规则：
>- 只要类在某个作用域内，其字段（成员变量）也在该作用域内；
>- 局部变量存在声明该变量的块语句或方法结束之前；
>- 在for，while中声明的局部变量存在于循环体内。

3、变量名能不能相同？
> 能，有两种情况。
> 1. 变量的作用域是程序的不同部分
> 2. C#会把类型级别的变量当成字段，而把方法内的变量当成局部变量(如果要引用类型级别的变量，可以采用"类名.变量名")。
> ```
> public class Test
> {
>     int i = 10;
>     public void Test()
>     {
>         int i = 10;
>     }
> }
> ```

4、常量是什么？
> 1. 常量是其值在使用过程中不会发生变化的变量。
> 2. 在声明和初始化变量的时候，加上const关键字。

5、常量的特点
> 1. 必须在声明时初始化，指定值后，就不能改写了；
> 2. 必须能在编译时用于计算。因此，不能用变量中提取的值初始化常量，如需要这么做，应使用只读字段；
> 3. 总是隐式静态的。不允许使用修饰符static。

6、常量的优点
> 1. 易于阅读。替代了较难读取的数字和字符串；
> 2. 易于修改。
> 3. 避免程序出现错误。

7、数据类型的分类及区别
> 1. 分为两类：值类型和引用类型。
> 2. 区别：
>- 从概念上，值类型直接存储值，而引用类型存储对值得引用；
>- 从内存上，值类型存储在堆栈（stack）中，而引用类型存储在托管堆（managed heap）上；
> > **注意：** 如果两个变量引用同一个对象，这两个变量是相互关联的，若有一个改变，其他的也会改变，相反，值类型就不会改变。

8、预定义值类型分类
> 1、整型
>- 有符号整数（sbyte：8位、short：16位、int：32位、long：64位）
>- 无符号整数（byte、ushort、uint、ulong）

> 2、浮点类型
>- 单精度浮点数：float（32位）
>- 双精度浮点数：double（64位）

> 3、decimal类型
>- 高精度十进制数表示：decimal（128位）

> 4、bool类型（true或false）

> 5、字符类型（char：16位的Unicode字符）

9、预定义的引用类型分类
>- object：根类型，其他类型都是从他派生而来的；
>- string：Unicode字符串。

10、object类型的用途
>- 绑定任何特定子类型的对象，可以用于反射；
>- 用户定义的类使用重写来提供其中一些方法的替代实现代码。

11、string类型中的字符"@"是什么？
> 1. 表示：字符串包含Unicode和十六进制转义序列。
> 2. 转义序列必须以`"\"`开头，所以，在表示反斜杠时必须使用两个`"\\"`，这样比较复杂，就采用`"@"`符号，在这个符号后面的所有字符都看成是原来的含义。

12、字符串插值格式"$"使用方法
> 允许把花括号放在包含一个变量或者代码表达式的字符串中，其结果就放在花括号所在的位置。

> ```
> var temp = 34.34;
> WriteLine($"tempType is {temp.GetType()}");
> 输出结果：tempType is System.Double
> ```

13、枚举的特点
> 枚举是用户定义的整数类型，关键字"enum"
>- 易于维护，确保变量指定合法的值；
>- 更清晰，允许使用描述性的名称表示整数值；
>- 易于输入。
>- 在后台会实例化为派生自基类System.Enum的结构，可以对其调用方法，执行任务。

14、using关键字的作用
>- 列出类的名称空间，在其他地方就可以使用类型名称来引用名称空间中的类型。
>- 给类和名称空间指定别名，名称空间别名的修饰符是"::"。一般情况下，使用名称空间中的类，我们采用"名称空间.类名"，但是，在使用了别名以后，要采用"别名::类名"。
> 例如
>  ```
> using alias = NamespaceName；  //指定别名
> alias::ClassName test=new alias::ClassName();
> WriteLine(test.GetName());     //类ClassName中定义了一个方法GetName
> ```

15、注释的表示方式
> 1、源文件中的内部注释
>- 单行注释使用双斜杠"//..."；
>- 多行注释使用`/*... */`

> 2、XML文档：根据特定的注释自动创建XML格式的文档说明
>- 以3条斜杠开头"///..."

16、预处理器指令有哪些？
> 1、#define和#undef（一般与#if结合使用）
>- #define：告诉编译器存在给定名称的符号
>- #undef：删除符号的定义

> 2、#if、#elif、#else、#endif：告诉编译器是否要编译代码块

> 3、#warning和#error
>- #warning：会向用户显示#warning指令后面的文本，之后编译继续
>- #error：会向用户显示后面的文本，作为一条编译错误消息，然后会立刻退出编译，不会产生IL代码

> 4、#region和#endregion：把一段代码视为有给定名称的一个块，可以使代码更好的布局

> 5、#line：用于改变编译器在警告和错误信息中显示的文件名和行号信息（#line default：把行号还原成默认的行号）

> 6、#pragma：可以抑制或还原指定的编译警告。#pragma指令可以在类或方法级别实现，对抑制警告的内容和抑制的时间进行更精细的控制。
> ```
> #pragma warning disable 169   //禁止"字段未使用"警告
> #pragma warning restore 169   //还原"字段未使用"警告
> ```

17、C#编程准则
> 标识符：给变量、用户定义的类型和这些类型的成员指定的名称。
>- 可以包含数字字符，但他们必须以字母或下划线开头（可以包含Unicode代码）
>- 不能把C#关键字用作标识符（如果要把某一保留字用作标识符，可以在标识符的前面加上前缀符号@，告知编译器其后的内容是一个标识符，而不是关键字）

> 命名约定
> > 1、名称的大小写
> > >- Pascal：名称中单词的首字母大写，例如`EmployeeSalary`
> > >- camel：名称中第一个单词的字母不大写，其他的都大写，例如`employeeSalary`
